/**** (c) Valve Corporation. Use is governed by the terms of the Steam Subscriber Agreement http://store.steampowered.com/subscriber_agreement/.
 ****/
(self.webpackChunkappmgmt_storeadmin =
  self.webpackChunkappmgmt_storeadmin || []).push([
  [6343],
  {
    82554: (e) => {
      e.exports = {
        BurgerWrapper: "_3MSz7L-XuvWfvFpBVftE1d",
        DragCtn: "_2b8yW5EptL3NZIM0kUbBmD",
        Row: "_3Z-k6Tgg_S03GPAXhShlPk",
        CreateNewCtn: "_2aHNC95rlbJ-2Wq3Au7zld",
        NoHidden: "_28H0v-MAYUppGj9ujTvgvW",
      };
    },
    82237: (e) => {
      e.exports = {
        Lock: "_3cqGSrhjuXb6Lw4dojTPEJ",
        BranchDefCtn: "_11WAUIwXjb3rL72ZaRtzdN",
        BranchName: "_3ynqGe3uvkGERYhMf1NQw6",
      };
    },
    43456: (e) => {
      e.exports = {
        DialogBody: "KSlT0UneLB1zpHRwylHVu",
        Identifier: "_2Xy8CetS9wxH_SB6iHopUF",
        DialogIntro: "_3dhpNFAZYMVjWtmhN7dCeG",
        RadioColumn: "_9-nH5Jcd_6ulz54s_05aZ",
        DragTargetCtn: "_1AM376IieEYFXxShihHfyJ",
        PreviewCtn: "_3haphwObDbQPvjmAQjy5S",
        IconPreviewCtn: "_3kkzSe6w1iFoXurO7KAQLp",
        "drag-drop-box": "aYdSQzbLzkCN9cJL0B45q",
        dragging: "_1Qf1VRDr0cRTUVkzOjDUF6",
      };
    },
    87275: (e) => {
      e.exports = {
        GridCtn: "_3aZdpxGUGPNdPlgmQ36X4Z",
        Title: "_2PuQFm-Uj5YLaqn-EJBN8W",
        CtnGridAndBranchSelection: "_3_kNX8WB1RQfUU58NLOkng",
        RestrictedIconsSection: "xnQ8wePEyeWhyKBuWfFNL",
        Columns: "P0LqcYqIoPMpNiIQNqBzo",
        LeftCol: "u-kARSsloZ1bumhOELUFp",
        RightCol: "VlHqUJNvQLHjxVfx8eqon",
        BranchSets: "_1gsbwBi65Y-6b3qDT9_b9A",
        Ctn: "_2_TSqr_PahJsdUr7OUbOtb",
        Header: "_2vGQ8_vi8RhVVYtUDoJb3H",
        SubTitle: "_16kNii34_urQfBwE0zBAQX",
        TopRow: "_2Ikzk3s5grjLZfKS4rmn1-",
        TitleText: "_3maqtebgAEfvjk-ib8CmoC",
      };
    },
    83113: (e) => {
      e.exports = {
        Row: "_3Enetf2TSp3eysYLb7Gr-",
        LargeIcon: "_1MtLAT6eLpozVPmevUsgqU",
        MediumIcon: "_26JGm_1NnXHMgSqM9JGNVe",
        SmallIcon: "_28o4lkB_elG0p3JZiRZStf",
        IconGridCtn: "_1j5Zbtm3I1NFNClVlq4Iv0",
        DraggableBox: "_2PT9jzd7z8YAn7wA9d3lrN",
        MsgUnpublished: "t0ZBz0HtxBsB9bGw8mRM",
        Icons: "_2DAN7CmSHDvbDgASG1HdqS",
        MarkerID: "EBvlSRsAswgZaKRoaUHSz",
        IconContents: "_1QxLGdvoMspodnFxsItlT0",
        EditButton: "_2EQQiFzNO5Cwok7l2r4HXp",
        DragBox: "_23dzP716dQpqS5cKc563Tl",
      };
    },
    36952: (e) => {
      e.exports = {
        EditorCtn: "mCr782p9TpOa_yS4crmr5",
        HeaderCtn: "_31vyCu9RQ4FcloKNaUf8GB",
        Row: "_12SNJrSPcxhX6RkaZXZq86",
        PublishNoteCtn: "_30NmSIrCpnJ9lCOdZqZm6e",
        CalloutTitle: "por_TNP8uIqnxGfaUwx-F",
      };
    },
    73515: (e) => {
      e.exports = {
        Dummy: "_2840rmUpPlQD_u2oirCKXu",
        Selected: "WvAtVArGoU9dj88kJb1G",
        HighlightIcon: "_3rt1qClyPaHAYiVwOSu9Xz",
        CustomMarker: "_3F_GfwciLV6y6FOEIe3_S5",
        MarkerBacking: "_1ft3M77d9XtBcrueBGrbGw",
        HighlightIconSVG: "nt4N5Hp8gRa3CnL6YpyKr",
        Faded: "_3G-TED_y5JFy9DHiymK5Cn",
        Marker: "_3GP2Yb1IBiNxW79A0_H-Q1",
        GameMarkerSVG: "_2FfQ96ZQOySW735_57yKby",
      };
    },
    35009: (e) => {
      e.exports = {
        GoLiveButtonCtn: "_1Ssh6bcQcBm8T6zVNU48G2",
        GoLiveButton: "_1rZeqdwHzajXNoY-uxRgfW",
        IsLive: "_2MGnyLAWN4c3di_W6U3YWJ",
        JumpToEndIcon: "_2FkWFO_BAQnsWrQr-nHvEz",
      };
    },
    99550: (e) => {
      e.exports = {
        LoadingTimeline: "_3AC5PeKRkSoB1JUS8LCinu",
        ScrollAndControlsCtn: "_1CYsmnIqkn90UQTVYK63be",
        GamepadMode: "_1wi1J1l41xYwh6lx7zH4Aw",
        Controls: "_1l2J-z02NZ7-HU23Bk7FwR",
        TimelineScrollContainer: "_3v-bzPuU4mVOvwvq1wX6Z6",
        ContentContainer: "_1Jjb0RXXDDj5JSQTNRIeRi",
        AbsoluteLayer: "_2F0d9JLSNH0gY26UBXIZYS",
        HideOverflow: "_2GDis70-E8G-El7mDlayt8",
        RelativeLayer: "_1xZCNiE6ZMwQsUHLh2y9t1",
        WithPointerEvents: "_12MLk3-t1rqZ33U6DiMKg1",
        RecordingDecorators: "_2PJGDULdt2ctu6R0EkUHPj",
        ClipDecorators: "tbss_z2HLa4Oa0yS4mGrb",
        GameModes: "_1Bh3PscPMEMGlegOtxPEWM",
        DateDecorator: "_2w-ta9UJW1Y73wRilaD9l-",
        BackgroundTicks: "xD30aylfCATSjNrytpUAm",
        Highlights: "_56YDWYPBkNJazWmgg83Sk",
        RangeHighlights: "s20SLnZnerU68G2dHOWRW",
        Timestamps: "xLUyqvUeXIgxuJpmmte1i",
        RangeSelector: "_2vqUVszLX8jrl8soNo84qt",
        SeekScrubber: "_3MV0K4aiJwcuWauL5dt6gY",
        PlayHead: "_37u67bibEd1DUyQFBTBNzb",
        Thumbnails: "_1pOPbtOaUeqeJm3nrdEkyx",
        PositionLeft: "_2lo44W-Sy4zMrYWnl55XBD",
        PositionRight: "_2tl3cTX_fsKtBrtcctB5wc",
        Phases: "_29M5GL7LdzPRq4bOtIu5My",
        ContentAndGradient: "XrJofUthOAZ7wCkD_C2fE",
        ScrollbarPlaceholder: "_1NhP7G104P9VPsp6bTxyBb",
        LeftControlsAndContent: "_1vc8f5bCHfDynpWgwyhf5m",
        ScrollGradientCtn: "rWNgVMPb6DEglMsLileNg",
        FrontGradient: "_2M09urev2z_0keBeRWlFsa",
        HideGradient: "_28_y-RUEZhJpt4in4Wyry9",
        EndGradient: "YzFF90kSvFzYRc4OndPpi",
        ScrollbarAndSiblings: "_34dlBrUZP054ElsvOp5hQm",
        ScrollBarCtn: "_1-ooPvEW2c6SHuhnz6SK3t",
        HideScrollBar: "N-WtiJTQNtp0Tzuw4BmgF",
        ScrollTrack: "NP3DlSRiWZygPWZSLSVX",
        PlayHeadAnnotation: "_32vHJA51iTnZgyk7drRCvc",
        RangeAnnotation: "_2cjQVZ5ycKyb79yPxB-Bms",
        ScrollThumb: "JffqXSW3actHr6hj8F9Sn",
        Highlight: "_1EGQ0DSJx5OOPFoNVz85oF",
      };
    },
    7450: (e) => {
      e.exports = { MouseListenerContainer: "_1t81JirfhcUdp7F73SUzQF" };
    },
    8959: (e) => {
      e.exports = {
        LoadingTimeline: "_3HMMNaShMT1M773fCgCd",
        ScrollAndControlsCtn: "gAhqB_Mx8V-7QYnzQP1eo",
        GamepadMode: "XkOPy2hiLaUWJsZVWC23u",
        Controls: "uwbPYSFyWCkcEbf3b5Y9K",
        TimelineScrollContainer: "II0EI3Ol8DvWt7FQfsNbx",
        ContentContainer: "_2eSQSp9u7_VDUDrCG4V-tL",
        AbsoluteLayer: "_2fti4qzLVbEydOmlw7A16i",
        HideOverflow: "_16Ta99sWFo7DNbWlpvpHRV",
        RelativeLayer: "_1RIfcMPhdua9IftpbJJAKq",
        WithPointerEvents: "_2Sk-Lj6jlDfehv6uuUa_Yn",
        RecordingDecorators: "NBc0PgdECgNGHybXMXgOp",
        ClipDecorators: "YBRVEhywfTRwb_vT9HdnU",
        GameModes: "_3vfGkbTjXUzSwr6b-v42JO",
        DateDecorator: "kakzXn3creKWdal1etpku",
        BackgroundTicks: "_3bRgOtndRhCrJpwTzd0Oim",
        Highlights: "LzHSWmJHomqtU-jTSLDEG",
        RangeHighlights: "_1NdyCSdtiQFvoBznqvarvN",
        Timestamps: "_36FQk5T4kMLr1axT-z3jAq",
        RangeSelector: "_3jnVEdXp155d_RQr3eZuyK",
        SeekScrubber: "_3x48wiJyAtvabHFlW4HWuo",
        PlayHead: "_3ckxIZyeOrSrQ775apezh2",
        Thumbnails: "_31eJnQyMpbmhp0mnHd02Ky",
        PositionLeft: "_1stnksokEwzIn10nHGDCEM",
        PositionRight: "_2f_ksFBRUllauZs4HA-bzg",
        Phases: "TaarLFX9W8lQiCjgz-nIn",
      };
    },
    59254: (e) => {
      e.exports = {
        LoadingTimeline: "JGGVRlj-AwNguh4wa7807",
        ScrollAndControlsCtn: "_2RzAySWe-9uzCJA9oGykll",
        GamepadMode: "_3lpEJRNBcA9EpAgLomD0jn",
        Controls: "HvZN6nroENhLkhniNutuR",
        TimelineScrollContainer: "_1cFVEeJk2np6JpMKYq0m9t",
        ContentContainer: "_3wqjsEPRzSGUpOgWYezV30",
        AbsoluteLayer: "_1vYBX3E1lB7wsdRdmsRSwV",
        HideOverflow: "C6chOG85M6_-hqwofg04b",
        RelativeLayer: "_1_XjIyiq_P7oZk4Aa3PZsk",
        WithPointerEvents: "_2GrriEvGl2vEPERHoIkg9X",
        RecordingDecorators: "T_GKyHV01N-0Mw4V9Q8N4",
        ClipDecorators: "_3jAa31iOtuHCYOt1cyYPHU",
        GameModes: "z3tClNy49hdbgj0NVx7R5",
        DateDecorator: "EiFtpT2NTMMovW9unJLGu",
        BackgroundTicks: "_2abPmFPmW_oPE349VO2TpA",
        Highlights: "_2_8rC82wthkPbfuHxBkHYk",
        RangeHighlights: "_2Lj8ZYpDL8HxfPJRXg0kgm",
        Timestamps: "_1e7MByQ-W7P_ftMx-4WcMV",
        RangeSelector: "_4kLbmnRkHeqUQus1ItdUY",
        SeekScrubber: "_23WuCkYUy41WcwdxqycJXb",
        PlayHead: "_1Zf0UX5Nyt7ZflIvx86a9K",
        Thumbnails: "Px56HgqgodVj1s1lELr9s",
        PositionLeft: "PftJQL7hFlMD6fyCmJ94X",
        PositionRight: "_3lMvwFfrxKrrjEOlUf7ov3",
        Phases: "_3CMHPm1gab4V9JTfZYAp1E",
        TimelineBacking: "_18sxaBKg910kJmmJS3zaaE",
        TimeTick: "faIAh3Zzg4MdulktB1IFo",
        TickLine: "iLLznzt7Npcsc-y_9tyCc",
        Major: "walQuMqIA1KE3_0tchqYj",
        Minor: "_2I5yeKjfnjaPmRNIpHUrl1",
      };
    },
    10564: (e) => {
      e.exports = {
        LoadingTimeline: "_1ZSym6hTh_XycEHZQv3waF",
        ScrollAndControlsCtn: "_1q95sqXb4oTj5LekKlUWqI",
        GamepadMode: "_1F4jNXOr-Gwt5oygH9F_mh",
        Controls: "z15TYuRsvRt6Li7EM3mM5",
        TimelineScrollContainer: "R0SGdHf8Z6rpbQGEf06ZP",
        ContentContainer: "_2XMJZ6Tb3zjNYuh91Il3rA",
        AbsoluteLayer: "_3AkqWv_vVG7IcuxTsw4FBK",
        HideOverflow: "qGvsK6jhx7uQrlMTQ6zSP",
        RelativeLayer: "_3zzAfZQcPSWB4Gj3tebKrI",
        WithPointerEvents: "_3z05uqMI8WeroTsIbWYYr0",
        RecordingDecorators: "TlW7mv6AQcJacn3I9Wcho",
        ClipDecorators: "_2HPd50upMLAGM4Ne2mOpIA",
        GameModes: "mKXM660QBtJ7Qy_5uNGdP",
        DateDecorator: "_1KAHyZKmBLACfUu9XXht0l",
        BackgroundTicks: "_1sDp4tXvu6KF6yaTe5Y65b",
        Highlights: "_3vFdT_Qdu7unGt0x2UBIOz",
        RangeHighlights: "P3bkvf7j3c-xSz6s7HtHY",
        Timestamps: "_3esOhQ7c-vdhQ6yUCny4aA",
        RangeSelector: "NMfai6QhLJB5lfGE-3T3o",
        SeekScrubber: "_3n81RbB8WDAKT_q_iUYF6P",
        PlayHead: "_1j_4JBYTjJZ3L044d9QjQL",
        Thumbnails: "_1a1mkc6mxngGs0scqTx8Rv",
        PositionLeft: "_3Tw8uk4rZfrmmyGfql1eTc",
        PositionRight: "_3OI9MLjE2183pXrrzjZlZ",
        Phases: "_1j2D4HXwIaWGBWeUeZiWve",
        ClipDecorator: "_3EWp_eWXsvKB-Lwz-Afl0S",
        gradient: "_3vAWnjV6c5oyReAPoGg-Ln",
      };
    },
    28361: (e) => {
      e.exports = {
        LoadingTimeline: "_3KG8zrhAf5BZd7OOkiM3Vn",
        ScrollAndControlsCtn: "_2Ox4l0Syi-OBMfeLLwGB0S",
        GamepadMode: "_1Nc3R34LFcFFu9xxGczIZx",
        Controls: "_1S92sYYyOl3-hAGUyKk3mT",
        TimelineScrollContainer: "_2yvt6-n0jndik9woSi9oiV",
        ContentContainer: "_28oA65JjmGpgktil_Spx8V",
        AbsoluteLayer: "_3RYVNG8TM3G95eG8DCgVCb",
        HideOverflow: "_1kDYn7vvEbKlU7Z4VfveI8",
        RelativeLayer: "_189IQalI-kinGc53wY8Btm",
        WithPointerEvents: "V18cwfJ6UCohOoz26FN68",
        RecordingDecorators: "_2u47IazTp8la3TplHQ4uMB",
        ClipDecorators: "_2LgpdbDk3onwK4JvCZ39GV",
        GameModes: "_32FUOpVgoy1QDT7K79IbqA",
        DateDecorator: "_3I1C0omMrwDJGYMspB33xc",
        BackgroundTicks: "-YJsXiYQ82zAY6sIPD-Z3",
        Highlights: "_1YMPrXbYXRhzivMd0RAOk-",
        RangeHighlights: "MxB0pCFqE_x6FHJiO8vGU",
        Timestamps: "_2GK8qqQxwH2_oWzF5rDbv6",
        RangeSelector: "pUP4yzI_BrVbBm7Bv9_ta",
        SeekScrubber: "_4LzfJqGOGDmemv2y4TUvS",
        PlayHead: "_7tgJLenOXLuiHf4FQsal-",
        Thumbnails: "TulKT7sbANoIafI9_KJza",
        PositionLeft: "_2g51I5QZegiV94lHBGsUhw",
        PositionRight: "_1AQnsvHDMaK1BJGY5kAcTl",
        Phases: "_3rPpP9lH-E-fnlD-DUERH3",
        TimelineRelativeDate: "xYXziACgvkSwOnjGsjrll",
        Overlay: "c1Fn5e_N42Q5Oz4gyqRvL",
      };
    },
    53298: (e) => {
      e.exports = {
        LoadingTimeline: "ALhsP_3HUfx4PHrpqy8R9",
        ScrollAndControlsCtn: "_5tbL0FKI0tuPTIa9Kh7Eo",
        GamepadMode: "_1dlSZNEhvmBeFco9nqqgCu",
        Controls: "u1VLCsRiWRO141U_KrOsN",
        TimelineScrollContainer: "_2IbHVvHaXnfviOahuULDQE",
        ContentContainer: "_2akKkTmA-GSqjV0ZuWZrxH",
        AbsoluteLayer: "_2e4HsYQIYWCzm4AUpHqlD2",
        HideOverflow: "_2Cp350sAx9clmoB_LKnqbp",
        RelativeLayer: "_124G22Z6qukxV-0yFjpk6h",
        WithPointerEvents: "ZoJ5cv5eX5Scw_K3FbQVA",
        RecordingDecorators: "_1b3xBvE7bRvkHIrvljgLJb",
        ClipDecorators: "_12hX8NvmhU3g8lrWcYZmia",
        GameModes: "_1w4ECxgpqgm_8JHSj5S_ys",
        DateDecorator: "_2_LxF0wGALV2Jtr6yimHGW",
        BackgroundTicks: "_1wC4nFbVKj98NDRuVnW2DK",
        Highlights: "_3Mwk0XzURhRyn-iKASG7Yj",
        RangeHighlights: "AwYHl8RlppVEH0g3dKMjP",
        Timestamps: "_2_I_TyIeQdR-V7l562aVwJ",
        RangeSelector: "_2509eCzShezVSGfZFWi9BW",
        SeekScrubber: "_3Re46KW-L5PLoUYxCq_k6W",
        PlayHead: "_3BW9NlhX6WYWHXM6WNBI54",
        Thumbnails: "_3WC2e0zUqP5LoUxckgI6Fv",
        PositionLeft: "m29ndF7OUcWuJyQ7gz0r9",
        PositionRight: "_3scLcN4HvBYNivCKDSVIGj",
        Phases: "_25KI7BuIZxgifkWKhYIy4m",
        GameModeMarker: "_XZRbjOovnp3-oJB1FHsX",
        Playing: "_1QXuDX8p22dW30Dq7Q4cY1",
        Staging: "_5elfnsld99d9XPrRSVVMb",
        Menus: "_2ouy5ehbuCra9zvvJVRt7N",
        Unspecified: "_3tV_P5UlKOy23ovyof9BCG",
        GameModeMarkerClip: "_2X0XBzWywYh06tLOpEVVhV",
      };
    },
    41972: (e) => {
      e.exports = {
        HighlightContextMenuItem: "_28S8ry9bxlwML-iCsdsuB",
        MenuItem: "JZCa05wXidmR0BEW4wKuT",
        EditMarker: "sMTceKd747vq8bsuL3OW9",
        CreateClip: "_1xK5Up775-kzkarHJyaUSH",
        DeleteMarker: "_1HITbDUgqbAsnVISlw-IU4",
        ViewScreenshot: "_2HfiRMT1mpZZy-Op04_Vp5",
        ViewClip: "_20E0pQUHwdjs6eM1Ow2GiS",
        active: "NjA0Fz51GxvZgm847KioJ",
      };
    },
    23533: (e) => {
      e.exports = {
        LoadingTimeline: "_2i7CkGHUrVZKOMEsrhI1p_",
        ScrollAndControlsCtn: "_3fITrWggW83OcggiMJdPz3",
        GamepadMode: "_2hCXeP62uQrMldE08f-mjT",
        Controls: "_1EiX3eLLYicyYcDHtIM6_s",
        TimelineScrollContainer: "_2RYEV5Q8tyI-Z488xqMdJh",
        ContentContainer: "_2lWpy5QzYnH2pWhRjUASJL",
        AbsoluteLayer: "_3wd1JlZa9wOIFFMqdVmsh8",
        HideOverflow: "_2PTM3ppOv1W0jPmlXV9zeK",
        RelativeLayer: "_237IHLV36I9F3GAeSC3Ast",
        WithPointerEvents: "sMhiTRaHJInFdVQZ6J0-m",
        RecordingDecorators: "_3S9aExsAjU_DTaDbMIj5i9",
        ClipDecorators: "_3sy9QqiqMextSXnKc1AMAN",
        GameModes: "_2zfITr74kyUJlBfMyJLgnn",
        DateDecorator: "_2ad7ZMfcbWLopAqjoc1dQy",
        BackgroundTicks: "_2rdq8jGEzjIT8wAFNFhiYQ",
        Highlights: "_2MKxDzVJV5-FqyH991s2MT",
        RangeHighlights: "_2pwNSvaiG6OMTbuF-NyeqL",
        Timestamps: "_1BmX-E7ljnjRC-DwV0vehq",
        RangeSelector: "_3Kw_btjCsTccf081ReOvQp",
        SeekScrubber: "lP4qnNu-VBcvUzlXNQtyt",
        PlayHead: "_3pAXAVoqYOE6IKmH5vVcvy",
        Thumbnails: "_26VL6vWz_H-HdOIX-WB1NV",
        PositionLeft: "_1UQilx5P8cBrDKId9y9Zml",
        PositionRight: "vmWKsPz2yK9DdAMmGopBd",
        Phases: "_3hNl6_lWZBob973Eyo8tN7",
        MarkerAndDropline: "KxkV7ibv4HxiLzsJDo09y",
        Faded: "_2YIhgvCldNrTquf5YdDweU",
        NoPointer: "_2ebcCpkh2QhQIrtDjawNTL",
        TimelineMarkerCtn: "_1Dg_c4LTkbyiG_03VDAsQE",
        TimelineMarker: "_2CNnKSqRD_9z5U0Knq2yjM",
        DroplineCtn: "_2KKJRZF-_QAqfpR0e-20x6",
        TimelineMarkerDropLine: "_3JsMmXCkE-NhKNzxarPwuc",
      };
    },
    62745: (e) => {
      e.exports = {
        Positioner: "r5C4vqop5qm8LQK3X0ko3",
        MouseWithin: "ew9abErxuaHlGCMzkyeWJ",
        Highlight: "xk10sVHcF-iepUcNGM7xL",
        PhaseHighlight: "_2sP2GHDIcIT3HmoJT5xGlA",
        Body: "_1hlTgJwbrd9u_brCsEsT0N",
        Edge: "_3_tErLe8CNqRhYf0vAfb-t",
      };
    },
    5540: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "_2X7jhW-qi_3UccesLWrrSi",
        ScrollAndControlsCtn: "_3NY57YPlBtVmbManJByw3B",
        GamepadMode: "_3LWcSQg02x6_mKFAC2HnOA",
        Controls: "_3iXWpF78DL2KpP8zwC0a0D",
        TimelineScrollContainer: "_3A2oPv5e_smY5BRZYb44oC",
        ContentContainer: "_37F8Twe4-MEGnPuMdrRjdV",
        AbsoluteLayer: "_2TPYTXJ5LTahFqYyrgyybY",
        HideOverflow: "_1GDbd0Ag6dx77g7HNg9fjA",
        RelativeLayer: "_1Gp1jY_vrVhkryDDlAy5XA",
        WithPointerEvents: "_2Wca3Yup3sepGJyb3yB9Wx",
        RecordingDecorators: "_2yAWbzlcRBmXGKBJxO5Q6K",
        ClipDecorators: "_1vxxhyF1HrGzKc8R-wGDGw",
        GameModes: "_2W6eCuNryz1pMcGhYEyFag",
        DateDecorator: "_2XW6UMjMH0uXl0q6gIOKs7",
        BackgroundTicks: "_3Tt6WBdl000PCM7C2kwD2c",
        Highlights: "_1epMF6kwn7KeUBakQKPhCm",
        RangeHighlights: "aRAHUpKDR27OMcL2xHCSC",
        Timestamps: "_2of-NiJ1-JIp_fPSufxZJ3",
        RangeSelector: "bBVOLxbX1EUhwt_Oez4GK",
        SeekScrubber: "_1c_f2oDp_5tIKiGQcvboIB",
        PlayHead: "NAXFU_K2NP9xmH2cnITpG",
        Thumbnails: "FNvG_yK3LCIcUTGSfMhVP",
        PositionLeft: "GECyynaguvZTc6_17XpFd",
        PositionRight: "_3Rwz0Dale6Fxyu3k2khbuf",
        Phases: "_xSGH0PVjr0l8tuXz9-3f",
        PlayheadInteractionCtn: "_3_VTfkSR95EXQBQCvfM-ua",
        ActiveCtn: "_2bsFx5e6IWGwk1Smh_yRl",
        PlayHeadContainer: "_2RtcuI1Wk2JRTn39xig3OS",
        TooltipSource: "DgGCjpjgZ28PDlwxsTwCr",
        Active: "_3N6L28ckYs_8Z7u62KJCJV",
        PlayHeadContent: "_1zm_aVI1mDMkbM_o1um30R",
        PlayHeadCurrentTimeContainer: "_38jg4bQlW8Tyygoswt3epd",
        NoPointer: "_2qwplD-OoJ3_iLfl14eORi",
      };
    },
    14296: (e) => {
      e.exports = { RangeHighlight: "_2a4wDhcnXixHXxFFvpLGbe" };
    },
    2508: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "_15xYd1duz4CX9ojFz0CE0r",
        ScrollAndControlsCtn: "_39WVqvqzprHCxsDbq6RIVi",
        GamepadMode: "_1iVq_Vso_g-hPu4I6clDcI",
        Controls: "q39fhjQv3o2GqRMkZeGeA",
        TimelineScrollContainer: "_2Ns82DABvcHzpa7h2Z1yN0",
        ContentContainer: "_2flM04qSQgffE6G2_pghpT",
        AbsoluteLayer: "hPYovdeG0fnX79y5Lq6i8",
        HideOverflow: "zl42_yRu36YJmTpwkrll3",
        RelativeLayer: "wxj4IaR3D-7lPHenwnyaS",
        WithPointerEvents: "_2AobDyHPf2lTm9ZzZIsGop",
        RecordingDecorators: "_1hCGwoXgxZG5aIyUcumoan",
        ClipDecorators: "_1d_mX4rNoLcSBlpCOOZ9d-",
        GameModes: "_26Bbv689gSTq0MjmYL-Y6Y",
        DateDecorator: "_2BqCIYg1x7daCu3oF0vicq",
        BackgroundTicks: "_2YoyAw0aHd57nTMyCX8Ek8",
        Highlights: "_2hsueyKwIwA6dgxRFhAuEw",
        RangeHighlights: "_3eoxS78PdZxxZaBBmdJDZB",
        Timestamps: "_3O3iRzw4rwhbFvTKLV7s2J",
        RangeSelector: "_2gSg55gNLQhpokogPcJ-As",
        SeekScrubber: "sTaCR323nQeC8QrAQW3Cr",
        PlayHead: "_3Ra6BfYOEPCrvdKvrXpd2i",
        Thumbnails: "_7KwbBvSEcjyRsmZ0g6j6z",
        PositionLeft: "_27IW3T5nky75Oz6a17zWSg",
        PositionRight: "xf_NxJ83twPRPic2nUu3s",
        Phases: "IIuLWvFELtrtCRCvRlpo",
        RangeControls: "_3TsJzrPgtC5rqLcR6ihpFi",
        RangeSelectorCtn: "_2ULjGYMNYTiUllQtzFXS11",
        Active: "_2bFlccGjBmvO9sTXH-UhId",
        InactiveSelectedRangeControl: "_2uX26Fo_kmE4ZR6JmKQpp4",
        SelectedRangeMask: "_2C2hWRks6sMz8e9rdXj_BH",
        RangeIcon: "DTarGRkLfmPhdBVfdlNIf",
        Hide: "_2OktuE6gQcRmHdDbzj7AzW",
        TrackRangeControls: "_1xinhHBSWQ2oYszkzt2zrt",
        RangeControl: "_106ZAEQ05s5XGwxAQ4k_W6",
        RangeMask: "_1SW3yTh55ykBnsHiBzIQFC",
        FullMask: "HBfBmaVuNVcfkTcAqMJdE",
      };
    },
    78760: (e) => {
      e.exports = {
        LoadingTimeline: "_3tH-UmmBxFZv85a4VmjR83",
        ScrollAndControlsCtn: "_3EGBZkS2chHJ5KaKxGam9e",
        GamepadMode: "_3Wahmr7e1VA6i9w9Iq0-Vg",
        Controls: "_3nrFGW_JIvdhMPBQvVaqby",
        TimelineScrollContainer: "_3vqWS2_hdUvKZO0Vipm-Pa",
        ContentContainer: "_2_mqytSivE2wDjb0DQRqEp",
        AbsoluteLayer: "CiFLrniSN_egwVrtxdvwm",
        HideOverflow: "_2BoIL1h7HxeuUr9oEBJu5e",
        RelativeLayer: "_3obgM4lCFV2Ggqbiz0HJZX",
        WithPointerEvents: "_1e6-Zdv13LsrP3qEPoBDr9",
        RecordingDecorators: "_3l9q4-8eUf8mm3ml4NZ-9m",
        ClipDecorators: "_1HU0h3xOeCJtdhA_ieKKsf",
        GameModes: "_2FL-NrMawaFVKSgQr2NRu7",
        DateDecorator: "_2bCxb7i3bzq1DCZWl04h-n",
        BackgroundTicks: "_2UfqYYX9g4-SFlozy19diE",
        Highlights: "_2iZX0eAmOssSWzNwVW2Sk2",
        RangeHighlights: "_1aNkPwMsxHkCpTJ3zueNmV",
        Timestamps: "_2TfF2B8IJjQO4cxcYnzNv-",
        RangeSelector: "wMeTvFQex5TV0NsHdu1En",
        SeekScrubber: "_1x23j31qyK2ov8527ywrtY",
        PlayHead: "_3hU0qsPL5AdwVbmHfPQjz8",
        Thumbnails: "_3U1E2lH8PHXEKmmCidFYET",
        PositionLeft: "_3a7NFvp83NwS--Uea7c18J",
        PositionRight: "_2aWYEMKtLLTVAg5lTA30Du",
        Phases: "_2HWX2m_BjCepXubvHC-OBI",
        RecordingDecorator: "_24zNSxRiQlHxbGT_RvZsoY",
        Clip: "_3Q-H1_vR-NtTfQf_Ohljdx",
        ClipMode: "_7MCqjcHde47TGpwTMEK5",
        Manual: "_1kfoF8deRCDIcTe5l3oplt",
        RecordingDecoratorClip: "_3d4VU3BdaG9Z5sL2fNq_xy",
        LiveRecordingBuffer: "_3PHrI-zb5iHRj5OfLEwEc0",
        IsLive: "_1kxbPOC7CK5DmZi9fZLfUl",
      };
    },
    36616: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "_3Tmq42XNJAOKkmYYNLwhYt",
        ScrollAndControlsCtn: "_2zSlRD5EZdNkxEXqxX19xj",
        GamepadMode: "_1iEsh140l3SOV-CHmx1gPK",
        Controls: "_3Sigu8Ua4QhAoaSILhJjnk",
        TimelineScrollContainer: "_36TGeLVHkkcngviDfI1e3w",
        ContentContainer: "_2mJpXt1qXS1THVBTX6wQIh",
        AbsoluteLayer: "_1hyNg-11fi93ggy44EPp0D",
        HideOverflow: "_1IkW2bCIFdXrtYpOKZJT78",
        RelativeLayer: "_1RLJoHOySeNow6t6Gb4q2I",
        WithPointerEvents: "_1o2r-Bw4voSyttJ2TnlIMF",
        RecordingDecorators: "_2qcUYqRha1_HKm_YVHzDFf",
        ClipDecorators: "_3qqUOckgF-Vne9B37h2VNV",
        GameModes: "_2K3UBqeIoBHg4LbvxflBnI",
        DateDecorator: "_2BEmrgSvLIuVLtOq4uyk-b",
        BackgroundTicks: "WbVOga7uck_kj9-xd1ZBj",
        Highlights: "_2nvnMUT2DtnJcH1Rlz3i04",
        RangeHighlights: "_2PKtguqz5iQChuLNLyEq-9",
        Timestamps: "R3B96ZoLAEXfwE5F5VAlS",
        RangeSelector: "_3DWyeaU2HR8tgw6IYQIrF2",
        SeekScrubber: "_2wVY5UH9H5eVSyRfPhgV10",
        PlayHead: "_3knz_EuOFUYwJ-8OisxbLi",
        Thumbnails: "JjnuXWzLmCm63Y-6KipH6",
        PositionLeft: "feeCzNA4u_b9e5tzS9oa6",
        PositionRight: "_1uGyz62lktHAb9_wh3QEUn",
        Phases: "_2wzBXR-nPbsfwcRPnqJ4yk",
        PlayheadInteractionCtn: "cxkAkBK32ah0etQ7VXfDI",
        ActiveCtn: "_3HMQwpcr66jg7N3RW9U4r1",
        PlayHeadContainer: "_3Fg3Bef5dt1s1SK8yzivuJ",
        TooltipSource: "_1zTEVuta8tTd1Iw-c1Ea-N",
        Active: "G8XiKETNpSUHoyKM8T3QA",
        PlayHeadContent: "t2rs722c_hdaOG6MWrVhD",
        PlayHeadCurrentTimeContainer: "_1BM_Z8Iu_1o-aPNlOB8DYa",
        NoPointer: "XCAfYcKute_vaG8jbwVAr",
        RangeControls: "_2ylJ735myBUxj8mYp92MQz",
        RangeSelectorCtn: "_35GmRrlfGhrO_6QVFR0Wi7",
        InactiveSelectedRangeControl: "_bKQMA7pDeFEDDAbdgdNg",
        SelectedRangeMask: "_3PO0lBzzlKrUN85s6-CJmt",
        RangeIcon: "_3H1CUoiDPdbAQs16z1Zc5X",
        Hide: "_1YPpCzSDkjW9CznvJ-t8ze",
        TrackRangeControls: "_23YDdZ4YDQPRZOCaKwscyh",
        RangeControl: "_3Z9hkuB9-Hmn5_8M48FE01",
        RangeMask: "Cr2MdFPZcaH4sJctAG6Gl",
        FullMask: "_3qoMxbpjei5WjkAOyagCpU",
        GhostPlayheadCtn: "_2QEZwA3q0IO62G_BU-Drbn",
        TooltipHoverSource: "_3GHTkEg295xMBJ6usRbh45",
        GhostPlayhead: "_1NsKSV4XAmywc3NCkOdJEq",
        Show: "_2rHDnc8CHv56EKtuTCKszw",
      };
    },
    48419: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "_3Q5mItz1omGnn-T1D3hSx6",
        ScrollAndControlsCtn: "_1fH0OLSeGlehC7ZroCzqe9",
        GamepadMode: "_2t0z1NBG3JkzrwgVIk_P3W",
        Controls: "_2LpY_Ns-dcnT5PHQQLiXPp",
        TimelineScrollContainer: "_1q2QlUl7dhMQoUemqokVst",
        ContentContainer: "cUBJWpslwHW62w7LbnL7c",
        AbsoluteLayer: "_1pSOlypnO47E0bAGUg8vzb",
        HideOverflow: "_2hT8Akt7q9EZvx2C0IFuRR",
        RelativeLayer: "_3zkquJ_VVnjp1lWbN1tTxS",
        WithPointerEvents: "_2KJPu1BcFSB6UeyCGC1Q9l",
        RecordingDecorators: "_2lJHaMtseWGNtKzez_c-tR",
        ClipDecorators: "Xqf7VLN_JqMJeMe-gjyHj",
        GameModes: "Z9nyGreF6wFTFgKjwuTur",
        DateDecorator: "_1H35HfLIngfg1Spx8-se-m",
        BackgroundTicks: "_2Qp-oYu2NVGRgnr-MnIi2c",
        Highlights: "_1pFb1qr2LgVW_Epi61zjiM",
        RangeHighlights: "F3-cbznHCNkLM3OoAmQEK",
        Timestamps: "_3fHbNOeEXYFGE31WD5XnOr",
        RangeSelector: "_3ovQqX7ALXvRC1ekegy7Lf",
        SeekScrubber: "_3YSduxpL8KnXHYHJkjuwvv",
        PlayHead: "_3uZ7PVoL2PO3WBpvCAnoK9",
        Thumbnails: "_2ZT_p0F8NlyiN2w9uK0V-8",
        PositionLeft: "_2dupDWRctKjVqN0z4s0oyR",
        PositionRight: "_1PDRoz5nG__plPLMJYlHLW",
        Phases: "_26bhPWtFCbtjxSwlbSIltM",
        TooltipOffset: "_2dYuDsUYCHiGRqSksoc2iU",
        ThumbnailContainerOffset: "iJ-nnbMoplnO7sW4GoKZE",
        ThumbnailContents: "_1p6K1C-xCaggsPiZeYS6xb",
        Hide: "_1IGjtF0VQplGgo8JQKuoMP",
        ImageAndInfoBoxContainer: "ke2xSKYvfY9kTFlZgvXyx",
        ImageContainer: "_16W4iNZCkRy5g-01USxzcp",
        ThumbnailImage: "_15YmEFGejPCWqJsgZIwIHh",
        NoRecordedContent: "_2oSbwmF9lRWp2wTpQ2BTcr",
        InfoBoxContainer: "_39hE1ouldA7027OOjS1Mgy",
        Header: "_1RvdZuUvhMBHThLFwYwITy",
        Icon: "_3ALDTTrBPXnpHpt1yU52k3",
        DescriptionBlock: "_2WNbTb6IIvTgYqRePMVYqW",
        Title: "_2xgQkBo5Tkz0utecycIdA4",
        Description: "_3wvMa5Sd15895W_3Q3Fyfx",
        ThumbnailHitBoxPadding: "_25m6SU3qwK58gHr_sKPaUm",
        Overlay: "_1F33WqZYbfSW5lvdSEZL4I",
        TooltipContents: "_1Q9Po562tX-Vtgo2NWXIw",
        TooltipChildren: "_2T0U4DTFWI5h9xaeZagxLF",
        TooltipImage: "_1xD6jfVHbDjGwO77Svhkcv",
        TooltipImageCtn: "_1v_O5vtQFICye0ocFetnId",
        ThumbnailTooltip: "_2Z4RGgTd1bRpgdwEhO8jCU",
        Highlight: "_3a20-bJDPDlu4mazQECyx5",
        TimeDisplayContainer: "_3d8jwG8NBfQYTwkZ0OxQJp",
        Playhead: "_2n75OrROEywBwiWw2aHhTK",
        RangeLeft: "_1gO9xZ0-LFtgn8qA4tyXYr",
        RangeRight: "JDbwFLFfYMT4xQA-bQ9Ko",
        Timestamp: "_2lPBQbxG1oIaw3OCRbqSwX",
        TooltipInteractionRegion: "nbJB1LiguVOaBnJGRVnl7",
        StateDescription: "u04UCICvObTJ4FUr9RQen",
        TooltipButtons: "_2__OPNuJ5jPGfN7LuKW-Qw",
        Button: "_15dYncysqGpt47Cy4LxDu6",
        AddMarker: "_1U3RGrxKiDB_p4u4cKiixk",
        GoToClip: "_38jzRyjtRvySB27qxc3OlN",
        CreateClipButton: "_3KYRSKclWw-y1WSWZZ0NdW",
        EditMarker: "_2ho8quLzRrIUiJRPbr8lzp",
        DeleteMarker: "_113MCALzgYpL4lDc_eE542",
        GoToClipFromMarker: "_1HHxKvMUEWqDdSy1BGBnyK",
        ViewScreenshot: "Id7gML3NYais_DAVYP7LW",
        TooltipHitBox: "_2QbChk9tpXisnWlJFH0Igj",
        TooltipContainer: "_1sw-kUqdIDK2G5BlOu_Dm9",
        ImageHighlightPosition: "_2ywONE_xgamAkfBmUE67IL",
        ImageHighlightBlock: "_1BeXpXQyetKgeO2_6NuHiJ",
        TooltipRangeContainer: "Ytt19E3fOLhHsFDpTCviL",
        Duration: "_1kvsGVxJZ9tkKXwysVa5PP",
        RangeIcon: "qV2yorV1nAB0bIQrbROqm",
      };
    },
    54637: (e) => {
      e.exports = {
        TimelineContextMenuItem: "_1_VGcqhwscnT-kPnPb2c22",
        MenuItem: "_1wPm9-zsQlqLzb92eR77lC",
        AddUserMarker: "_3VSFddY_9-Sh1I3ByUwmD4",
        TakeScreenshot: "_13th0aVaGQhNp6eltjFYyh",
        StartEndClip: "_1eb1crSvl4J1Ie12OvhHUz",
        ViewClip: "_3YpMycJiNuGZOe9A5ddrxL",
        ClipPhase: "_3BLSZg3UyXhaQ4rkXaTvhs",
        active: "_1D7oiWH7xjJ2nI27nnFzwI",
      };
    },
    2596: (e) => {
      e.exports = {
        "duration-app-launch": "800ms",
        TourPositioner: "_3SETpnYbAtvmO7w4gpOCtK",
        TourBox: "_1lcizT_Nbxsk484XzTtcFf",
        CloseButton: "_1A5Qloms_qv3D5xh052LKf",
        X: "kcjJIs0EE3MG_h_t5nCza",
        Title: "_51Xf1tIa1NCIih20Qi1Nm",
        Content: "_1iiz2Ocj1OAe9wZjdPrZSv",
        Action: "_39eWK3BcJKYP9H1X1cTdyV",
        TipCount: "_1T5ZuXrxnGb4BDtEbYTuGz",
        TourStopArrow: "_2JvQPEForHWVgljtxxAwRP",
        BackgroundAnimation: "_15yvWK6GCakW5yZ0YB66fv",
        "ItemFocusAnim-darkerGrey-nocolor": "Eu2HOvMbunn7MzCLIJ5ES",
        "ItemFocusAnim-darkerGrey": "DvP1wiF6eV9afdQaEkods",
        "ItemFocusAnim-darkGrey": "_2tQsBdyAzzF2_nY65OSwNm",
        "ItemFocusAnim-grey": "Qg-4WEghuaXqBRIE-lEVs",
        "ItemFocusAnim-translucent-white-10": "_18ENJxMfn40_y_8CMeuuMm",
        "ItemFocusAnim-translucent-white-20": "_1wbIEe3KnohwpAw2O4M9YP",
        "ItemFocusAnimBorder-darkGrey": "_3hC5OOIGfv0lY8ykI4qpNa",
        "ItemFocusAnim-green": "_3ZDnxVKI3Xfr_a6bvaivKR",
      };
    },
    22131: (e, t, r) => {
      "use strict";
      r.r(t), r.d(t, { default: () => Da });
      var i,
        n,
        a = r(90626),
        s = r(86679),
        l = r(45737),
        o = r.n(l),
        m = r(16676),
        c = r(95695),
        d = r.n(c),
        u = r(738),
        g = r(56011),
        p = r(61859),
        _ = r(37085),
        f = r(80613),
        h = r.n(f),
        S = r(89068),
        b = r(56545);
      !(function (e) {
        (e[(e.k_ETimelineImageType_SVG_XML = 1)] =
          "k_ETimelineImageType_SVG_XML"),
          (e[(e.k_ETimelineImageType_PNG = 2)] = "k_ETimelineImageType_PNG"),
          (e[(e.k_ETimelineImageType_JPG = 3)] = "k_ETimelineImageType_JPG");
      })(i || (i = {}));
      class M extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            M.prototype.appid || S.Sg(M.M()),
            f.Message.initialize(this, e, 0, -1, [5], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            M.sm_m ||
              (M.sm_m = {
                proto: M,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: S.qM.readFixed64String,
                    bw: S.gp.writeFixed64String,
                  },
                  name: { n: 3, br: S.qM.readString, bw: S.gp.writeString },
                  desc: { n: 4, br: S.qM.readString, bw: S.gp.writeString },
                  branches: {
                    n: 5,
                    r: !0,
                    q: !0,
                    br: S.qM.readString,
                    bw: S.gp.writeRepeatedString,
                  },
                  last_update_rtime: {
                    n: 6,
                    br: S.qM.readUint32,
                    bw: S.gp.writeUint32,
                  },
                  priority: { n: 7, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  last_publish_rtime: {
                    n: 8,
                    br: S.qM.readUint32,
                    bw: S.gp.writeUint32,
                  },
                },
              }),
            M.sm_m
          );
        }
        static MBF() {
          return M.sm_mbf || (M.sm_mbf = S.w0(M.M())), M.sm_mbf;
        }
        toObject(e = !1) {
          return M.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(M.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(M.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new M();
          return M.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(M.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return M.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(M.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return M.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSet";
        }
      }
      class y extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            y.prototype.appid || S.Sg(y.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            y.sm_m ||
              (y.sm_m = {
                proto: y,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  assetset: { n: 2, c: M },
                },
              }),
            y.sm_m
          );
        }
        static MBF() {
          return y.sm_mbf || (y.sm_mbf = S.w0(y.M())), y.sm_mbf;
        }
        toObject(e = !1) {
          return y.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(y.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(y.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new y();
          return y.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(y.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return y.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(y.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return y.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_CreateAssetSet_Request";
        }
      }
      class T extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            T.prototype.assetset || S.Sg(T.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            T.sm_m ||
              (T.sm_m = { proto: T, fields: { assetset: { n: 1, c: M } } }),
            T.sm_m
          );
        }
        static MBF() {
          return T.sm_mbf || (T.sm_mbf = S.w0(T.M())), T.sm_mbf;
        }
        toObject(e = !1) {
          return T.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(T.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(T.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new T();
          return T.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(T.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return T.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(T.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return T.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_CreateAssetSet_Response";
        }
      }
      class B extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            B.prototype.appid || S.Sg(B.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            B.sm_m ||
              (B.sm_m = {
                proto: B,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: S.qM.readFixed64String,
                    bw: S.gp.writeFixed64String,
                  },
                },
              }),
            B.sm_m
          );
        }
        static MBF() {
          return B.sm_mbf || (B.sm_mbf = S.w0(B.M())), B.sm_mbf;
        }
        toObject(e = !1) {
          return B.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(B.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(B.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new B();
          return B.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(B.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return B.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(B.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return B.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_DeleteAssetSet_Request";
        }
      }
      class v extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return v.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new v();
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new v();
          return v.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return v.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return v.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_DeleteAssetSet_Response";
        }
      }
      class R extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            R.prototype.appid || S.Sg(R.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            R.sm_m ||
              (R.sm_m = {
                proto: R,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  assetset: { n: 2, c: M },
                },
              }),
            R.sm_m
          );
        }
        static MBF() {
          return R.sm_mbf || (R.sm_mbf = S.w0(R.M())), R.sm_mbf;
        }
        toObject(e = !1) {
          return R.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(R.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(R.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new R();
          return R.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(R.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return R.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(R.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return R.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdateAssetSet_Request";
        }
      }
      class G extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return G.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new G();
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new G();
          return G.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return G.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return G.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdateAssetSet_Response";
        }
      }
      class w extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            w.prototype.appid || S.Sg(w.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            w.sm_m ||
              (w.sm_m = {
                proto: w,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                },
              }),
            w.sm_m
          );
        }
        static MBF() {
          return w.sm_mbf || (w.sm_mbf = S.w0(w.M())), w.sm_mbf;
        }
        toObject(e = !1) {
          return w.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(w.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(w.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new w();
          return w.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(w.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return w.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(w.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return w.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_GetAllAssetSets_Request";
        }
      }
      class C extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            C.prototype.assetset || S.Sg(C.M()),
            f.Message.initialize(this, e, 0, -1, [2], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            C.sm_m ||
              (C.sm_m = {
                proto: C,
                fields: { assetset: { n: 2, c: M, r: !0, q: !0 } },
              }),
            C.sm_m
          );
        }
        static MBF() {
          return C.sm_mbf || (C.sm_mbf = S.w0(C.M())), C.sm_mbf;
        }
        toObject(e = !1) {
          return C.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(C.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(C.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new C();
          return C.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(C.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return C.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(C.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return C.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_GetAllAssetSets_Response";
        }
      }
      class E extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            E.prototype.appid || S.Sg(E.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            E.sm_m ||
              (E.sm_m = {
                proto: E,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: S.qM.readFixed64String,
                    bw: S.gp.writeFixed64String,
                  },
                  branch: { n: 3, br: S.qM.readString, bw: S.gp.writeString },
                },
              }),
            E.sm_m
          );
        }
        static MBF() {
          return E.sm_mbf || (E.sm_mbf = S.w0(E.M())), E.sm_mbf;
        }
        toObject(e = !1) {
          return E.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(E.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(E.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new E();
          return E.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(E.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return E.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(E.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return E.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_AddBranchToAssetSet_Request";
        }
      }
      class I extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            I.prototype.updated || S.Sg(I.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            I.sm_m ||
              (I.sm_m = { proto: I, fields: { updated: { n: 1, c: M } } }),
            I.sm_m
          );
        }
        static MBF() {
          return I.sm_mbf || (I.sm_mbf = S.w0(I.M())), I.sm_mbf;
        }
        toObject(e = !1) {
          return I.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(I.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(I.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new I();
          return I.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(I.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return I.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(I.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return I.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_AddBranchToAssetSet_Response";
        }
      }
      class k extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            k.prototype.appid || S.Sg(k.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            k.sm_m ||
              (k.sm_m = {
                proto: k,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: S.qM.readFixed64String,
                    bw: S.gp.writeFixed64String,
                  },
                  branch: { n: 3, br: S.qM.readString, bw: S.gp.writeString },
                },
              }),
            k.sm_m
          );
        }
        static MBF() {
          return k.sm_mbf || (k.sm_mbf = S.w0(k.M())), k.sm_mbf;
        }
        toObject(e = !1) {
          return k.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(k.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(k.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new k();
          return k.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(k.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return k.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(k.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return k.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_RemoveBranchFromAssetSet_Request";
        }
      }
      class P extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            P.prototype.updated || S.Sg(P.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            P.sm_m ||
              (P.sm_m = { proto: P, fields: { updated: { n: 1, c: M } } }),
            P.sm_m
          );
        }
        static MBF() {
          return P.sm_mbf || (P.sm_mbf = S.w0(P.M())), P.sm_mbf;
        }
        toObject(e = !1) {
          return P.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(P.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(P.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new P();
          return P.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(P.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return P.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(P.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return P.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_RemoseBranchFromAssetSet_Response";
        }
      }
      class O extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            O.prototype.appid || S.Sg(O.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            O.sm_m ||
              (O.sm_m = {
                proto: O,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  first_assetset_id: {
                    n: 2,
                    br: S.qM.readFixed64String,
                    bw: S.gp.writeFixed64String,
                  },
                  second_assetset_id: {
                    n: 3,
                    br: S.qM.readFixed64String,
                    bw: S.gp.writeFixed64String,
                  },
                },
              }),
            O.sm_m
          );
        }
        static MBF() {
          return O.sm_mbf || (O.sm_mbf = S.w0(O.M())), O.sm_mbf;
        }
        toObject(e = !1) {
          return O.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(O.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(O.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new O();
          return O.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(O.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return O.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(O.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return O.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_SwapAssetSetPriority_Request";
        }
      }
      class z extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            z.prototype.updated_first || S.Sg(z.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            z.sm_m ||
              (z.sm_m = {
                proto: z,
                fields: {
                  updated_first: { n: 1, c: M },
                  updated_second: { n: 2, c: M },
                },
              }),
            z.sm_m
          );
        }
        static MBF() {
          return z.sm_mbf || (z.sm_mbf = S.w0(z.M())), z.sm_mbf;
        }
        toObject(e = !1) {
          return z.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(z.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(z.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new z();
          return z.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(z.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return z.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(z.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return z.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_SwapAssetSetPriority_Response";
        }
      }
      class D extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            D.prototype.appid || S.Sg(D.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            D.sm_m ||
              (D.sm_m = {
                proto: D,
                fields: {
                  appid: { n: 1, br: S.qM.readUint32, bw: S.gp.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: S.qM.readFixed64String,
                    bw: S.gp.writeFixed64String,
                  },
                },
              }),
            D.sm_m
          );
        }
        static MBF() {
          return D.sm_mbf || (D.sm_mbf = S.w0(D.M())), D.sm_mbf;
        }
        toObject(e = !1) {
          return D.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(D.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(D.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new D();
          return D.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(D.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return D.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(D.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return D.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdatePublishTime_Request";
        }
      }
      class A extends f.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            A.prototype.updated || S.Sg(A.M()),
            f.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            A.sm_m ||
              (A.sm_m = { proto: A, fields: { updated: { n: 1, c: M } } }),
            A.sm_m
          );
        }
        static MBF() {
          return A.sm_mbf || (A.sm_mbf = S.w0(A.M())), A.sm_mbf;
        }
        toObject(e = !1) {
          return A.toObject(e, this);
        }
        static toObject(e, t) {
          return S.BT(A.M(), e, t);
        }
        static fromObject(e) {
          return S.Uq(A.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (h().BinaryReader)(e),
            r = new A();
          return A.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return S.zj(A.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (h().BinaryWriter)();
          return A.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          S.i0(A.M(), e, t);
        }
        serializeBase64String() {
          var e = new (h().BinaryWriter)();
          return A.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdatePublishTime_Response";
        }
      }
      !(function (e) {
        (e.CreateAssetSet = function (e, t) {
          return e.SendMsg(
            "AssetSetPublishing.CreateAssetSet#1",
            (0, b.I8)(y, t),
            T,
            { ePrivilege: 7 },
          );
        }),
          (e.DeleteAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.DeleteAssetSet#1",
              (0, b.I8)(B, t),
              v,
              { ePrivilege: 7 },
            );
          }),
          (e.UpdateAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.UpdateAssetSet#1",
              (0, b.I8)(R, t),
              G,
              { ePrivilege: 7 },
            );
          }),
          (e.GetAllAssetSets = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.GetAllAssetSets#1",
              (0, b.I8)(w, t),
              C,
              { bConstMethod: !0, ePrivilege: 7 },
            );
          }),
          (e.AddBranchToAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.AddBranchToAssetSet#1",
              (0, b.I8)(E, t),
              I,
              { ePrivilege: 7 },
            );
          }),
          (e.RemoveBranchFromAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.RemoveBranchFromAssetSet#1",
              (0, b.I8)(k, t),
              P,
              { ePrivilege: 7 },
            );
          }),
          (e.SwapAssetSetPriority = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.SwapAssetSetPriority#1",
              (0, b.I8)(O, t),
              z,
              { ePrivilege: 7 },
            );
          }),
          (e.UpdatePublishTime = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.UpdatePublishTime#1",
              (0, b.I8)(D, t),
              A,
              { ePrivilege: 7 },
            );
          });
      })(n || (n = {}));
      var W = r(34629),
        F = r(96059),
        q = r(81393),
        N = r(68797),
        x = r(6419),
        U = r(6144),
        j = r(73745),
        L = r(78327);
      const H = "default",
        X = "steam_default_assetset",
        V = "steam_default_hidden";
      class Z {
        m_mapAssetSets = new Map();
        m_mapAssetSetCallback = new Map();
        m_dummyAssetSetCallback = new U.lu();
        m_mapAssetSetListChangeCallback = new Map();
        m_SteamInterface = null;
        GetAllAssetSets(e) {
          return Array.from(this.m_mapAssetSets.values()).filter(
            (t) => t.appid === e,
          );
        }
        GetAllNonSpecialAssetSets(e) {
          return Array.from(this.m_mapAssetSets.values()).filter(
            (t) => t.appid === e && t.name != X && t.name != V,
          );
        }
        GetAllPublicAssetSets(e) {
          return Array.from(this.m_mapAssetSets.values()).filter(
            (t) => t.appid === e && t.branches.includes(H),
          );
        }
        GetAssetSetByID(e, t) {
          return t
            ? this.m_mapAssetSets.get(t)
            : {
                name: (0, p.we)(
                  "#TimelineMarkers_Hidden_new_asset_set_new_name",
                  this.GetAllNonSpecialAssetSets(e).length + 1,
                ),
                desc: "",
              };
        }
        GetAssetSetChangeCallback(e) {
          return e
            ? (this.m_mapAssetSetCallback.has(e) ||
                this.m_mapAssetSetCallback.set(e, new U.lu()),
              this.m_mapAssetSetCallback.get(e))
            : this.m_dummyAssetSetCallback;
        }
        GetAppAssetSetListChangeCallback(e) {
          return (
            this.m_mapAssetSetListChangeCallback.has(e) ||
              this.m_mapAssetSetListChangeCallback.set(e, new U.lu()),
            this.m_mapAssetSetListChangeCallback.get(e)
          );
        }
        GetPublicSpecialAssetSet(e) {
          const t = this.GetAllAssetSets(e);
          for (let e = 0; e < t.length; ++e)
            if (t[e].name == X) return t[e].assetset_id;
          return null;
        }
        GetHiddenSpecialAssetSet(e) {
          const t = this.GetAllAssetSets(e);
          for (let e = 0; e < t.length; ++e)
            if (t[e].name == V) return t[e].assetset_id;
          return null;
        }
        async CreateAssetSet(e) {
          const t = b.w.Init(y);
          let r = null;
          try {
            t.Body().set_appid(e.appid), t.Body().set_assetset(M.fromObject(e));
            const i = await n.CreateAssetSet(
              this.m_SteamInterface.GetServiceTransport(),
              t,
            );
            if (i.GetEResult() == _.d.k_EResultOK) {
              const t = i.Body().assetset().toObject();
              return (
                this.m_mapAssetSets.set(t.assetset_id, t),
                this.GetAppAssetSetListChangeCallback(e.appid).Dispatch(
                  this.GetAllAssetSets(e.appid),
                ),
                _.d.k_EResultOK
              );
            }
            r = (0, N.H)(i);
          } catch (e) {
            r = (0, N.H)(e);
          }
          return (
            console.error(
              "CAssetSetStore.CreateAssetSet failed: on item " +
                e.appid +
                " with " +
                r?.strErrorMsg,
              r,
            ),
            _.d.k_EResultFail
          );
        }
        async UpdateAssetSet(e) {
          const t = b.w.Init(R);
          let r = null;
          try {
            t.Body().set_appid(e.appid), t.Body().set_assetset(M.fromObject(e));
            const i = await n.UpdateAssetSet(
              this.m_SteamInterface.GetServiceTransport(),
              t,
            );
            if (i.GetEResult() == _.d.k_EResultOK)
              return (
                this.m_mapAssetSets.set(e.assetset_id, e),
                this.GetAssetSetChangeCallback(e.assetset_id).Dispatch(e),
                _.d.k_EResultOK
              );
            r = (0, N.H)(i);
          } catch (e) {
            r = (0, N.H)(e);
          }
          return (
            console.error(
              "CAssetSetStore.UpdateAssetSet failed: on item " +
                e.appid +
                " with " +
                r?.strErrorMsg,
              r,
            ),
            _.d.k_EResultFail
          );
        }
        async DeleteAssetSet(e, t) {
          const r = b.w.Init(B);
          let i = null;
          try {
            r.Body().set_appid(e), r.Body().set_assetset_id(t);
            const a = await n.DeleteAssetSet(
              this.m_SteamInterface.GetServiceTransport(),
              r,
            );
            if (a.GetEResult() == _.d.k_EResultOK)
              return (
                this.m_mapAssetSets.delete(t),
                this.GetAppAssetSetListChangeCallback(e).Dispatch(
                  this.GetAllAssetSets(e),
                ),
                _.d.k_EResultOK
              );
            i = (0, N.H)(a);
          } catch (e) {
            i = (0, N.H)(e);
          }
          return (
            console.error(
              "CAssetSetStore.DeleteAssetSet failed: on item " +
                e +
                " with " +
                i?.strErrorMsg,
              i,
            ),
            _.d.k_EResultFail
          );
        }
        async AddBranchToAssetSet(e, t, r) {
          const i = b.w.Init(E);
          let a = null;
          const s = this.m_mapAssetSets.get(t);
          if (!s)
            return (
              console.log(
                "CAssetSetStore.AddBranchToAssetSet object missing: " + t,
              ),
              _.d.k_EResultFail
            );
          try {
            i.Body().set_appid(e),
              i.Body().set_assetset_id(t),
              i.Body().set_branch(r);
            const l = await n.AddBranchToAssetSet(
              this.m_SteamInterface.GetServiceTransport(),
              i,
            );
            if (l.GetEResult() == _.d.k_EResultOK)
              return (
                s.branches || (s.branches = []),
                s.branches.push(r),
                this.GetAssetSetChangeCallback(s.assetset_id).Dispatch({
                  ...s,
                }),
                _.d.k_EResultOK
              );
            a = (0, N.H)(l);
          } catch (e) {
            a = (0, N.H)(e);
          }
          return (
            console.error(
              "CAssetSetStore.AddBranchToAssetSet failed: on item " +
                e +
                " with " +
                a?.strErrorMsg,
              a,
            ),
            _.d.k_EResultFail
          );
        }
        async RemoveBranchFromAssetSet(e, t, r) {
          const i = b.w.Init(k);
          let a = null;
          const s = this.m_mapAssetSets.get(t);
          if (!s)
            return (
              console.log(
                "CAssetSetStore.RemoveBranchFromAssetSet object missing: " + t,
              ),
              _.d.k_EResultFail
            );
          const l = (s.branches || []).findIndex((e) => e === r);
          if (l < 0)
            return (
              console.log(
                "CAssetSetStore.RemoveBranchFromAssetSet branch does not exist: " +
                  t,
              ),
              _.d.k_EResultFail
            );
          try {
            i.Body().set_appid(e),
              i.Body().set_assetset_id(t),
              i.Body().set_branch(r);
            const o = await n.RemoveBranchFromAssetSet(
              this.m_SteamInterface.GetServiceTransport(),
              i,
            );
            if (o.GetEResult() == _.d.k_EResultOK)
              return (
                s.branches.splice(l, 1),
                this.GetAssetSetChangeCallback(s.assetset_id).Dispatch({
                  ...s,
                }),
                _.d.k_EResultOK
              );
            a = (0, N.H)(o);
          } catch (e) {
            a = (0, N.H)(e);
          }
          return (
            console.error(
              "CAssetSetStore.RemoveBranchFromAssetSet failed: on item " +
                e +
                " with " +
                a?.strErrorMsg,
              a,
            ),
            _.d.k_EResultFail
          );
        }
        static s_Singleton;
        static Get() {
          return (
            Z.s_Singleton ||
              ((Z.s_Singleton = new Z()),
              Z.s_Singleton.Init(),
              "dev" == L.TS.WEB_UNIVERSE &&
                (window.g_AssetSetStore = Z.s_Singleton)),
            Z.s_Singleton
          );
        }
        Init() {
          let e = (0, L.Tc)("asset_sets", "application_config");
          this.ValidateStoreDefault(e) &&
            e.forEach((e) => this.m_mapAssetSets.set(e.assetset_id, e));
          const t = (0, L.Tc)(
            "promotion_operation_token",
            "application_config",
          );
          (0, q.wT)(Boolean(t), "require promotion_operation_token"),
            "dev" == L.TS.WEB_UNIVERSE &&
              console.log(
                "DEV_DEBUG Initializing CAssetSetStore with access token ",
                t,
              ),
            (this.m_SteamInterface = new F.D(L.TS.WEBAPI_BASE_URL, t));
        }
        ValidateStoreDefault(e) {
          const t = e;
          return (
            !!(
              t &&
              Array.isArray(t) &&
              t.length > 0 &&
              "object" == typeof t[0]
            ) &&
            "string" == typeof t[0].assetset_id &&
            "number" == typeof t[0].appid
          );
        }
      }
      function K() {
        return {
          fnCreateAssetSet: Z.Get().CreateAssetSet,
          fnUpdateAssetSet: Z.Get().UpdateAssetSet,
          fnDeleteAssetSet: Z.Get().DeleteAssetSet,
          fnAddBranchToAssetSet: Z.Get().AddBranchToAssetSet,
          fnRemoveBranchFromAssetSet: Z.Get().RemoveBranchFromAssetSet,
        };
      }
      function Q(e, t) {
        return Z.Get().GetAssetSetByID(e, t)?.name || (0, p.we)("#Unknown");
      }
      function J(e) {
        const [t, r] = (0, a.useState)(null),
          [i, n] = (0, a.useState)(null),
          s = (0, a.useCallback)((e) => {
            Z.Get()
              .GetAllAssetSets(e)
              .forEach((e) => {
                e.name === X
                  ? r(e.assetset_id)
                  : e.name === V && n(e.assetset_id);
              });
          }, []);
        return (
          (0, a.useEffect)(() => s(e), [e, s]),
          (0, j.hL)(Z.Get().GetAppAssetSetListChangeCallback(e), (t) => s(e)),
          { publicAssetSetID: t, hiddenAssetSetID: i }
        );
      }
      function $(e, t) {
        const [r, i] = (0, a.useState)(() => Z.Get().GetAssetSetByID(e, t));
        return (0, j.hL)(Z.Get().GetAssetSetChangeCallback(t), i), r;
      }
      async function Y(e, t) {
        const { fnCreateAssetSet: r } = K(),
          i = { appid: e, name: t ? X : V, branches: t ? [H] : [] },
          n = await r(i);
        return n != _.d.k_EResultOK
          ? { eResult: n, assetSetID: null }
          : {
              eResult: n,
              assetSetID: t
                ? Z.Get().GetPublicSpecialAssetSet(e)
                : Z.Get().GetHiddenSpecialAssetSet(e),
            };
      }
      (0, W.Cg)([x.o], Z.prototype, "CreateAssetSet", null),
        (0, W.Cg)([x.o], Z.prototype, "UpdateAssetSet", null),
        (0, W.Cg)([x.o], Z.prototype, "DeleteAssetSet", null),
        (0, W.Cg)([x.o], Z.prototype, "AddBranchToAssetSet", null),
        (0, W.Cg)([x.o], Z.prototype, "RemoveBranchFromAssetSet", null);
      var ee = r(41735),
        te = r.n(ee);
      let re = null;
      var ie = r(32754);
      function ne(e) {
        const { assetSetID: t, className: r, appid: i } = e,
          { publicAssetSetID: n } = J(i);
        return a.createElement(
          m.$n,
          {
            onClick: (e) =>
              (function (e, t, r) {
                const i = new Map();
                if (t) {
                  ue(t).forEach((e) => {
                    const r = de(t, e);
                    i.set(r.markerid, r);
                  });
                }
                if (r && r != t) {
                  ue(r).forEach((e) => {
                    const t = de(r, e);
                    i.set(t.markerid, t);
                  });
                }
                let n =
                  '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs>';
                Array.from(i.values()).forEach((e) => {
                  n += ae(e);
                }),
                  (n += "</defs></svg>");
                const a = `${e}_markers.svg`;
                !(function (e, t) {
                  const r = new Blob([t], { type: "text/plain" }),
                    i = window.URL.createObjectURL(r),
                    n = document.createElement("a");
                  (n.href = i),
                    (n.download = e),
                    document.body.appendChild(n),
                    n.click(),
                    window.URL.revokeObjectURL(i);
                })(a, n);
              })(i, n, t),
            disabled: !t,
          },
          "",
          " ",
          (0, p.we)("#TimelineMarkers_Hidden_download"),
          "",
          a.createElement(
            ie.he,
            {
              toolTipContent: (0, p.we)(
                "#TimelineMarkers_Hidden_download_ttip",
              ),
              className: r,
            },
            "(?)",
          ),
        );
      }
      function ae(e) {
        let t = `<g id="${e.markerid}">`;
        return (
          e.image_type == i.k_ETimelineImageType_SVG_XML
            ? (t += (function (e) {
                const t = new DOMParser(),
                  r = t
                    .parseFromString(e, "image/svg+xml")
                    .querySelector("svg");
                return r ? r.innerHTML : null;
              })(e.image))
            : e.image_type == i.k_ETimelineImageType_PNG &&
              (t += `<image width="36" height="36" xlink:href='${e.image}' />`),
          (t += "</g>"),
          t
        );
      }
      const se = 128,
        le = 128,
        oe = 24;
      class me {
        m_mapTimelineMarker = new Map();
        m_mapAppToMarkerListChange = new Map();
        m_mapAssetSetAndMarkerIDToMarkerChanges = new Map();
        GetAllMarkersForApp(e) {
          return Array.from(this.m_mapTimelineMarker.values()).filter(
            (t) => t.appid == e,
          );
        }
        GetMarkerForAssetSets(e) {
          if (!e || 0 == e.length) return [];
          const t = new Map();
          return (
            e.forEach((e) => t.set(e.assetset_id, !0)),
            Array.from(this.m_mapTimelineMarker.values()).filter((e) =>
              t.has(e.asset_set_id),
            )
          );
        }
        GetGameMarkerSVGById(e, t) {
          const r = this.m_mapTimelineMarker.get(t);
          if (r) return ae(r);
        }
        AddTempMarker(e, t) {
          this.m_mapTimelineMarker.set(e, t);
        }
        RemoveTempMarker(e) {
          this.m_mapTimelineMarker.delete(e);
        }
        BIsLoaded(e) {
          return !0;
        }
        GetMarkerChange(e, t) {
          const r = e + "_" + t;
          return (
            this.m_mapAssetSetAndMarkerIDToMarkerChanges.has(r) ||
              this.m_mapAssetSetAndMarkerIDToMarkerChanges.set(r, new U.lu()),
            this.m_mapAssetSetAndMarkerIDToMarkerChanges.get(r)
          );
        }
        GetAppMarkerListChange(e) {
          return (
            this.m_mapAppToMarkerListChange.has(e) ||
              this.m_mapAppToMarkerListChange.set(e, new U.lu()),
            this.m_mapAppToMarkerListChange.get(e)
          );
        }
        GetAppMarkers(e, t) {
          let r = null,
            i = null;
          return (
            Array.from(this.m_mapTimelineMarker.values()).forEach((n) => {
              n.asset_set_id == e &&
                n.markerid == t &&
                (n.unpublished_changes ? (i = n) : (r = n));
            }),
            { oPublishedMarker: r, oUnpublishedMarker: i }
          );
        }
        GetMarkerIDSetForAssetSetID(e) {
          const t = new Set();
          return (
            this.m_mapTimelineMarker.forEach((r) => {
              r.asset_set_id === e && t.add(r.markerid);
            }),
            t
          );
        }
        GetUnpublishedTimelineMarkerIDSetForAssetSetID(e) {
          const t = new Set();
          return (
            this.m_mapTimelineMarker.forEach((r) => {
              r.asset_set_id === e &&
                r.unpublished_changes &&
                t.add(r.timeline_marker_id);
            }),
            t
          );
        }
        BDoesAssetSetHaveMarkerID(e, t) {
          return Array.from(this.m_mapTimelineMarker.values()).some(
            (r) => r.asset_set_id == e && r.markerid == t,
          );
        }
        GetUnpublishedThanPublishedFor(e, t) {
          const r = this.GetAppMarkers(e, t);
          return r.oUnpublishedMarker
            ? r.oUnpublishedMarker
            : r.oPublishedMarker;
        }
        EnsureRequirePublishingIsVisible() {
          const e = document.getElementById("needs_publishing_msg");
          if (e) {
            "none" === e.style.display && (e.style.display = "block");
          }
        }
        async CreateTimelineMarkerDefinition(e, t, r, i, n) {
          let a = null;
          try {
            const s = new FormData();
            s.append("sessionid", L.TS.SESSIONID),
              s.append("appid", "" + e),
              s.append("asset_set_id", t),
              s.append("markerid", r),
              s.append("imagedata", i),
              s.append("imagetype", "" + n);
            const l = `${L.TS.PARTNER_BASE_URL}timelinemarkers/ajaxcreatemarker`,
              o = await te().post(l, s);
            if (200 == o?.status && o.data.success == _.d.k_EResultOK) {
              const r = o.data.new_marker;
              return (
                "dev" == L.TS.WEB_UNIVERSE &&
                  console.log("new marker created: ", r),
                this.m_mapTimelineMarker.set(r.timeline_marker_id, r),
                this.GetAppMarkerListChange(e).Dispatch([
                  ...this.GetAllMarkersForApp(e),
                ]),
                Q(e, t) == X && this.EnsureRequirePublishingIsVisible(),
                _.d.k_EResultOK
              );
            }
            a = (0, N.H)(o);
          } catch (e) {
            a = (0, N.H)(e);
          }
          return (
            console.error(
              "CTimelineMarkerEditorStore create failed with " + a.strErrorMsg,
              a,
            ),
            _.d.k_EResultFail
          );
        }
        async UpdateTimelineMarkerDefinition(e, t, r, i, n, a) {
          let s = null;
          const l = this.m_mapTimelineMarker.get(r);
          if (!l)
            return (
              console.error(
                "CTimelineMarkerEditorStore attempting update, timeline markerid does not exist: " +
                  r,
              ),
              _.d.k_EResultNoMatch
            );
          (0, q.wT)(
            e == l.appid,
            "Unexpected in UpdateTimelineMarkerDefinition appid don't match",
          );
          const o = l.markerid,
            m = l.asset_set_id;
          try {
            const l = new FormData();
            l.append("sessionid", L.TS.SESSIONID),
              l.append("appid", "" + e),
              l.append("asset_set_id", t),
              l.append("markerid", i),
              l.append("imagedata", n),
              l.append("imagetype", "" + a),
              l.append("timeline_marker_id", r);
            const c = `${L.TS.PARTNER_BASE_URL}timelinemarkers/ajaxupdatemarker`,
              d = await te().post(c, l);
            if (200 == d?.status && d.data.success == _.d.k_EResultOK) {
              const r = d.data.updated_marker;
              this.m_mapTimelineMarker.set(r.timeline_marker_id, r);
              const i = this.GetAppMarkers(m, o);
              if (
                (this.GetMarkerChange(m, o).Dispatch(
                  i.oPublishedMarker,
                  i.oUnpublishedMarker,
                ),
                o != r.markerid)
              ) {
                const e = this.GetAppMarkers(t, r.markerid);
                this.GetMarkerChange(t, r.markerid).Dispatch(
                  e.oPublishedMarker,
                  e.oUnpublishedMarker,
                );
              }
              return (
                this.GetAppMarkerListChange(e).Dispatch([
                  ...this.GetAllMarkersForApp(e),
                ]),
                Q(e, t) == X && this.EnsureRequirePublishingIsVisible(),
                _.d.k_EResultOK
              );
            }
            s = (0, N.H)(d);
          } catch (e) {
            s = (0, N.H)(e);
          }
          return (
            console.error(
              "CTimelineMarkerEditorStore update failed with " + s.strErrorMsg,
              s,
            ),
            _.d.k_EResultFail
          );
        }
        async DeleteTimelineMarkerDefinition(e, t, r) {
          let i = null;
          const n = this.m_mapTimelineMarker.get(r);
          if (!n)
            return (
              console.error(
                "CTimelineMarkerEditorStore attempting delete, timeline markerid does not exist: " +
                  r,
              ),
              _.d.k_EResultNoMatch
            );
          const a = n.markerid;
          try {
            const s = new FormData();
            s.append("sessionid", L.TS.SESSIONID),
              s.append("appid", "" + e),
              s.append("asset_set_id", t),
              s.append("timeline_marker_id", r);
            const l = `${L.TS.PARTNER_BASE_URL}timelinemarkers/ajaxdeletemarker`,
              o = await te().post(l, s);
            if (200 == o?.status && o.data.success == _.d.k_EResultOK) {
              this.m_mapTimelineMarker.delete(r);
              const i = this.GetAppMarkers(t, a);
              return (
                (i?.oPublishedMarker || i.oUnpublishedMarker) &&
                  this.GetMarkerChange(t, n.markerid).Dispatch(
                    i.oPublishedMarker,
                    i.oUnpublishedMarker,
                  ),
                this.GetAppMarkerListChange(e).Dispatch([
                  ...this.GetAllMarkersForApp(e),
                ]),
                _.d.k_EResultOK
              );
            }
            i = (0, N.H)(o);
          } catch (e) {
            i = (0, N.H)(e);
          }
          return (
            console.error(
              "DeleteTimelineMarkerDefinition create failed with " +
                i.strErrorMsg,
              i,
            ),
            _.d.k_EResultFail
          );
        }
        async PublishTimelineMarkerDefinitions(e, t, r) {
          let i = null;
          for (let e = 0; e < r.length; ++e) {
            const t = r[e],
              i = this.m_mapTimelineMarker.get(t);
            if (!i)
              return (
                console.error(
                  "CTimelineMarkerEditorStore attempting publish, timeline markerid does not exist: " +
                    t,
                ),
                _.d.k_EResultNoMatch
              );
            if (!i.unpublished_changes)
              return (
                console.error(
                  "CTimelineMarkerEditorStore attempting publish already published asset: " +
                    t,
                ),
                _.d.k_EResultInvalidState
              );
          }
          try {
            const n = new FormData();
            n.append("sessionid", L.TS.SESSIONID),
              n.append("appid", "" + e),
              n.append("asset_set_id", t),
              n.append("timeline_marker_id", r.join(","));
            const a = `${L.TS.PARTNER_BASE_URL}timelinemarkers/ajaxpublishmarkers`,
              s = await te().post(a, n);
            if (200 == s?.status && s.data.success == _.d.k_EResultOK) {
              for (let e = 0; e < r.length; ++e) {
                const t = r[e],
                  i = this.m_mapTimelineMarker.get(t),
                  n = this.GetAppMarkers(i.asset_set_id, i.markerid);
                n.oPublishedMarker &&
                  this.m_mapTimelineMarker.delete(
                    n.oPublishedMarker.timeline_marker_id,
                  );
                const a = {
                  ...n.oUnpublishedMarker,
                  unpublished_changes: !1,
                  time_last_updater: Math.floor(Date.now() / 1e3),
                };
                this.m_mapTimelineMarker.set(a.timeline_marker_id, a),
                  this.GetMarkerChange(a.asset_set_id, a.markerid).Dispatch(
                    a,
                    null,
                  );
              }
              return (
                this.GetAppMarkerListChange(e).Dispatch([
                  ...this.GetAllMarkersForApp(e),
                ]),
                _.d.k_EResultOK
              );
            }
            i = (0, N.H)(s);
          } catch (e) {
            i = (0, N.H)(e);
          }
          return (
            console.error(
              "PublishTimelineMarkerDefinition create failed with " +
                i.strErrorMsg,
              i,
            ),
            _.d.k_EResultFail
          );
        }
        static s_Singleton;
        static Get() {
          return (
            me.s_Singleton ||
              ((me.s_Singleton = new me()),
              me.s_Singleton.Init(),
              "dev" == L.TS.WEB_UNIVERSE &&
                (window.g_TimelineMarkerEditStore = me.s_Singleton)),
            me.s_Singleton
          );
        }
        Init() {
          let e = (0, L.Tc)("timeline_markers", "application_config");
          var t;
          this.ValidateStoreDefault(e) &&
            e.forEach((e) =>
              this.m_mapTimelineMarker.set(e.timeline_marker_id, e),
            ),
            (t = he),
            re
              ? console.error(
                  "Attempt to set timeline marker hook a second time",
                )
              : (re = t);
        }
        ValidateStoreDefault(e) {
          const t = e;
          return (
            !!(
              t &&
              Array.isArray(t) &&
              t.length > 0 &&
              "object" == typeof t[0]
            ) &&
            "string" == typeof t[0].asset_set_id &&
            "number" == typeof t[0].appid
          );
        }
      }
      function ce() {
        return {
          fnCreateTimelineMarkerDefinition:
            me.Get().CreateTimelineMarkerDefinition,
          fnUpdateTimelineMarkerDefinition:
            me.Get().UpdateTimelineMarkerDefinition,
          fnDeleteTimelineMarkerDefinition:
            me.Get().DeleteTimelineMarkerDefinition,
          fnPublishTimelineMarkerDefinitions:
            me.Get().PublishTimelineMarkerDefinitions,
        };
      }
      function de(e, t) {
        return me.Get().GetUnpublishedThanPublishedFor(e, t);
      }
      function ue(e) {
        return Array.from(me.Get().GetMarkerIDSetForAssetSetID(e));
      }
      function ge(e, t) {
        return me.Get().AddTempMarker(e, t);
      }
      function pe(e) {
        return me.Get().RemoveTempMarker(e);
      }
      function _e(e) {
        const [t, r] = (0, a.useState)(() => me.Get().GetAllMarkersForApp(e));
        return (0, j.hL)(me.Get().GetAppMarkerListChange(e), r), t;
      }
      function fe(e, t) {
        const [r, i] = (0, a.useState)(() =>
          me.Get().GetMarkerIDSetForAssetSetID(t),
        );
        return (
          (0, a.useEffect)(() => {
            t && e && i(me.Get().GetMarkerIDSetForAssetSetID(t));
          }, [e, t]),
          (0, j.hL)(me.Get().GetAppMarkerListChange(e), () =>
            i(me.Get().GetMarkerIDSetForAssetSetID(t)),
          ),
          r
        );
      }
      function he(e, t) {
        const r = me.Get().GetGameMarkerSVGById(e, t);
        if (!r) return null;
        const i = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">${r}</svg>`;
        return new DOMParser().parseFromString(i, "image/svg+xml")
          .documentElement.firstChild;
      }
      (0, W.Cg)([j.oI], me.prototype, "CreateTimelineMarkerDefinition", null),
        (0, W.Cg)([j.oI], me.prototype, "UpdateTimelineMarkerDefinition", null),
        (0, W.Cg)([j.oI], me.prototype, "DeleteTimelineMarkerDefinition", null),
        (0, W.Cg)(
          [j.oI],
          me.prototype,
          "PublishTimelineMarkerDefinitions",
          null,
        );
      var Se = r(71298),
        be = r(56330),
        Me = r(9154),
        ye = r(12155),
        Te = r(52038),
        Be = r(43456),
        ve = r(83113),
        Re = r(82554);
      function Ge(e) {
        const { imageBase64OrUntrustedSVG: t, imageType: r } = e;
        if (!t) return null;
        let n;
        return (
          r == i.k_ETimelineImageType_SVG_XML
            ? (n = `data:image/svg+xml,${encodeURIComponent(t)}`)
            : r == i.k_ETimelineImageType_PNG && (n = t),
          a.createElement(
            "div",
            { className: (0, Te.A)(Be.IconPreviewCtn) },
            a.createElement(
              "div",
              { className: ve.Icons },
              a.createElement("img", {
                className: ve.LargeIcon,
                src: n,
                alt: "SVG Large Preview",
              }),
              a.createElement("img", {
                className: ve.MediumIcon,
                src: n,
                alt: "SVG Medium Preview",
              }),
              a.createElement("img", {
                className: ve.SmallIcon,
                src: n,
                alt: "SVG Small Preview",
              }),
            ),
          )
        );
      }
      function we(e) {
        const { svgXmlUntrusted: t } = e;
        if (!t) return null;
        const r = `data:image/svg+xml,${encodeURIComponent(t)}`;
        return a.createElement("img", {
          className: ve.SmallIcon,
          src: r,
          alt: "SVG Small Preview",
        });
      }
      function Ce(e) {
        const { appid: t, assetSetID: r, markerID: i } = e,
          { oPublishedMarker: n, oUnpublishedMarker: s } = (function (e, t) {
            const [r, i] = (0, a.useState)(null),
              [n, s] = (0, a.useState)(null);
            return (
              (0, a.useEffect)(() => {
                const r = me.Get().GetAppMarkers(e, t);
                r && (i(r.oPublishedMarker), s(r.oUnpublishedMarker));
              }, [e, t]),
              (0, j.hL)(me.Get().GetMarkerChange(e, t), (e, t) => {
                i(e), s(t);
              }),
              { oPublishedMarker: r, oUnpublishedMarker: n }
            );
          })(r, i),
          { publicAssetSetID: l, hiddenAssetSetID: o } = J(t),
          [c, d] = (0, a.useState)(!1);
        if (!n && !s) return null;
        const _ = s || n,
          f = Boolean(s && s.asset_set_id != o),
          h = n?.asset_set_id === l;
        return a.createElement(
          "div",
          {
            className: ve.IconContents,
            onMouseEnter: () => d(!0),
            onMouseLeave: () => d(!1),
          },
          f &&
            a.createElement(
              "span",
              { className: ve.MsgUnpublished },
              (0, p.we)("#TimelineMarker_state_pending"),
            ),
          a.createElement(Ge, {
            imageBase64OrUntrustedSVG: _.image,
            imageType: _.image_type,
          }),
          a.createElement("div", { className: ve.MarkerID }, _.markerid),
          c &&
            a.createElement(
              m.$n,
              {
                className: ve.EditButton,
                onClick: (e) =>
                  (0, u.pg)(
                    a.createElement(oa, {
                      appid: t,
                      bDisallowMarkerIDEdit: h,
                      oTimelineMarkerDef: _,
                    }),
                    (0, g.uX)(e),
                  ),
              },
              (0, p.we)("#Button_Edit"),
            ),
        );
      }
      function Ee(e) {
        const {
            appid: t,
            assetSetID: r,
            strMessageOnEmpty: i,
            bDraggable: n,
          } = e,
          s = fe(t, r);
        return s && 0 != s.size
          ? a.createElement(
              "div",
              { className: ve.IconGridCtn },
              a.createElement(
                ke,
                { assetSetID: r },
                Array.from(s).map((e, i) =>
                  a.createElement(
                    Ie,
                    {
                      key: r + "_" + e,
                      id: `assetsetid_${r}_markerid_${e}`,
                      index: i,
                      bDraggable: n,
                    },
                    a.createElement(Ce, {
                      appid: t,
                      assetSetID: r,
                      markerID: e,
                    }),
                  ),
                ),
              ),
            )
          : a.createElement("div", { className: Re.NoHidden }, i);
      }
      function Ie(e) {
        const { id: t, children: r, index: i, bDraggable: n } = e;
        return a.createElement(
          s.sx,
          { draggableId: t, index: i, isDragDisabled: !n },
          (e) =>
            a.createElement(
              "div",
              {
                ref: e.innerRef,
                ...e.draggableProps,
                ...e.dragHandleProps,
                className: ve.DraggableBox,
                style: { ...e.draggableProps.style },
              },
              r,
            ),
        );
      }
      function ke(e) {
        const { assetSetID: t, children: r } = e;
        return a.createElement(
          s.gL,
          { droppableId: "undroppable" + t, direction: "horizontal" },
          (e) =>
            a.createElement(
              "div",
              {
                ref: e.innerRef,
                ...e.droppableProps,
                style: { display: "flex" },
              },
              r,
              e.placeholder,
            ),
        );
      }
      function Pe(e) {
        const { assetSetID: t, appid: r, strMessage: i } = e;
        return a.createElement(
          s.gL,
          { droppableId: `droptarget_assetsetid_${t}_appid_${r}` },
          (e) =>
            a.createElement(
              "div",
              { ...e.droppableProps, ref: e.innerRef, className: ve.DragBox },
              a.createElement("span", null, i),
              e.placeholder,
            ),
        );
      }
      var Oe = r(14947),
        ze = r(86318),
        De = r(59134),
        Ae = r(60778),
        We = r(14771);
      const Fe = new Ae.wd("ReactUsageReporting").Debug,
        qe = 1e3 * We.Kp.PerMinute;
      class Ne {
        m_strProduct;
        m_strVersion;
        m_transport = null;
        m_mapRoutes = new Map();
        m_mapComponents = new Map();
        m_mapActions = new Map();
        m_reportCount = 0;
        m_bInitialized = !1;
        Init(e, t, r) {
          (this.m_bInitialized = !0),
            (this.m_strProduct = e),
            (this.m_strVersion = t),
            (this.m_transport = r),
            this.ScheduleSend();
        }
        ScheduleSend() {
          setTimeout(() => this.CheckSend(), qe);
        }
        CheckSend() {
          this.m_reportCount > 0 && this.SendMetrics(), this.ScheduleSend();
        }
        ReportInternal(e, t) {
          t.has(e) || t.set(e, 0),
            t.set(e, t.get(e) + 1),
            this.m_reportCount++,
            this.ShouldSendMetricsImmediately() && this.SendMetrics();
        }
        ReportRouteMatch(e) {
          Fe("Route match: " + e), this.ReportInternal(e, this.m_mapRoutes);
        }
        ReportTrackedComponent(e) {
          Fe("Tracked component: " + e),
            this.ReportInternal(e, this.m_mapComponents);
        }
        ReportTrackedAction(e) {
          Fe("User action: " + e), this.ReportInternal(e, this.m_mapActions);
        }
        ShouldSendMetricsImmediately() {
          return this.m_reportCount >= 100;
        }
        SendMetrics() {
          if (!this.m_bInitialized) return;
          const e = b.w.Init(De.bc);
          e.Body().set_product(this.m_strProduct),
            e.Body().set_version(this.m_strVersion),
            this.m_mapRoutes.forEach((t, r) => {
              let i = new De.N4();
              i.set_route(r), i.set_count(t), e.Body().add_routes(i);
            }),
            this.m_mapComponents.forEach((t, r) => {
              let i = new De.Zd();
              i.set_component(r), i.set_count(t), e.Body().add_components(i);
            }),
            this.m_mapActions.forEach((t, r) => {
              let i = new De.Ys();
              i.set_action(r), i.set_count(t), e.Body().add_actions(i);
            }),
            this.m_mapRoutes.clear(),
            this.m_mapComponents.clear(),
            this.m_mapActions.clear(),
            (this.m_reportCount = 0),
            De._5.ReportReactUsage(this.m_transport, e);
        }
        get version() {
          return this.m_strVersion;
        }
        get product() {
          return this.m_strProduct;
        }
      }
      (0, W.Cg)([x.o], Ne.prototype, "CheckSend", null);
      const xe = new Ne();
      var Ue = r(65946);
      function je() {
        return window.g_GRS;
      }
      function Le() {
        if (null != je()) {
          const e = je();
          return {
            bLoading: e.BLoadingAppsWithBackgroundVideo(),
            rgApps: e.GetAppsWithBackgroundVideo(),
          };
        }
        return { bLoading: !1, rgApps: [] };
      }
      function He(e) {
        const { bLoading: t, rgApps: r } = (function () {
          const [e, t] = (0, a.useState)(Le());
          return (0, a.useEffect)(() => (0, Oe.mJ)(Le, t), []), e;
        })();
        return {
          bLoading: t,
          app: (0, a.useMemo)(() => r.find((t) => t.game_id === e), [r, e]),
        };
      }
      function Xe(e, t, r, i, n, a) {
        return null != je()
          ? je().LoadThumbnails(e, t, r, i, n, a ?? !0)
          : null;
      }
      function Ve() {
        return null != je()
          ? {
              fnCreateUserTimelineMarkers: je().CreateUserTimelineMarkers,
              fnUpdateUserTimelineMarkers: je().UpdateUserTimelineMarkers,
              fnRemoveUserTimelineMarker: je().RemoveUserTimelineMarker,
            }
          : null;
      }
      function Ze(e, t) {
        return (0, Ue.q3)(() => {
          if (null != je()) return je().GetAchievementInfo(e, t);
        });
      }
      function Ke() {
        return (0, Ue.q3)(() => {
          if (null != je()) return !je().BEnoughDiskSpace();
        });
      }
      var Qe,
        Je = r(53184),
        $e = r(39393),
        Ye = r(25489),
        et = r(4926),
        tt = r(62490),
        rt = r(48333);
      !(function (e) {
        (e[(e.None = 0)] = "None"),
          (e[(e.DownloadFailed = 1)] = "DownloadFailed"),
          (e[(e.PlaybackError = 2)] = "PlaybackError"),
          (e[(e.MediaTypeError = 3)] = "MediaTypeError");
      })(Qe || (Qe = {}));
      class it {
        m_elVideo = null;
        m_player = null;
        m_listeners = new U.Ji();
        m_nDownloadFailureCount = 0;
        m_bInitailized = !1;
        m_bPaused = !1;
        m_bAtEnd = !1;
        m_strMediaTypeError = null;
        m_ePlayerError = Qe.None;
        m_bUserInputNeeded = !1;
        m_bMuted = !1;
        m_bSeekReadyToPlay = !1;
        m_bVideoElementPlaying = !1;
        m_nPlaybackSpeed = 1;
        m_bIsWaiting = !0;
        m_bAutoPlay;
        m_bLoadedMetadata = !1;
        m_nPlaybackTime = 0;
        m_nVideoStartTime = 0;
        m_nVideoDuration = 0;
        m_nVolume = 1;
        m_eSeekType = rt.lU.Absolute;
        constructor(e) {
          (0, Oe.Gn)(this), (this.m_bAutoPlay = !!e);
        }
        IsPaused() {
          return this.m_bPaused;
        }
        IsAtEnd() {
          return this.m_bAtEnd;
        }
        BSeekReadyToPlay() {
          return this.m_bSeekReadyToPlay;
        }
        GetMediaTypeError() {
          return this.m_strMediaTypeError;
        }
        GetPlaybackError() {
          return this.m_ePlayerError;
        }
        GetUserInputNeeded() {
          return this.m_bUserInputNeeded;
        }
        GetPlaybackTime() {
          return this.m_eSeekType === rt.lU.Absolute
            ? this.m_nPlaybackTime
            : this.m_nPlaybackTime - this.m_nVideoStartTime;
        }
        GetTimelineDuration() {
          return this.m_eSeekType === rt.lU.Absolute
            ? this.m_nVideoDuration
            : this.m_nVideoDuration - this.m_nVideoStartTime;
        }
        GetVolume() {
          return this.m_nVolume;
        }
        GetMuted() {
          return this.m_bMuted;
        }
        GetMPDURL() {
          return this.m_player?.GetMPDURL();
        }
        GetVideoElementCurrentTime() {
          return this.m_elVideo?.currentTime;
        }
        BVideoElementPlaying() {
          return this.m_bVideoElementPlaying;
        }
        BVideoElementWaiting() {
          return this.m_bIsWaiting;
        }
        GetVideoHeight() {
          return this.m_elVideo?.clientHeight || 0;
        }
        GetVideoWidth() {
          return this.m_elVideo?.clientWidth || 0;
        }
        GetLoadedMetadata() {
          return this.m_bLoadedMetadata;
        }
        Start(e, t, r, i = rt.lU.Absolute) {
          this.Stop(),
            (this.m_bAtEnd = !1),
            (this.m_elVideo = e),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-userpausechange",
              this.OnUserPauseChange,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "playing",
              this.OnVideoPlaying,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "pause",
              this.OnVideoPause,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "timeupdate",
              this.OnVideoTimeUpdate,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "ended",
              this.OnVideoEnd,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-ended",
              this.OnVideoEnd,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-bufferupdate",
              this.OnVideoTimeUpdate,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-downloadfailed",
              this.OnDownloadFailed,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-playbackerror",
              this.OnPlaybackError,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-userinputneeded",
              this.OnUserInputNeeded,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "waiting",
              this.OnVideoWaiting,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "volumechange",
              this.OnVolumeChange,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "canplay",
              this.OnCanPlay,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "seeking",
              this.OnSeeking,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "loadedmetadata",
              this.OnLoadedMetadata,
            ),
            (this.m_player = new rt.Zn(this.m_elVideo)),
            this.m_player.SetUserPlayChoice(this.m_bAutoPlay),
            this.m_player.PlayMPD(t),
            (this.m_bMuted = st("muted")),
            (this.m_nVolume = st("volume")),
            this.m_player.SetMuted(this.m_bMuted),
            this.m_player.SetVolume(this.m_nVolume),
            (this.m_bSeekReadyToPlay = !1),
            (this.m_eSeekType = i);
          const n = `seeking_${t}_${r.toFixed(3)}`;
          (0, ze.q_)(`CGameRecordingVideo:: perf mark ${n}`),
            performance.mark(n),
            this.m_player.Seek(r, this.m_eSeekType),
            (this.m_bPaused = this.m_player.IsPaused()),
            (this.m_bInitailized = !0);
        }
        Stop() {
          this.m_listeners.Unregister(),
            this.m_player && this.m_player.Close(),
            (this.m_elVideo = null),
            (this.m_player = null),
            (this.m_bInitailized = !1),
            (this.m_bPaused = !1),
            (this.m_bAtEnd = !1),
            (this.m_bSeekReadyToPlay = !1),
            (this.m_bVideoElementPlaying = !1),
            (this.m_ePlayerError = Qe.None),
            (this.m_bUserInputNeeded = !1),
            (this.m_nPlaybackTime = 0),
            (this.m_nVideoStartTime = 0),
            (this.m_nVideoDuration = 0),
            (this.m_bLoadedMetadata = !1),
            (this.m_bIsWaiting = !0);
        }
        async UpdateMPD() {
          await this.m_player?.UpdateMPD();
        }
        IsInitialized() {
          return this.m_bInitailized;
        }
        OnCanPlay() {
          (this.m_bSeekReadyToPlay = !0), (this.m_bAtEnd = !1);
        }
        OnUserPauseChange() {
          this.m_bPaused = this.m_player.IsPaused();
        }
        OnVideoPlaying() {
          (this.m_bVideoElementPlaying = !0),
            (this.m_bIsWaiting = !1),
            this.SetPlaybackSpeed(this.m_nPlaybackSpeed),
            (0, ze.tG)("video playing");
        }
        OnVideoPause() {
          (this.m_bVideoElementPlaying = !1), (0, ze.tG)("video paused");
        }
        OnVideoTimeUpdate() {
          (this.m_nVideoStartTime = this.m_player.GetAvailableVideoStartTime()),
            (this.m_nVideoDuration = this.m_player.GetBufferedLiveEdgeTime()),
            (this.m_nPlaybackTime = this.m_player.GetCurrentPlayTime());
        }
        OnVideoEnd() {
          (this.m_bVideoElementPlaying = !1),
            (this.m_bAtEnd = !0),
            (0, ze.tG)("video ended");
        }
        OnSeeking() {
          (0, ze.tG)("video on seeking"),
            (this.m_bVideoElementPlaying = !1),
            (this.m_bIsWaiting = !0),
            (this.m_bAtEnd = !1);
        }
        OnLoadedMetadata() {
          this.m_bLoadedMetadata = !0;
        }
        async OnDownloadFailed(e) {
          if ((e.detail || rt.N_.PlaybackError) == rt.N_.UnsupportedMediaType)
            return (
              (0, ze.ZI)("media type error"),
              void (this.m_ePlayerError = Qe.MediaTypeError)
            );
          (0, ze.ZI)("video download failed", e.detail),
            this.m_nDownloadFailureCount < 2
              ? (await this.m_player?.UpdateMPD(),
                this.m_nDownloadFailureCount++)
              : (this.m_ePlayerError = Qe.DownloadFailed);
        }
        OnPlaybackError() {
          (this.m_bVideoElementPlaying = !1),
            (0, ze.ZI)("video playback error"),
            (this.m_ePlayerError = Qe.PlaybackError);
        }
        OnUserInputNeeded() {
          (this.m_bUserInputNeeded = !0),
            !this.m_bMuted &&
              this.m_elVideo.autoplay &&
              ((0, ze.fX)("Failed to autoplay video. Muting and trying again."),
              this.SetMute(!0),
              this.Play());
        }
        OnVolumeChange() {
          (0, ze.tG)("volume change");
        }
        OnVideoWaiting() {
          (this.m_bIsWaiting = !0),
            (this.m_bVideoElementPlaying = !1),
            this.GetTimelineDuration() - this.GetPlaybackTime() < 1 &&
              (this.m_bAtEnd = !0);
        }
        UserInputReceived() {
          this.IsInitialized() &&
            ((this.m_bUserInputNeeded = !1), this.m_player.SeekAndPlay(0));
        }
        SetVolume(e) {
          (this.m_nVolume = e),
            lt("volume", e),
            e > 0 ? this.SetMute(!1, !0) : this.SetMute(!0, !0),
            this.IsInitialized() && this.m_player.SetVolume(e);
        }
        SetMute(e, t) {
          this.IsInitialized() && this.m_player.SetMuted(e),
            (this.m_bMuted = e),
            t && lt("muted", e);
        }
        TogglePlayPause() {
          this.IsInitialized() &&
            (this.m_player.IsPaused() ? this.Play() : this.Pause());
        }
        Play() {
          this.IsInitialized() && this.m_player.Play();
        }
        Pause() {
          this.IsInitialized() &&
            (this.m_player.Pause(), (this.m_bIsWaiting = !1));
        }
        SetPlaybackSpeed(e) {
          (this.m_nPlaybackSpeed = e),
            this.IsInitialized() && (this.m_elVideo.playbackRate = e);
        }
        GetPlaybackSpeed() {
          return this.m_nPlaybackSpeed;
        }
        Seek(e) {
          if (!this.IsInitialized()) return;
          const t = `seeking_${this.m_player.GetMPDURL()}_${e.toFixed(3)}`;
          (this.m_bAtEnd = !1),
            (this.m_bSeekReadyToPlay = !1),
            performance.mark(t),
            (0, ze.q_)(`CGameRecordingVideo:: perf mark ${t}`),
            (0, ze.q_)(`CGameRecordingVideo::Seek to ${e}`),
            (this.m_nPlaybackTime = e),
            this.m_player.Seek(e, this.m_eSeekType);
        }
      }
      let nt;
      function at() {
        if (!nt) {
          let e,
            t = window.localStorage.getItem("gameRecordingPlayer") || "{}";
          try {
            e = JSON.parse(t);
          } catch (t) {
            e = {};
          }
          nt = { muted: e.muted || !1, volume: e.volume || 1 };
        }
        return nt;
      }
      function st(e) {
        return at()[e];
      }
      function lt(e, t) {
        let r = at();
        r[e] = t;
        let i = JSON.stringify(r);
        window.localStorage.setItem("gameRecordingPlayer", i);
      }
      (0, W.Cg)([Oe.sH], it.prototype, "m_bInitailized", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bPaused", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bAtEnd", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_strMediaTypeError", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_ePlayerError", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bUserInputNeeded", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bMuted", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bSeekReadyToPlay", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bVideoElementPlaying", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_nPlaybackSpeed", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bIsWaiting", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_bLoadedMetadata", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_nPlaybackTime", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_nVideoStartTime", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_nVideoDuration", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_nVolume", void 0),
        (0, W.Cg)([Oe.sH], it.prototype, "m_eSeekType", void 0),
        (0, W.Cg)([Oe.XI], it.prototype, "Start", null),
        (0, W.Cg)([Oe.XI], it.prototype, "Stop", null),
        (0, W.Cg)([j.oI], it.prototype, "OnCanPlay", null),
        (0, W.Cg)([j.oI], it.prototype, "OnUserPauseChange", null),
        (0, W.Cg)([j.oI], it.prototype, "OnVideoPlaying", null),
        (0, W.Cg)([j.oI], it.prototype, "OnVideoPause", null),
        (0, W.Cg)([j.oI], it.prototype, "OnVideoTimeUpdate", null),
        (0, W.Cg)([j.oI], it.prototype, "OnVideoEnd", null),
        (0, W.Cg)([j.oI], it.prototype, "OnSeeking", null),
        (0, W.Cg)([j.oI], it.prototype, "OnLoadedMetadata", null),
        (0, W.Cg)([j.oI], it.prototype, "OnDownloadFailed", null),
        (0, W.Cg)([j.oI], it.prototype, "OnPlaybackError", null),
        (0, W.Cg)([j.oI], it.prototype, "OnUserInputNeeded", null),
        (0, W.Cg)([j.oI], it.prototype, "OnVolumeChange", null),
        (0, W.Cg)([j.oI], it.prototype, "OnVideoWaiting", null),
        (0, W.Cg)([j.oI], it.prototype, "UserInputReceived", null);
      var ot,
        mt,
        ct,
        dt = r(95679),
        ut = r(35009),
        gt = r(52694),
        pt = r(76217);
      function _t() {
        const e = ht(Rt().GetGameID());
        return e === ot.NotRecording || e === ot.NotRunning
          ? null
          : a.createElement(ft, null);
      }
      function ft(e) {
        const t = Rt(),
          r = (0, Ue.q3)(() => t.GetIsLiveEdge() && !t.GetHidePlayer()),
          i = a.useCallback(() => {
            t.SetHidePlayer(!1), t.GetGameRecordingVideo().Play();
            const e = t.GetLiveEdgeMS();
            t.SetPlaytimeFromGlobalMS(e), t.FocusGlobalMS(e);
          }, [t]);
        return a.createElement(
          ie.he,
          {
            className: ut.GoLiveButtonCtn,
            toolTipContent: (0, p.we)(
              r ? "#Playback_AtLatest" : "#Playback_JumpToLatest",
            ),
            direction: "bottom",
          },
          a.createElement(
            pt.Z,
            {
              onClick: i,
              className: (0, Te.A)(ut.GoLiveButton, r && ut.IsLive),
            },
            a.createElement(gt.xA, { className: (0, Te.A)(ut.JumpToEndIcon) }),
          ),
        );
      }
      function ht(e) {
        const { app: t } = He(e);
        if (!t) return ot.NotRecording;
        switch (t.recording_type) {
          default:
          case dt.vb.k_EGameRecordingType_Unknown:
          case dt.vb.k_EGameRecordingType_NotRecording:
            return ot.NotRecording;
          case dt.vb.k_EGameRecordingType_ManualRecording:
            return ot.ManualRecording;
          case dt.vb.k_EGameRecordingType_BackgroundRecording:
            return ot.BackgroundRecording;
        }
      }
      !(function (e) {
        (e.NotRunning = "NotRunning"),
          (e.NotRecording = "NotRecording"),
          (e.ManualRecording = "ManualRecording"),
          (e.BackgroundRecording = "BackgroundRecording"),
          (e.ForeverRecording = "ForeverRecording");
      })(ot || (ot = {})),
        (function (e) {
          (e.Overlay = "Overlay"),
            (e.Clips = "Clips"),
            (e.Background = "Background"),
            (e.CommunityClip = "Community"),
            (e.ChatClip = "Chat"),
            (e.Partner = "Partner");
        })(mt || (mt = {})),
        (function (e) {
          (e.Never = "Never"), (e.Always = "Always"), (e.Manual = "Manual");
        })(ct || (ct = {}));
      const St = 3 * $e.kh,
        bt = 5 * $e.kh,
        Mt = $e.kh + 2e3,
        yt = 1e3;
      class Tt {
        m_gameRecordingVideo = null;
        m_timelineLoader = null;
        m_fnUnregisterLoader = null;
        m_rgListeners = [];
        m_videoRef;
        m_bHidePlayer = !1;
        m_fnGetManifest;
        m_strRecordingID = null;
        m_nPendingSeekSec = -1;
        m_playbackDefinition = null;
        m_pendingStop = null;
        m_durationMS = (0, et.Sb)(null);
        m_lastRecordingGlobalMS = (0, et.Sb)(null);
        m_bWasLiveEdge = !1;
        m_nGlobalTimelinePlaybackMS = null;
        m_nGlobalTimelinePlaybackSec = null;
        m_fnUnregisterAutorun = [];
        m_eGameRecordingMode;
        m_rgSeekPerf = [];
        m_eRecordingState = ot.NotRecording;
        m_eRecordingSetting = ct.Never;
        m_bGamepadMode = !1;
        m_bControlsVisible = !0;
        m_fnRenderGlyph = void 0;
        m_previousHighlightEntry = null;
        m_nextHighlightEntry = null;
        m_displayHighlightEntry = null;
        m_nRelativeTimeForDisplay = void 0;
        m_rgClipOffsets = [];
        m_phasePreview = void 0;
        constructor(e, t, r, i, n, a, s, l) {
          (0, Oe.Gn)(this),
            (this.m_fnGetManifest = t),
            (this.m_gameRecordingVideo = new it(!0)),
            (this.m_eGameRecordingMode = r),
            (this.m_bGamepadMode = n),
            (this.m_playbackDefinition = s),
            null != i && (this.m_bControlsVisible = i),
            "Overlay" === r && (this.m_bHidePlayer = !0),
            l && this.SetClipOffsets(l),
            (this.m_fnRenderGlyph = a),
            this.m_fnUnregisterAutorun.push(
              (0, Oe.mJ)(
                () => ({
                  bIsAtEnd: this.m_gameRecordingVideo.IsAtEnd(),
                  bIsPaused: this.m_gameRecordingVideo.IsPaused(),
                }),
                (e) => {
                  e.bIsAtEnd &&
                    !e.bIsPaused &&
                    this.PlayNextTimelineRecording();
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, Oe.mJ)(
                () => this.m_gameRecordingVideo.GetPlaybackTime(),
                (e) => {
                  if (
                    this.m_pendingStop &&
                    this.m_pendingStop.m_strRecordingID ==
                      this.m_strRecordingID &&
                    this.m_pendingStop.m_nOffsetMS <= 1e3 * e
                  ) {
                    if (this.m_playbackDefinition)
                      return void this.StartPlaybackForRange();
                    this.m_gameRecordingVideo.Pause(),
                      (this.m_pendingStop = null);
                  }
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, Oe.mJ)(
                () => ({
                  playback: this.m_gameRecordingVideo.GetPlaybackTime(),
                  bVideoPlaying:
                    this.m_gameRecordingVideo.BVideoElementPlaying(),
                }),
                (e) => {
                  if (e.bVideoPlaying) {
                    const t =
                      this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
                        this.m_strRecordingID,
                        1e3 * e.playback,
                        0,
                      );
                    if (t)
                      this.UpdateGlobalPlayTime(t.nGlobalOffsetMS),
                        t.nGlobalOffsetMS > this.GetLiveEdgeMS().valMS &&
                          "Overlay" === this.m_eGameRecordingMode &&
                          this.m_gameRecordingVideo.GetPlaybackSpeed() > 1 &&
                          (console.log(
                            " hitting live edge, slow down the playback ",
                          ),
                          this.m_gameRecordingVideo.SetPlaybackSpeed(1));
                    else {
                      const e = this.GetLiveEdgeMS();
                      isNaN(e.valMS) ||
                        (this.SetPlaytimeFromGlobalMS(e),
                        this.FocusGlobalMS(e));
                    }
                  }
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, Oe.mJ)(
                () => ({
                  globalPlaybackMS: this.m_nGlobalTimelinePlaybackMS,
                  bVideoPaused: this.m_gameRecordingVideo.IsPaused(),
                  bHidePlayer: this.m_bHidePlayer,
                }),
                (e) => {
                  if (!this.m_timelineLoader?.BInitialized()) return;
                  if (e.bHidePlayer) return void this.SetEntriesForLiveEdge();
                  (!this.m_previousHighlightEntry ||
                    !this.m_nextHighlightEntry ||
                    (this.m_nextHighlightEntry?.globalMS &&
                      e.globalPlaybackMS >=
                        this.m_nextHighlightEntry.globalMS.valMS) ||
                    (this.m_previousHighlightEntry?.globalMS &&
                      e.globalPlaybackMS <=
                        this.m_previousHighlightEntry.globalMS.valMS) ||
                    (e.bVideoPaused &&
                      this.m_previousHighlightEntry?.globalMS &&
                      e.globalPlaybackMS >=
                        this.m_previousHighlightEntry.globalMS.valMS + yt)) &&
                    (this.CalculatePreviousHighlightEntry(
                      e.globalPlaybackMS,
                      e.bVideoPaused,
                    ),
                    this.CalculateNextHighlightEntry(
                      e.globalPlaybackMS,
                      e.bVideoPaused,
                    ));
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, Oe.mJ)(
                () => this.m_gameRecordingVideo.BSeekReadyToPlay(),
                (e) => {
                  if (e) {
                    const e = `seeking_${this.GetManifestFromRecordingID(this.m_strRecordingID)}_${this.m_gameRecordingVideo.GetPlaybackTime().toFixed(3)}`;
                    try {
                      const t = `measure_${this.m_strRecordingID}_${this.m_gameRecordingVideo.GetPlaybackTime().toFixed(3)}`,
                        r = performance.measure(t, e);
                      (0, ze.q_)(
                        `CGameRecordingVideo:: perf measure ${e} duration ${r.duration}`,
                      ),
                        r && this.m_rgSeekPerf.push(r.duration);
                    } catch (t) {
                      (0, ze.q_)(
                        `CGameRecordingVideo:: cant measure ${e}, error: ${t}`,
                      );
                    }
                  }
                },
                { fireImmediately: !0 },
              ),
            ),
            this.SetLoader(e);
        }
        AddEventListener(e) {
          return this.m_rgListeners.push(e), () => tt.x9(this.m_rgListeners, e);
        }
        FireEvent(e, ...t) {
          for (let r of this.m_rgListeners) {
            let i = r[e];
            i instanceof Function && i.apply(r, t);
          }
        }
        dispose() {
          this.m_fnUnregisterAutorun.forEach((e) => e()),
            this.m_fnUnregisterLoader &&
              (this.m_fnUnregisterLoader(), (this.m_fnUnregisterLoader = null));
        }
        SetVideoElement(e) {
          if (e) {
            if (this.m_videoRef === e) return;
            if (((this.m_videoRef = e), this.m_strRecordingID)) {
              const e = this.m_nPendingSeekSec > 0 ? this.m_nPendingSeekSec : 0;
              (this.m_nPendingSeekSec = -1),
                this.ChangePlaybackRecording(this.m_strRecordingID, e);
            } else this.TryPlayInitialTimelineVideo();
          } else this.m_gameRecordingVideo.Stop(), (this.m_videoRef = null);
        }
        OnInvalidateRecording(e, t) {
          const r = this.m_fnGetManifest(t);
          this.m_gameRecordingVideo.GetMPDURL() == r &&
            ((0, ze.q_)(`Recording invalidated for ${t}. Reloading MPD`),
            this.m_gameRecordingVideo.UpdateMPD());
        }
        OnLoaderInitialized() {
          (this.m_durationMS = this.m_timelineLoader.GetGlobalTimelineEndMS()),
            (this.m_lastRecordingGlobalMS =
              this.m_timelineLoader.GetEndOfRecordingsMS()),
            (this.m_bWasLiveEdge = !0),
            this.TryPlayInitialTimelineVideo();
          const e =
            ((t = this.m_timelineLoader.GetGameID()),
            (null != je() && t && je().GetClipSummariesForGame(t)) || []);
          var t;
          this.SetClipOffsets(e);
        }
        OnInvalidate(e) {
          if (
            ((this.m_durationMS =
              this.m_timelineLoader.GetGlobalTimelineEndMS()),
            (this.m_lastRecordingGlobalMS =
              this.m_timelineLoader.GetEndOfRecordingsMS()),
            this.m_bHidePlayer && this.m_timelineLoader.IsActiveTimeline(e))
          )
            this.SetEntriesForLiveEdge();
          else {
            if (this.m_previousHighlightEntry && this.m_nextHighlightEntry) {
              const t = this.m_timelineLoader.GetTimelineMetadataIndex(e),
                r = this.m_timelineLoader.GetTimelineMetadataIndex(
                  this.m_previousHighlightEntry.timelineID,
                ),
                i = this.m_timelineLoader.GetTimelineMetadataIndex(
                  this.m_nextHighlightEntry.timelineID,
                );
              if (t < r || t > i) return;
            }
            this.CalculatePreviousHighlightEntry(
              this.m_nGlobalTimelinePlaybackMS,
              this.GetGameRecordingVideo().IsPaused(),
            ),
              this.CalculateNextHighlightEntry(
                this.m_nGlobalTimelinePlaybackMS,
                this.GetGameRecordingVideo().IsPaused(),
              );
          }
        }
        OnTimelineLoaded(e) {
          this.m_previousHighlightEntry &&
            this.m_previousHighlightEntry.timelineID === e &&
            this.CalculatePreviousHighlightEntry(
              this.m_nGlobalTimelinePlaybackMS,
              this.GetGameRecordingVideo().IsPaused(),
            ),
            this.m_nextHighlightEntry &&
              this.m_nextHighlightEntry.timelineID === e &&
              this.CalculateNextHighlightEntry(
                this.m_nGlobalTimelinePlaybackMS,
                this.GetGameRecordingVideo().IsPaused(),
              );
        }
        SetEntriesForLiveEdge() {
          const e = this.GetLiveEdgeMS();
          this.CalculatePreviousHighlightEntry(e.valMS, !0),
            (this.m_nextHighlightEntry = null);
        }
        CalculatePreviousHighlightEntry(e, t) {
          const r = t ? 1 : yt * this.m_gameRecordingVideo.GetPlaybackSpeed(),
            i = this.m_timelineLoader.GetClosestPreviousEntryInGlobalTimeline(
              e - r,
            );
          "loaded" !== i.timelineState || i.entry
            ? (this.m_previousHighlightEntry = i)
            : (this.m_previousHighlightEntry =
                this.m_timelineLoader.GetClosestPreviousEntryInGlobalTimeline(
                  e,
                ));
        }
        CalculateNextHighlightEntry(e, t) {
          const r =
            this.m_timelineLoader.GetClosestNextEntryInGlobalTimeline(e);
          if ("loaded" !== r.timelineState || r.entry)
            this.m_nextHighlightEntry = r;
          else {
            const r = t ? 1 : yt * this.m_gameRecordingVideo.GetPlaybackSpeed();
            this.m_nextHighlightEntry =
              this.m_timelineLoader.GetClosestNextEntryInGlobalTimeline(e - r);
          }
        }
        GetPreviousHighlightEntry() {
          return this.m_previousHighlightEntry;
        }
        GetNextHighlightEntry() {
          return this.m_nextHighlightEntry;
        }
        GetDisplayHighlightEntry() {
          return this.m_displayHighlightEntry;
        }
        SetDisplayHighlightEntry(e, t) {
          this.m_displayHighlightEntry = { entry: e, duration: t };
        }
        GetPhasePreview() {
          return this.m_phasePreview;
        }
        SetPhasePreview(e) {
          this.m_phasePreview = e;
        }
        GetRelativeTimeForDisplay() {
          return this.m_nRelativeTimeForDisplay;
        }
        ClearRelativeTimeDisplay() {
          this.m_nRelativeTimeForDisplay = void 0;
        }
        GetClipOffsets() {
          return this.m_rgClipOffsets;
        }
        SetClipOffsets(e) {
          if (!this.m_timelineLoader?.BInitialized()) return;
          let t = [];
          e &&
            e.length &&
            e.forEach((e) => {
              const r = this.m_timelineLoader.GetGlobalOffsetDataForTimeline(
                e.start_timeline_id,
                0,
              );
              if (!r) return;
              const i = r.nGlobalOffsetMS + parseInt(e.start_offset_ms);
              t.push({
                strClipID: e.clip_id,
                nGlobalOffsetMS: i,
                nDurationMS: parseInt(e.duration_ms),
              });
            }),
            (this.m_rgClipOffsets = t);
        }
        GetTotalMS() {
          return this.m_durationMS;
        }
        GetIsActiveTimeline(e) {
          return this.m_timelineLoader.IsActiveTimeline(e);
        }
        BIsVideoElementPaused() {
          return this.m_gameRecordingVideo.IsPaused();
        }
        BInitialized() {
          return this.m_timelineLoader.BInitialized();
        }
        GetHidePlayer() {
          return this.m_bHidePlayer;
        }
        SetHidePlayer(e) {
          e && (this.m_strRecordingID = null), (this.m_bHidePlayer = e);
        }
        BPlayerInitialized() {
          return this.m_gameRecordingVideo.IsInitialized();
        }
        GetGameRecordingVideo() {
          return this.m_gameRecordingVideo;
        }
        GetGameID() {
          return this.m_timelineLoader.GetGameID();
        }
        GetClipID() {
          return this.m_timelineLoader.GetClipID();
        }
        GetRecordingState() {
          return this.m_eRecordingState;
        }
        SetRecordingState(e) {
          this.m_eRecordingState = e;
        }
        GetLoader() {
          return this.m_timelineLoader;
        }
        SetLoader(e) {
          this.m_timelineLoader != e &&
            (this.m_fnUnregisterLoader && this.m_fnUnregisterLoader(),
            (this.m_timelineLoader = e),
            (this.m_fnUnregisterLoader =
              this.m_timelineLoader.AddEventListener(this)),
            e.BInitialized() && this.OnLoaderInitialized());
        }
        SetGetManifest(e) {
          this.m_fnGetManifest = e;
        }
        GetRecordingID() {
          return this.m_strRecordingID;
        }
        GetRecordingSetting() {
          return this.m_eRecordingSetting;
        }
        SetRecordingSetting(e) {
          this.m_eRecordingSetting = e;
        }
        GetRecordingMode() {
          return this.m_eGameRecordingMode;
        }
        ShouldModeShowClipControls() {
          switch (this.m_eGameRecordingMode) {
            case mt.Overlay:
            case mt.Clips:
            case mt.Background:
              return !0;
            default:
              return !1;
          }
        }
        CanModeAddMarker() {
          switch (this.m_eGameRecordingMode) {
            case mt.Overlay:
            case mt.Clips:
            case mt.Background:
              return !0;
            default:
              return !1;
          }
        }
        GetPlaybackStats() {
          if (!this.m_rgSeekPerf.length) return null;
          const e = this.m_rgSeekPerf.length,
            t = this.m_rgSeekPerf.reduce((e, t) => e + t) / e,
            r = Math.sqrt(
              this.m_rgSeekPerf
                .map((e) => Math.pow(e - t, 2))
                .reduce((e, t) => e + t) / e,
            ),
            i = Math.max(...this.m_rgSeekPerf),
            n = Math.min(...this.m_rgSeekPerf);
          return {
            nMean: t,
            nStdDev: r,
            nMax: i,
            nMin: n,
            nLength: e,
            nLastVal: this.m_rgSeekPerf[e - 1],
          };
        }
        async StartPlaybackForRange() {
          let e,
            t = this.m_timelineLoader.GetGlobalOffsetDataForTimeline(
              this.m_playbackDefinition.m_strTimelineID,
              0,
            ),
            r = t?.nGlobalOffsetMS || 0;
          if (
            ((r += this.m_playbackDefinition.m_nTimelineStartMS),
            (e = this.m_playbackDefinition.m_strEntryID
              ? await this.m_timelineLoader.FindRecordingAndOffsetForEntry(
                  this.m_playbackDefinition.m_strEntryID,
                )
              : this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
                  r,
                )),
            e)
          ) {
            if (this.m_playbackDefinition.m_nDurationMS) {
              let e = r + this.m_playbackDefinition.m_nDurationMS,
                t =
                  this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
                    e,
                  );
              this.m_pendingStop = {
                m_strRecordingID: t.strRecordingID,
                m_nOffsetMS: t.nRecordingOffsetMS,
              };
            }
            this.UpdateGlobalPlayTime(r),
              this.ChangePlaybackRecording(
                e.strRecordingID,
                e.nRecordingOffsetMS / 1e3,
              );
          }
        }
        TryPlayInitialTimelineVideo() {
          if (this.m_timelineLoader.BInitialized() && !this.m_bHidePlayer)
            if (this.m_playbackDefinition) this.StartPlaybackForRange();
            else if (this.m_eGameRecordingMode === mt.Overlay) {
              const e = this.GetLiveEdgeMS(),
                t =
                  this.m_timelineLoader.GetFirstRecordingOfLastTimelineSession(),
                r = this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
                  t,
                  0,
                  0,
                );
              r && e.valMS < r.nGlobalOffsetMS
                ? (this.UpdateGlobalPlayTime(r.nGlobalOffsetMS),
                  this.ChangePlaybackRecording(t, 0))
                : isNaN(e.valMS) || this.SetPlaytimeFromGlobalMS(e, !1, !0);
            } else if (this.m_eGameRecordingMode === mt.Background) {
              const e =
                this.m_timelineLoader.GetFirstRecordingOfLastTimelineSession();
              this.SetPlaytimeFromRecordingOffset(e, 0);
            } else {
              const e = this.m_timelineLoader.GetFirstRecording();
              this.SetPlaytimeFromRecordingOffset(e, 0);
            }
        }
        GetTotalSeconds() {
          return Math.floor(
            this.m_timelineLoader.GetGlobalTimelineEndMS().valMS / 1e3,
          );
        }
        GetCurrentPlaybackGlobalMS(e = 0) {
          const t =
            Math.floor(1e3 * this.m_gameRecordingVideo.GetPlaybackTime()) + e;
          return this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
            this.m_strRecordingID,
            t,
            0,
          );
        }
        GetIsLiveEdge() {
          const e = this.GetGlobalMSPlaytime().valMS || 0;
          return "Overlay" === this.m_eGameRecordingMode
            ? !!this.m_lastRecordingGlobalMS && this.m_bWasLiveEdge
            : this.GetTotalMS().valMS - e < 1;
        }
        GetLiveEdgeBufferWindowStartMS() {
          if (
            "Overlay" === this.m_eGameRecordingMode &&
            this.m_lastRecordingGlobalMS
          ) {
            const e = Math.max(
              0,
              this.m_lastRecordingGlobalMS.valMS - St - 1e3,
            );
            return (0, et.Sb)(e);
          }
          return this.GetTotalMS();
        }
        GetLiveEdgeMS() {
          if (
            "Overlay" === this.m_eGameRecordingMode &&
            this.m_lastRecordingGlobalMS
          ) {
            const e = Math.max(0, this.m_lastRecordingGlobalMS.valMS - Mt);
            return (0, et.Sb)(e);
          }
          return (0, et.Sb)(Math.max(0, this.GetTotalMS().valMS - 1));
        }
        GetTimelineAndOffsetRelativeToCurrentPlayback(e = 0) {
          const t = this.GetCurrentPlaybackGlobalMS(e);
          return (
            t ||
            ((0, ze.ZI)(
              `failed to find offset for ${this.m_strRecordingID} at ${Math.floor(1e3 * this.m_gameRecordingVideo.GetPlaybackTime())} MS`,
            ),
            null)
          );
        }
        SeekDeltaMS(e) {
          const t = this.GetGlobalMSPlaytime();
          if (!this.m_strRecordingID) {
            const r =
              e > 0
                ? this.GetClosestNextRecordingForGlobalMS(t)
                : this.GetClosestPreviousRecordingForGlobalMS(t);
            if (r) {
              const t = e > 0 ? e : Math.max(parseInt(r.duration_ms) + e, 0);
              return void this.SetPlaytimeFromRecordingOffset(
                r.recording_id,
                t,
                e < 0,
              );
            }
          }
          const r =
              "Overlay" === this.m_eGameRecordingMode
                ? this.GetLiveEdgeMS().valMS
                : this.GetTotalMS().valMS,
            i = Ye.OQ(t.valMS + e, 0, r - 1e3);
          this.SetPlaytimeFromGlobalMS((0, et.Sb)(i));
        }
        ConvertGlobaOffsetToRecordingAndRelativeOffset(e) {
          return this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
            e,
          );
        }
        PlayNextTimelineRecording(e) {
          if (this.m_playbackDefinition)
            return void this.StartPlaybackForRange();
          let t;
          if (this.m_strRecordingID)
            t = this.m_timelineLoader.GetNextRecording(this.m_strRecordingID);
          else {
            const e =
              this.m_timelineLoader.GetClosestNextRecordingInGlobalTimeline(
                (0, et.Sb)(this.m_nGlobalTimelinePlaybackMS),
              );
            t = e?.recording_id;
          }
          t
            ? this.SetPlaytimeFromRecordingOffset(t, 0)
            : (this.m_gameRecordingVideo.Pause(),
              e && this.TryPlayInitialTimelineVideo());
        }
        GetClipsAtGlobalMS(e) {
          return (
            this.m_rgClipOffsets.filter(
              (t) =>
                t.nGlobalOffsetMS <= e.valMS &&
                t.nGlobalOffsetMS + t.nDurationMS >= e.valMS,
            ) || []
          );
        }
        GetClosestPreviousRecordingForGlobalMS(e) {
          return this.m_timelineLoader.GetClosestPreviousRecordingInGlobalTimeline(
            e,
          );
        }
        GetClosestNextRecordingForGlobalMS(e) {
          return this.m_timelineLoader.GetClosestNextRecordingInGlobalTimeline(
            e,
          );
        }
        SetPlaytimeFromRecordingOffset(e, t, r, i) {
          let n = t;
          r &&
            (n = this.m_timelineLoader.ConvertRecordingTimeMStoPreTrimTimeMS(
              e,
              t,
            ));
          const a = this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
            e,
            n,
            0,
          );
          a &&
            (this.UpdateGlobalPlayTime(a.nGlobalOffsetMS),
            this.ChangePlaybackRecording(e, n / 1e3, i));
        }
        GetManifestFromRecordingID(e) {
          return this.m_fnGetManifest(e);
        }
        ChangePlaybackRecording(e, t = 0, r) {
          this.m_bHidePlayer = !1;
          const i = this.m_gameRecordingVideo.IsPaused();
          if (
            this.m_strRecordingID === e &&
            this.m_gameRecordingVideo.IsInitialized()
          )
            return void this.m_gameRecordingVideo.Seek(t);
          if (
            (this.m_gameRecordingVideo.Stop(), (this.m_strRecordingID = e), !e)
          )
            return;
          if (!this.m_videoRef) return void (this.m_nPendingSeekSec = t);
          const n = this.GetManifestFromRecordingID(e),
            a = this.m_timelineLoader.BRecordingHasZeroOffset(e)
              ? rt.lU.Absolute
              : rt.lU.FromAvailableStart;
          this.m_gameRecordingVideo.Start(this.m_videoRef, n, t, a),
            (r || i) && this.m_gameRecordingVideo.Pause();
        }
        StopPlayback() {
          this.m_gameRecordingVideo.Stop();
        }
        TogglePlayPause() {
          this.m_gameRecordingVideo.IsPaused() ||
          !this.m_gameRecordingVideo.IsInitialized()
            ? (this.m_nGlobalTimelinePlaybackMS >
                this.m_lastRecordingGlobalMS?.valMS &&
                this.TryPlayInitialTimelineVideo(),
              this.m_gameRecordingVideo.GetTimelineDuration() -
                this.m_gameRecordingVideo.GetPlaybackTime() <
              0.05
                ? this.PlayNextTimelineRecording(!0)
                : this.m_gameRecordingVideo.Play())
            : this.m_gameRecordingVideo.Pause();
        }
        GetGlobalMSPlaytime() {
          return (0, et.Sb)(this.m_nGlobalTimelinePlaybackMS);
        }
        GetGlobalPlaytimeSec() {
          return this.m_nGlobalTimelinePlaybackSec;
        }
        UpdateGlobalPlayTime(e) {
          if (
            ((this.m_nGlobalTimelinePlaybackMS = e),
            (this.m_nGlobalTimelinePlaybackSec = Math.floor(e / 1e3)),
            this.m_lastRecordingGlobalMS &&
              null !== this.m_lastRecordingGlobalMS.valMS)
          ) {
            const e = this.m_bWasLiveEdge ? bt : St;
            this.m_bWasLiveEdge =
              this.m_lastRecordingGlobalMS.valMS -
                (this.GetGlobalMSPlaytime()?.valMS || 0) <
              e;
          }
        }
        HandleSeekToPreviousRecording(e, t, r) {
          const i = this.GetClosestPreviousRecordingForGlobalMS(e);
          if (i) {
            const e = parseInt(i.duration_ms),
              n = Math.max(e - 5e3, 0.75 * e);
            r || (this.m_nRelativeTimeForDisplay = n / 1e3),
              this.UpdateGlobalPlayTime(
                this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
                  i.recording_id,
                  n,
                  0,
                ).nGlobalOffsetMS,
              ),
              this.ChangePlaybackRecording(i?.recording_id, n / 1e3, t);
          } else
            r || (this.m_nRelativeTimeForDisplay = 0),
              this.UpdateGlobalPlayTime(0),
              this.ChangePlaybackRecording(this.m_strRecordingID, 0, t);
        }
        HandleSeekToNextRecording(e, t, r) {
          const i = this.GetClosestNextRecordingForGlobalMS(e);
          i
            ? (r || (this.m_nRelativeTimeForDisplay = 0),
              this.UpdateGlobalPlayTime(
                this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
                  i.recording_id,
                  0,
                  0,
                ).nGlobalOffsetMS,
              ),
              this.ChangePlaybackRecording(i?.recording_id, 0, t))
            : (r || (this.m_nRelativeTimeForDisplay = this.GetTotalMS().valMS),
              this.ChangePlaybackRecording(
                this.m_strRecordingID,
                this.GetTotalMS().valMS / 1e3,
                t,
              ));
        }
        SetPlaytimeFromGlobalMS(e, t, r, i) {
          this.m_pendingStop = null;
          let n =
            this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
              e.valMS,
            );
          if (n)
            r || (this.m_nRelativeTimeForDisplay = e.valMS),
              this.UpdateGlobalPlayTime(e.valMS),
              this.ChangePlaybackRecording(
                n?.strRecordingID,
                n?.nRecordingOffsetMS / 1e3,
                t,
              );
          else if (i)
            this.ChangePlaybackRecording(
              n?.strRecordingID,
              n?.nRecordingOffsetMS / 1e3,
              t,
            );
          else {
            e.valMS > this.m_nGlobalTimelinePlaybackMS
              ? this.HandleSeekToNextRecording(e, t, r)
              : this.HandleSeekToPreviousRecording(e, t, r);
          }
        }
        ConvertGlobalOffsetToTimelineRelativeOffset(e) {
          return this.m_timelineLoader.GetTimelineOffsetFromGlobal(e, 0);
        }
        MakeRelativeToTimelineEndIfActive(e, t) {
          return this.m_timelineLoader.MakeRelativeToTimelineEndIfActive(e, t);
        }
        GetTimelineDuration(e) {
          if (!this.m_timelineLoader.BInitialized()) return null;
          const t = this.m_timelineLoader.GetTimelineMetadata(e);
          return t ? parseInt(t.metadata.duration_ms) : null;
        }
        GetTimelineFirstRecordingOffset(e) {
          if (!this.m_timelineLoader.BInitialized()) return null;
          const t = this.m_timelineLoader.GetTimelineMetadata(e);
          if (!t) return null;
          const r = t.metadata.recordings;
          return r.length ? parseInt(r[0].start_offset_ms) : null;
        }
        async AddUserMarkerAtGlobalMS(e, t, r) {
          const i = this.m_timelineLoader.GetTimelineOffsetFromGlobal(
            e.valMS,
            0,
          );
          if (i) {
            const e = this.m_timelineLoader.GetGameID(),
              { fnCreateUserTimelineMarkers: n } = Ve(),
              a = this.m_timelineLoader.GetTimelineStartBeforeGlobalZeroMS(
                i.strTimelineID,
              );
            xe.ReportTrackedAction(t);
            const s = "steam_marker",
              l = await n(e, this.GetClipID(), {
                timeline_id: i.strTimelineID,
                entry_id: "",
                time: "" + Math.floor(i.nTimelineOffsetMS.valMS + a),
                type: Je.Bw.k_ETimelineEntryType_UserMarker,
                marker_icon: s,
                marker_priority: 0,
              });
            l.eResult == _.d.k_EResultOK &&
              (this.m_timelineLoader.AddUserMarker(
                i.strTimelineID,
                Math.floor(i.nTimelineOffsetMS.valMS),
                s,
                l.entry_id,
              ),
              r && r(l.entry_id, i.strTimelineID));
          }
        }
        async RemoveUserMarker(e, t) {
          const { fnRemoveUserTimelineMarker: r } = Ve(),
            i = this.m_timelineLoader.GetGameID();
          return (await r(i, this.GetClipID(), e, t)) == _.d.k_EResultOK
            ? (this.m_timelineLoader.RemoveUserMarker(e, t), !0)
            : ((0, ze.tG)(
                `Failed to delete user marker for timeline ${e} entry ${t}`,
              ),
              !1);
        }
        async UpdateUserMarker(e, t, r, i) {
          const { fnUpdateUserTimelineMarkers: n } = Ve(),
            a = this.m_timelineLoader.GetGameID(),
            s = {
              timeline_id: e,
              entry_id: t.id,
              time: t.time,
              type: Je.Bw.k_ETimelineEntryType_UserMarker,
              marker_icon: t.icon,
              marker_priority: t.priority,
              range_title: r,
              marker_description: i,
            };
          if ((await n(a, this.GetClipID(), s)) == _.d.k_EResultOK) {
            const n = {
              strIcon: t.icon,
              name: r,
              description: i,
              nTimelineOffsetMS: parseInt(t.time),
            };
            return this.m_timelineLoader.UpdateUserMarker(e, t.id, n), !0;
          }
          return !1;
        }
        FocusGlobalMS(e) {
          this.FireEvent("OnFocusGlobalMS", e);
        }
        SetPlaybackStop(e) {
          const t = this.ConvertGlobaOffsetToRecordingAndRelativeOffset(
            e.valMS,
          );
          t &&
            (this.m_pendingStop = {
              m_strRecordingID: t.strRecordingID,
              m_nOffsetMS: t.nRecordingOffsetMS,
            });
        }
        ClearPlaybackStop() {
          this.m_pendingStop = null;
        }
        GenerateClipNameFromTimeline(e, t, r, i) {
          return this.m_timelineLoader.GenerateClipNameFromTimeline(e, t, r, i);
        }
        GetRenderGlyph() {
          return this.m_bGamepadMode ? this.m_fnRenderGlyph : void 0;
        }
        SetRenderGlyph(e) {
          this.m_fnRenderGlyph = e;
        }
        GetGamepadMode() {
          return this.m_bGamepadMode;
        }
        SetGamepadMode(e) {
          this.m_bGamepadMode = e;
        }
        GetControlsVisible() {
          return this.m_bControlsVisible;
        }
        SetControlsVisible(e) {
          null != e && (this.m_bControlsVisible = e);
        }
      }
      (0, W.Cg)([Oe.sH], Tt.prototype, "m_bHidePlayer", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_strRecordingID", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_durationMS", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_lastRecordingGlobalMS", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_nGlobalTimelinePlaybackMS", void 0),
        (0, W.Cg)(
          [Oe.sH],
          Tt.prototype,
          "m_nGlobalTimelinePlaybackSec",
          void 0,
        ),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_rgSeekPerf", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_eRecordingState", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_eRecordingSetting", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_bGamepadMode", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_bControlsVisible", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_fnRenderGlyph", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_previousHighlightEntry", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_nextHighlightEntry", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_displayHighlightEntry", void 0),
        (0, W.Cg)([Oe.sH], Tt.prototype, "m_nRelativeTimeForDisplay", void 0),
        (0, W.Cg)([Oe.sH.ref], Tt.prototype, "m_rgClipOffsets", void 0),
        (0, W.Cg)([Oe.sH.ref], Tt.prototype, "m_phasePreview", void 0),
        (0, W.Cg)([j.oI], Tt.prototype, "SetVideoElement", null),
        (0, W.Cg)([j.oI], Tt.prototype, "OnInvalidateRecording", null),
        (0, W.Cg)([Oe.XI], Tt.prototype, "OnLoaderInitialized", null),
        (0, W.Cg)([j.oI], Tt.prototype, "OnInvalidate", null),
        (0, W.Cg)([j.oI], Tt.prototype, "OnTimelineLoaded", null),
        (0, W.Cg)([j.oI], Tt.prototype, "GetLiveEdgeMS", null),
        (0, W.Cg)([j.oI], Tt.prototype, "StopPlayback", null),
        (0, W.Cg)([j.oI], Tt.prototype, "TogglePlayPause", null),
        (0, W.Cg)([Oe.XI], Tt.prototype, "UpdateGlobalPlayTime", null);
      const Bt = a.createContext({ timelinePlaybackCoordinator: null });
      function vt(e) {
        const {
            children: t,
            mode: r,
            fnGetManifest: i,
            loader: n,
            recordingState: s,
            controlsVisible: l,
            gamepadMode: o,
            renderGlyph: m,
            recordingSetting: c,
            playbackDefinition: d,
            clipSummaries: u,
          } = e,
          [g] = a.useState(() => new Tt(n, i, r, l, o, m, d, u));
        (0, a.useEffect)(() => {
          g.SetLoader(n);
        }, [g, n]),
          (0, a.useEffect)(() => {
            g.SetRecordingState(s);
          }, [g, s]),
          (0, a.useEffect)(() => {
            g.SetRecordingSetting(c);
          }, [g, c]),
          (0, a.useEffect)(() => {
            g.SetGetManifest(i);
          }, [g, i]),
          (0, a.useEffect)(() => {
            g.SetControlsVisible(l);
          }, [g, l]),
          (0, a.useEffect)(() => {
            g.SetGamepadMode(o);
          }, [g, o]),
          (0, a.useEffect)(() => {
            g.SetRenderGlyph(m);
          }, [g, m]),
          (0, a.useEffect)(() => {
            g.SetClipOffsets(u);
          }, [g, u]),
          (0, a.useEffect)(() => () => g.dispose(), [g]);
        const p = a.useMemo(() => ({ timelinePlaybackCoordinator: g }), [g]);
        return a.createElement(Bt.Provider, { value: p }, t);
      }
      function Rt() {
        return (0, a.useContext)(Bt).timelinePlaybackCoordinator;
      }
      var Gt = r(8959);
      const wt = { nBeforeMS: 0, nAfterMS: 12e3 },
        Ct = a.createContext({
          globalStartMS: void 0,
          globalEndMS: void 0,
          setRange: null,
          setStartMS: null,
          setEndMS: null,
          globalPreviewStartMS: void 0,
          globalPreviewEndMS: void 0,
          setPreviewRange: null,
          clearPreviewSelection: null,
          selectionZoomCount: 0,
          eInitMethod: void 0,
          startMetrics: void 0,
          endMetrics: void 0,
          zoomIntoSelection: null,
          zoomOutSelection: null,
        });
      function Et() {
        const e = (0, a.useContext)(Ct);
        return { nGlobalStartMS: e.globalStartMS, nGlobalEndMS: e.globalEndMS };
      }
      function It() {
        return (0, a.useContext)(Ct).globalStartMS;
      }
      function kt() {
        return (0, a.useContext)(Ct).globalEndMS;
      }
      function Pt() {
        return (0, a.useContext)(Ct).setRange;
      }
      function Ot() {
        return (0, a.useContext)(Ct).setStartMS;
      }
      function zt() {
        return (0, a.useContext)(Ct).setEndMS;
      }
      function Dt() {
        const e = (0, a.useContext)(Ct);
        return {
          selectedMarker: e.selectedMarker,
          setSelectedMarker: e.setSelectedMarker,
        };
      }
      function At() {
        const e = (0, a.useContext)(Ct);
        return !isNaN(e.globalStartMS?.valMS) && !isNaN(e.globalEndMS?.valMS);
      }
      function Wt() {
        return (0, a.useContext)(Ct).clearSelection;
      }
      function Ft() {
        const e = Pt(),
          t = Ot(),
          r = zt(),
          i = Et(),
          n = (0, a.useContext)(Ct).selectionZoomCount,
          s = qt();
        return a.useCallback(
          (a, l, o, m) => {
            if (void 0 === o && void 0 === m) return;
            let c = void 0 !== i.nGlobalStartMS || void 0 !== i.nGlobalEndMS,
              d = o || i.nGlobalStartMS,
              u = m || i.nGlobalEndMS;
            d &&
              u &&
              u.valMS <= d.valMS &&
              (void 0 !== o ? (u = void 0) : (d = void 0));
            const g = wt.nBeforeMS + wt.nAfterMS;
            void 0 === d && (d = (0, et.Sb)(u.valMS - g)),
              void 0 === u && (u = (0, et.Sb)(d.valMS + g));
            const p = d != i.nGlobalStartMS,
              _ = u != i.nGlobalEndMS;
            p && _ ? e(l, d, u) : p ? t(l, d) : _ && r(l, u),
              !c && p && _ && 0 == n && s();
          },
          [i, e, t, r, n, s],
        );
      }
      function qt() {
        return (0, a.useContext)(Ct).zoomIntoSelection;
      }
      const Nt = 3e5;
      var xt;
      !(function (e) {
        (e.Playhead = "Playhead"),
          (e.RangeLeft = "RangeLeft"),
          (e.RangeRight = "RangeRight"),
          (e.Highlight = "Highlight");
      })(xt || (xt = {}));
      class Ut {
        m_fnUnregisterFromLoader;
        m_loader;
        m_maskBounds = [-1, -1];
        m_eventTarget;
        constructor(e, t) {
          (0, Oe.Gn)(this), (this.m_loader = e), (this.m_eventTarget = t);
        }
        Init() {
          (this.m_fnUnregisterFromLoader =
            this.m_loader.AddEventListener(this)),
            this.m_loader.BInitialized() && this.OnLoaderInitialized();
        }
        GetGameID() {
          return this.m_loader.GetGameID();
        }
        BInitialized() {
          return this.m_loader.BInitialized();
        }
        IsActiveRecording(e) {
          return this.m_loader.IsActiveRecording(e);
        }
        IsActiveTimeline(e) {
          return this.m_loader.IsActiveTimeline(e);
        }
        GetStateDescriptionAtGlobalMS(e) {
          return this.m_loader.GetStateDescriptionAtGlobalMS((0, et.Sb)(e));
        }
        GetTimelineOffsetFromGlobal(e, t) {
          return this.m_loader.GetTimelineOffsetFromGlobal(e, t);
        }
        GetTimelineStartTime(e) {
          const t = this.m_loader.GetTimelineMetadata(e);
          return t?.metadata ? t.metadata.date_recorded : null;
        }
        BEmpty() {
          return !1;
        }
        GetTimelines() {
          return this.m_loader.GetTimelines();
        }
        GetGlobalTimelineEndMS() {
          return this.m_loader.GetGlobalTimelineEndMS();
        }
        GetTimelineDataOrStartLoad(e) {
          return this.m_loader.GetTimelineDataOrStartLoad(e);
        }
        GetTimelineStartBeforeGlobalZeroMS(e) {
          return this.m_loader.GetTimelineStartBeforeGlobalZeroMS(e);
        }
        MakeRelativeToTimelineEndIfActive(e, t) {
          return this.m_loader.MakeRelativeToTimelineEndIfActive(e, t);
        }
        FindRangeEventsAtGlobalMS(e) {
          return this.m_loader.FindRangeEventsAtGlobalMS(e);
        }
        Close() {
          this.m_fnUnregisterFromLoader &&
            (this.m_fnUnregisterFromLoader(),
            (this.m_fnUnregisterFromLoader = void 0)),
            (this.m_loader = null);
        }
        OnLoaderInitialized() {
          this.m_eventTarget.OnLoaderInitialized &&
            this.m_eventTarget.OnLoaderInitialized();
        }
        OnInvalidate(e) {
          this.m_eventTarget.OnInvalidate && this.m_eventTarget.OnInvalidate(e);
        }
        OnTimelineLoaded(e) {
          this.m_eventTarget.OnTimelineLoaded &&
            this.m_eventTarget.OnTimelineLoaded(e);
        }
        OnInvalidateRecording(e, t) {
          this.m_eventTarget.OnInvalidateRecording &&
            this.m_eventTarget.OnInvalidateRecording(e, t);
        }
      }
      class jt {
        m_playbackCoordinator;
        m_fnUnregisterPlaybackCoordinator;
        m_refTimelineParentCtn;
        m_timelineMask;
        m_durationMS = 0;
        m_mapTimelineClips = Oe.sH.map([], { deep: !1 });
        m_scrollLeftPX = 0;
        m_scrollWindowWidth = null;
        m_scrollWindowOffsetPX = null;
        m_bAutoScrollPaused = !1;
        m_autoScrollPauseTimeout = null;
        m_msVisible = 0;
        m_bCustomZoom = !1;
        m_bUserClipping = !1;
        m_prevLeftAndVisible = null;
        m_rgTimelineOffsets = [];
        m_mapTimelineEntries = Oe.sH.map([], { deep: !1 });
        m_bInitialized = !1;
        m_eThumbnailComponent = null;
        m_nGlobalRelativeThumbnailPositionPX = void 0;
        m_thumbnailHighlightEntry = void 0;
        m_phaseToHighlight = void 0;
        constructor(e, t, r) {
          (0, Oe.Gn)(this),
            (this.m_playbackCoordinator = t),
            (this.m_timelineMask = new Ut(e, this)),
            (this.m_fnUnregisterPlaybackCoordinator = t.AddEventListener(this)),
            this.UpdateClipSummaries(r),
            this.m_timelineMask.Init();
        }
        BInitialized() {
          return this.m_bInitialized;
        }
        OnLoaderInitialized() {
          (this.m_durationMS =
            this.m_timelineMask.GetGlobalTimelineEndMS().valMS),
            this.OnInvalidate(),
            this.InitDefaultsIfReady();
        }
        InitDefaultsIfReady() {
          !this.m_bInitialized &&
            this.m_scrollWindowWidth &&
            this.m_timelineMask.BInitialized() &&
            ((this.m_bInitialized = !0),
            (this.m_msVisible = this.ComputeDefaultMSVisible()),
            this.ScrollToCenteredGlobalMS(
              this.m_playbackCoordinator.GetGlobalMSPlaytime().valMS,
            ));
        }
        OnTimelineLoaded(e) {
          (0, ze.q_)("OnTimelineLoaded", e);
          this.FindTimelineOffsets(e)
            ? this.ComputeEntriesForTimeline(e)
            : (0, ze.tG)("Missing timeline offset metadata for", e);
        }
        OnInvalidate(e) {
          (0, ze.q_)("on invalidate", e);
          const t = this.m_timelineMask.GetGlobalTimelineEndMS().valMS,
            r = t - this.m_durationMS,
            i = this.m_durationMS <= 0;
          let n;
          this.m_durationMS = t;
          let a =
            this.IsTempZoom() || this.m_bCustomZoom || this.m_bUserClipping;
          if (r > 0 && i) this.m_msVisible = this.ComputeDefaultMSVisible();
          else if (r > 0 && !this.m_bAutoScrollPaused && !a)
            this.m_msVisible = this.ComputeDefaultMSVisible();
          else if (r < 0 && this.m_msVisible > t)
            (this.m_msVisible = this.ComputeDefaultMSVisible()),
              this.ScrollToOffset(0);
          else if (r < 0) {
            const e = this.FindClosestTimelineStartForOffsetPX(
              this.m_scrollLeftPX,
            );
            if (e) {
              const t = this.ConvertGlobalMSToGlobalPXOffset(e.globalOffsetMS),
                r = this.ConvertDeltaPXToDurationMS(this.m_scrollLeftPX - t);
              n = { strTimelineID: e.timelineID, nTimelineOffsetMS: r };
            }
          }
          const s = this.m_timelineMask.GetTimelines();
          let l = 0;
          if (this.BInitialized() && e) {
            const t = s.findIndex((t) => t.metadata.timeline_id === e);
            t >= 0 && (l = t);
          }
          if (
            ((this.m_rgTimelineOffsets = s.map((e, t) =>
              t >= l
                ? this.ComputeTimelineOffset(e)
                : this.m_rgTimelineOffsets[t],
            )),
            n)
          ) {
            const e = this.FindTimelineOffsets(n.strTimelineID);
            if (e) {
              const t = e.globalOffsetMS + n.nTimelineOffsetMS,
                r = (0, Ye.OQ)(
                  this.ConvertGlobalMSToGlobalPXOffset(t),
                  0,
                  this.GetMaxScrollLeftPX(),
                );
              this.ScrollToOffset(r);
            }
          }
          s.forEach((e, t) => {
            t >= l && this.ComputeEntriesForTimeline(e.metadata.timeline_id);
          });
        }
        OnFocusGlobalMS(e) {
          this.ScrollToCenteredGlobalMS(e.valMS);
        }
        GetGameID() {
          return this.m_timelineMask.GetGameID();
        }
        SetTimelineParentCtnRef(e) {
          this.m_refTimelineParentCtn = e;
        }
        GetTimelineParentCtnRef() {
          return this.m_refTimelineParentCtn;
        }
        SetThumbnailComponent(e) {
          (this.m_eThumbnailComponent = e),
            e || (this.m_nGlobalRelativeThumbnailPositionPX = void 0),
            e !== xt.Highlight && (this.m_thumbnailHighlightEntry = null);
        }
        GetThumbnailComponent() {
          return this.m_eThumbnailComponent;
        }
        SetThumbnailPosition(e) {
          this.m_nGlobalRelativeThumbnailPositionPX = e;
        }
        GetThumbnailPosition() {
          return this.m_nGlobalRelativeThumbnailPositionPX;
        }
        SetThumbnailEntry(e) {
          this.m_thumbnailHighlightEntry = e;
        }
        GetThumbnailEntry() {
          return this.m_eThumbnailComponent === xt.Highlight
            ? this.m_thumbnailHighlightEntry
            : null;
        }
        Close() {
          this.m_timelineMask.Close(),
            (this.m_timelineMask = null),
            this.m_fnUnregisterPlaybackCoordinator &&
              this.m_fnUnregisterPlaybackCoordinator(),
            (this.m_fnUnregisterPlaybackCoordinator = null),
            (this.m_bInitialized = !1),
            this.m_autoScrollPauseTimeout && this.ClearAutoScrollPauseTimeout();
        }
        ComputeDefaultMSVisible() {
          const e = 2 * this.GetTimelineMarginWidth(),
            t = 10 * (this.m_rgTimelineOffsets.length - 1),
            r = Math.max(1, this.m_scrollWindowWidth - t - e),
            i = Math.ceil(
              ((e + t) * this.m_durationMS) /
                (this.m_scrollWindowWidth - (e + t)),
            ),
            n = 1e3 * r;
          return Math.min(this.m_durationMS + i, n);
        }
        ZoomIn(e, t) {
          if (this.m_msVisible <= 1e3) return;
          const r = this.m_msVisible - this.m_msVisible / 1.1 ** e,
            i = r * t,
            n = this.ConvertPXOffsetToGlobalMS(this.m_scrollLeftPX),
            a = Math.max(this.m_msVisible - r, 1e3);
          (this.m_msVisible = a),
            (this.m_bCustomZoom = !0),
            this.ScrollToOffset(this.ConvertGlobalMSToGlobalPXOffset(n + i));
        }
        ZoomOut(e, t) {
          const r =
            this.m_durationMS +
            this.ConvertDeltaPXToDurationMS(
              10 * (this.m_rgTimelineOffsets.length - 1) +
                2 * this.GetTimelineMarginWidth(),
            );
          if (this.m_msVisible >= r) return;
          const i = this.m_msVisible * 1.1 ** e - this.m_msVisible,
            n = i * t,
            a = this.ConvertPXOffsetToGlobalMS(this.m_scrollLeftPX),
            s = Math.min(this.m_msVisible + i, r);
          (this.m_msVisible = s),
            (this.m_bCustomZoom = !0),
            this.ScrollToOffset(this.ConvertGlobalMSToGlobalPXOffset(a - n));
        }
        IsTempZoom() {
          return !!this.m_prevLeftAndVisible;
        }
        SetTempZoomScale(e, t) {
          let r = Math.max(e, 0),
            i = Math.min(t, this.m_durationMS);
          (this.m_prevLeftAndVisible = [this.m_scrollLeftPX, this.m_msVisible]),
            (this.m_msVisible = i - r);
          const n = this.ConvertGlobalMSToGlobalPXOffset(r);
          this.ScrollToOffset(n);
        }
        ClearTempZoomScale() {
          if (!this.m_prevLeftAndVisible) return;
          const [e, t] = this.m_prevLeftAndVisible;
          (this.m_prevLeftAndVisible = null),
            this.ScrollToOffset(e),
            (this.m_msVisible = t);
        }
        SetUserIsClipping(e) {
          this.m_bUserClipping = e;
        }
        GetTimelineGapWidth() {
          return 10;
        }
        GetTimelineMarginWidth() {
          return 12;
        }
        UpdateClipSummaries(e = []) {
          this.m_mapTimelineClips.clear(),
            e.forEach((e) => {
              const t = e.start_timeline_id;
              this.m_mapTimelineClips.has(t) ||
                this.m_mapTimelineClips.set(t, []);
              const r = {
                clipID: e.clip_id,
                msDuration: parseInt(e.duration_ms),
                msTimelineOffset: parseInt(e.start_offset_ms),
                timelineID: t,
              };
              this.m_mapTimelineClips.get(t).push(r);
            });
        }
        BEmpty() {
          return this.m_timelineMask.BEmpty();
        }
        ComputeTimelineOffset(e) {
          const t = isNaN(parseInt(e.metadata.duration_ms))
              ? 0
              : parseInt(e.metadata.duration_ms),
            r = e.metadata.recordings.map((e) => {
              const r = parseInt(e.start_offset_ms);
              let i = parseInt(e.duration_ms);
              return (
                isNaN(i) &&
                  this.m_timelineMask.IsActiveRecording(e.recording_id) &&
                  (i = t - r),
                {
                  recordingID: e.recording_id,
                  timelineOffsetMS: r,
                  nDurationMS: i,
                  bIsActive: this.m_timelineMask.IsActiveRecording(
                    e.recording_id,
                  ),
                  recordingType: e.recording_type,
                }
              );
            }),
            i = (e.metadata.phases || []).map((e) => ({
              timelineOffsetMS: parseInt(e.background_timeline_offset),
              nDurationMS: parseInt(e.duration_ms),
              phase: e,
            }));
          return {
            timelineID: e.metadata.timeline_id,
            globalOffsetMS: e.nGlobalOffsetMS.valMS,
            nDurationMS: t,
            recordingOffsets: r,
            phaseOffsets: i,
          };
        }
        GetCurrentZoomScale() {
          return this.m_msVisible / (this.m_scrollWindowWidth || 1) || 1;
        }
        GetClipsForTimeline(e) {
          return this.m_mapTimelineClips.get(e) || [];
        }
        ComputeEntriesForTimeline(e) {
          const t = this.m_timelineMask.GetTimelineDataOrStartLoad(e);
          t &&
            "loaded" == t.m_strState &&
            this.m_mapTimelineEntries.set(e, {
              rgGameModes: t.m_rgGameModeChanges,
              rgHighlights: t.m_rgEntries,
            });
        }
        GetVisibleTimelineGameModes(e) {
          return this.m_mapTimelineEntries.get(e)?.rgGameModes;
        }
        GetVisibleTimelineHighlights(e) {
          return this.m_mapTimelineEntries.get(e)?.rgHighlights;
        }
        GetStateDescriptionAtGlobalMS(e) {
          return this.m_timelineMask.GetStateDescriptionAtGlobalMS(e);
        }
        FindRangeEventsAtGlobalMS(e) {
          return this.m_timelineMask.FindRangeEventsAtGlobalMS(e);
        }
        GetTimelineOffsetMS(e) {
          return this.m_timelineMask.GetTimelineStartBeforeGlobalZeroMS(e);
        }
        ScrollToCenteredGlobalMS(e) {
          const t = this.ConvertGlobalMSToGlobalPXOffset(e);
          this.ScrollToOffsetCentered(t);
        }
        ScrollToOffset(e) {
          this.m_scrollLeftPX = (0, Ye.OQ)(e, 0, this.GetMaxScrollLeftPX());
        }
        ScrollToOffsetCentered(e) {
          const t = Math.max(0, e - 0.5 * this.m_scrollWindowWidth);
          this.ScrollToOffset(t);
        }
        ScrollBy(e) {
          const t = this.m_scrollLeftPX + e;
          this.ScrollToOffset(t);
        }
        GetAutoScrollPaused() {
          return this.m_bAutoScrollPaused;
        }
        SetAutoScrollPaused(e) {
          this.ClearAutoScrollPauseTimeout(), (this.m_bAutoScrollPaused = e);
        }
        GetAutoScrollPauseTimeout() {
          return this.m_autoScrollPauseTimeout;
        }
        ClearAutoScrollPauseTimeout() {
          this.m_autoScrollPauseTimeout &&
            clearTimeout(this.m_autoScrollPauseTimeout),
            (this.m_autoScrollPauseTimeout = null);
        }
        SetAutoScrollPauseTimeout(e = 5e3) {
          this.ClearAutoScrollPauseTimeout(),
            (this.m_autoScrollPauseTimeout = window.setTimeout(() => {
              this.SetAutoScrollPaused(!1);
            }, e));
        }
        ScrollToEnd() {
          this.ScrollToOffset(this.GetMaxScrollLeftPX());
        }
        SetScrollWindowWidth(e) {
          (this.m_scrollWindowWidth = e),
            this.m_timelineMask.BInitialized() &&
              (this.ScrollToOffset(this.m_scrollLeftPX),
              this.InitDefaultsIfReady());
        }
        SetScrollWindowOffset(e) {
          this.m_scrollWindowOffsetPX = e;
        }
        GetScrollWindowOffset() {
          return this.m_scrollWindowOffsetPX;
        }
        GetScrollableWidthPX() {
          if (!this.m_rgTimelineOffsets?.length) return 0;
          const e = this.m_rgTimelineOffsets.length - 1,
            t = this.m_rgTimelineOffsets[e];
          return (
            10 * e +
            this.ConvertDurationMSToDeltaPX(t.globalOffsetMS + t.nDurationMS)
          );
        }
        GetOverscanWidth() {
          return (10 * this.GetScrollWindowWidth()) / 100;
        }
        GetScrollWindowWidth() {
          return this.m_scrollWindowWidth;
        }
        GetMaxScrollLeftPX() {
          return Math.max(
            0,
            this.GetScrollableWidthPX() -
              this.GetScrollWindowWidth() +
              2 * this.GetTimelineMarginWidth(),
          );
        }
        BReachedMaxScroll() {
          return (
            Math.ceil(this.m_scrollLeftPX) ===
            Math.ceil(this.GetMaxScrollLeftPX())
          );
        }
        BReachedMinScroll() {
          return 0 === this.m_scrollLeftPX;
        }
        GetVisualWindowStartPX() {
          return this.m_scrollLeftPX;
        }
        GetVisualWidth() {
          return Math.min(
            this.m_scrollWindowWidth,
            this.GetScrollableWidthPX() + 2 * this.GetTimelineMarginWidth(),
          );
        }
        GetVirtualWindowStartPX() {
          return Math.max(this.m_scrollLeftPX - this.GetOverscanWidth(), 0);
        }
        GetVirtualWindowWidthPX() {
          const e = (0, Ye.OQ)(this.m_scrollLeftPX, 0, this.GetOverscanWidth()),
            t = Math.min(
              this.GetScrollableWidthPX() -
                (this.m_scrollLeftPX + this.m_scrollWindowWidth),
              this.GetOverscanWidth(),
            );
          return e + this.m_scrollWindowWidth + t;
        }
        GetVirtualWindowEndPX() {
          return (
            this.GetVirtualWindowStartPX() + this.GetVirtualWindowWidthPX()
          );
        }
        GetVisibleTimelines() {
          const e =
              this.FindIndexOfClosestTimelineEndForOffsetPX(
                this.GetVirtualWindowStartPX(),
              ) + 1,
            t = this.FindIndexOfClosestTimelineStartForOffsetPX(
              this.GetVirtualWindowEndPX(),
            );
          return this.m_rgTimelineOffsets.slice(e, t + 1).map((e) => {
            const t = Math.max(
                e.globalOffsetMS,
                this.ConvertPXOffsetToGlobalMS(this.GetVirtualWindowStartPX()),
              ),
              r = Math.min(
                e.nDurationMS - (t - e.globalOffsetMS),
                this.ConvertDeltaPXToDurationMS(this.GetVirtualWindowWidthPX()),
              ),
              i = this.ConvertGlobalMSToGlobalPXOffset(t),
              n = this.ConvertDurationMSToDeltaPX(r),
              a = this.ConvertGlobalMSToGlobalPXOffset(e.globalOffsetMS),
              s = this.ConvertDurationMSToDeltaPX(e.nDurationMS);
            return {
              ...e,
              pxStart: a,
              pxDuration: s,
              msVisibleStart: t,
              msVisibleDuration: r,
              pxVisibleStart: i,
              pxVisibleDuration: n,
            };
          });
        }
        GetVisibleRecordings() {
          const e = [];
          return (
            this.GetVisibleTimelines().forEach((t) => {
              t.recordingOffsets.forEach((r) => {
                const i = t.pxStart + this.GetPXForDuration(r.timelineOffsetMS),
                  n = i + this.GetPXForDuration(r.nDurationMS);
                n < this.GetVirtualWindowStartPX() ||
                  i > this.GetVirtualWindowEndPX() ||
                  e.push({
                    recordingID: r.recordingID,
                    nStartPX: i,
                    nEndPX: n,
                    bIsActive: r.bIsActive,
                    recordingType: r.recordingType,
                  });
              });
            }),
            e
          );
        }
        GetVisibleClips() {
          const e = [];
          return (
            this.GetVisibleTimelines().forEach((t) => {
              const r = this.ConvertGlobalMSToGlobalPXOffset(t.globalOffsetMS);
              this.GetClipsForTimeline(t.timelineID).forEach((i) => {
                const n = r + this.GetPXForDuration(i.msTimelineOffset),
                  a = Math.min(
                    this.GetVirtualWindowEndPX(),
                    this.ConvertGlobalMSToGlobalPXOffset(
                      t.globalOffsetMS + i.msTimelineOffset + i.msDuration,
                    ),
                  );
                a < this.GetVirtualWindowStartPX() ||
                  n > this.GetVirtualWindowEndPX() ||
                  e.push({ clipID: i.clipID, pxClipStart: n, pxClipEnd: a });
              });
            }),
            e
          );
        }
        GetPXForDuration(e) {
          return e / this.GetCurrentZoomScale();
        }
        GetVisibleTimelinesInWindow() {
          const e =
              this.FindIndexOfClosestTimelineEndForOffsetPX(
                this.m_scrollLeftPX,
              ) + 1,
            t = this.FindIndexOfClosestTimelineStartForOffsetPX(
              this.m_scrollLeftPX + this.m_scrollWindowWidth,
            );
          return this.m_rgTimelineOffsets.slice(e, t + 1);
        }
        GetVisibleWindowRelativeTimelines() {
          return this.GetVisibleTimelinesInWindow().map((e) => {
            const t = this.m_scrollLeftPX,
              r = this.GetVirtualWindowEndPX() - this.GetOverscanWidth(),
              i = this.ConvertGlobalMSToGlobalPXOffset(e.globalOffsetMS),
              n = i + this.ConvertDurationMSToDeltaPX(e.nDurationMS),
              a = Math.max(i, t),
              s = Math.min(n, r);
            return {
              timelineID: e.timelineID,
              nVisibleStartPX: a,
              nEndPX: s,
              nTimelineStartMS: this.ConvertPXToTimelineRelativeMS(t),
              nGlobalStartMS: this.ConvertPXOffsetToGlobalMS(t),
            };
          });
        }
        ConvertPXToTimelineRelativeMS(e, t = "start") {
          const r = this.ConvertPXOffsetToGlobalMS(e);
          let i = this.m_timelineMask.GetTimelineOffsetFromGlobal(r, 0);
          return "end-if-active" == t &&
            i.strTimelineID &&
            this.m_timelineMask.IsActiveTimeline(i.strTimelineID)
            ? this.m_timelineMask.MakeRelativeToTimelineEndIfActive(
                i.strTimelineID,
                i.nTimelineOffsetMS.valMS,
              )
            : i.nTimelineOffsetMS.valMS;
        }
        GetTimeRecorded(e) {
          return this.m_timelineMask.GetTimelineStartTime(e);
        }
        ConvertGlobalMSToClipOrNone(e) {
          const t = this.m_timelineMask.GetTimelineOffsetFromGlobal(e, 0);
          if (!t) return null;
          const { nTimelineOffsetMS: r, strTimelineID: i } = t;
          if (!i) return null;
          if (this.m_mapTimelineClips.has(i)) {
            return this.m_mapTimelineClips
              .get(i)
              .find(
                (e) =>
                  e.msTimelineOffset <= r.valMS &&
                  e.msTimelineOffset + e.msDuration >= r.valMS,
              );
          }
          return null;
        }
        ConvertGlobalMSToScrollWindowPXOffset(e) {
          return this.ConvertGlobalMSToGlobalPXOffset(e) - this.m_scrollLeftPX;
        }
        ConvertGlobalMSToGlobalPXOffset(e, t = -1) {
          t < 0 &&
            (t = tt.rJ(this.m_rgTimelineOffsets, (t) => e - t.globalOffsetMS));
          const r = 10 * t;
          return this.ConvertDurationMSToDeltaPX(e) + r;
        }
        ConvertPXOffsetToGlobalMS(e, t = !0) {
          if (this.BPositionInGap(e)) {
            if (!t) return null;
            const r = this.FindClosestTimelineEndForOffsetPX(e);
            return r ? r.globalOffsetMS + r.nDurationMS : 0;
          }
          const r = this.FindClosestTimelineStartForOffsetPX(e);
          if (!r) return null;
          const i = this.ConvertGlobalMSToGlobalPXOffset(r.globalOffsetMS),
            n = this.ConvertDeltaPXToDurationMS(e - i);
          return r.globalOffsetMS + n;
        }
        FindClosestTimelineEndForOffsetPX(e) {
          const t = this.FindIndexOfClosestTimelineEndForOffsetPX(e);
          if (t < 0) return null;
          return this.m_rgTimelineOffsets[t];
        }
        FindClosestTimelineStartForOffsetPX(e) {
          const t = this.FindIndexOfClosestTimelineStartForOffsetPX(e);
          if (t < 0) return null;
          return this.m_rgTimelineOffsets[t];
        }
        FindIndexOfClosestTimelineEndForOffsetPX(e) {
          return tt.rJ(this.m_rgTimelineOffsets, (t) => {
            const r =
              this.ConvertGlobalMSToGlobalPXOffset(t.globalOffsetMS) +
              this.ConvertDurationMSToDeltaPX(t.nDurationMS);
            return e - r;
          });
        }
        FindIndexOfClosestTimelineStartForOffsetPX(e) {
          return tt.rJ(this.m_rgTimelineOffsets, (t) => {
            const r = this.ConvertGlobalMSToGlobalPXOffset(t.globalOffsetMS);
            return e - r;
          });
        }
        FindTimelineOffsets(e) {
          return this.m_rgTimelineOffsets.find((t) => t.timelineID === e);
        }
        BPositionInGap(e) {
          const t = this.FindIndexOfClosestTimelineEndForOffsetPX(e);
          if (t < 0) return !1;
          const r = t + 1;
          if (r >= this.m_rgTimelineOffsets.length) return !1;
          const i = this.m_rgTimelineOffsets[t],
            n = this.m_rgTimelineOffsets[r],
            a = this.ConvertGlobalMSToGlobalPXOffset(i.globalOffsetMS);
          return (
            e < this.ConvertGlobalMSToGlobalPXOffset(n.globalOffsetMS) &&
            e !== a
          );
        }
        ConvertDurationMSToDeltaPX(e) {
          return e / this.GetCurrentZoomScale();
        }
        ConvertDeltaPXToDurationMS(e) {
          return e * this.GetCurrentZoomScale();
        }
        SetPhaseToHighlight(e) {
          this.m_phaseToHighlight = e;
        }
        GetPhaseToHighlight() {
          return this.m_phaseToHighlight;
        }
      }
      (0, W.Cg)([Oe.sH], jt.prototype, "m_durationMS", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_scrollLeftPX", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_scrollWindowWidth", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_scrollWindowOffsetPX", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_bAutoScrollPaused", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_autoScrollPauseTimeout", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_msVisible", void 0),
        (0, W.Cg)([Oe.sH.ref], jt.prototype, "m_rgTimelineOffsets", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_bInitialized", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_eThumbnailComponent", void 0),
        (0, W.Cg)(
          [Oe.sH],
          jt.prototype,
          "m_nGlobalRelativeThumbnailPositionPX",
          void 0,
        ),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_thumbnailHighlightEntry", void 0),
        (0, W.Cg)([Oe.sH], jt.prototype, "m_phaseToHighlight", void 0),
        (0, W.Cg)([Oe.XI], jt.prototype, "OnLoaderInitialized", null),
        (0, W.Cg)([Oe.XI], jt.prototype, "InitDefaultsIfReady", null),
        (0, W.Cg)([Oe.XI], jt.prototype, "OnInvalidate", null),
        (0, W.Cg)([Oe.XI], jt.prototype, "ZoomIn", null),
        (0, W.Cg)([Oe.XI], jt.prototype, "ZoomOut", null),
        (0, W.Cg)([Oe.XI], jt.prototype, "SetTempZoomScale", null),
        (0, W.Cg)([Oe.XI], jt.prototype, "ClearTempZoomScale", null),
        (0, W.Cg)([Oe.XI], jt.prototype, "UpdateClipSummaries", null),
        (0, W.Cg)([j.oI], jt.prototype, "BReachedMaxScroll", null),
        (0, W.Cg)([j.oI], jt.prototype, "BReachedMinScroll", null);
      const Lt = a.createContext(null);
      function Ht(e) {
        let {
            loader: t,
            playbackCoordinator: r,
            children: i,
            clipSummaries: n,
            refTimelineParentCtn: s,
          } = e,
          [l, o] = (0, a.useState)(null);
        return (
          (0, a.useEffect)(() => {
            if (!t) return;
            let e = new jt(t, r, n);
            return o(e), () => e.Close();
          }, [t]),
          (0, a.useEffect)(() => {
            l && l.UpdateClipSummaries(n);
          }, [l, n]),
          (0, a.useEffect)(() => {
            l && s && l.SetTimelineParentCtnRef(s.current);
          }, [l, s]),
          (function (e) {
            let t = At();
            (0, a.useEffect)(() => {
              e && e.SetUserIsClipping(t);
            }, [e, t]);
          })(l),
          (function (e) {
            let t = a.useCallback(
              (t, r) => {
                if (!e) return;
                if (!t || !r) return void e.ClearTempZoomScale();
                let i = Math.floor(0.1 * (r.valMS - t.valMS)),
                  n = r.valMS - t.valMS;
                n < 0.9 * Nt && (i = Math.floor((Nt - n) / 2));
                let a = t.valMS - i,
                  s = r.valMS + i;
                e.SetTempZoomScale(a, s);
              },
              [e],
            );
            !(function (e) {
              let t = (0, a.useContext)(Ct),
                r = t.selectionZoomCount,
                i = t.globalStartMS,
                n = t.globalEndMS,
                s = (0, a.useRef)(r),
                l = (0, a.useRef)(null);
              (l.current = e),
                (0, a.useEffect)(() => {
                  if (!l.current) return;
                  let e = !isNaN(i?.valMS) && !isNaN(n?.valMS);
                  (s.current == r && e) ||
                    ((s.current = r),
                    e && r ? l.current(i, n) : l.current(null, null));
                }, [r, i, n, s, l]);
            })(t);
          })(l),
          l ? a.createElement(Lt.Provider, { value: l }, i) : null
        );
      }
      function Xt() {
        return (0, a.useContext)(Lt);
      }
      var Vt = r(59254);
      const Zt = [1e3, 5e3, 3e4, 6e4, 15e4, 3e5, 9e5, 18e5],
        Kt = a.memo(function (e) {
          const t = Xt(),
            r = (0, Ue.q3)(() => t.GetVisibleTimelines());
          return a.createElement(
            a.Fragment,
            null,
            r.map((e) =>
              a.createElement(Qt, {
                key: e.timelineID,
                msVisibleStart: e.msVisibleStart,
                pxVisibleDuration: e.pxVisibleDuration,
                pxVisibleStart: e.pxVisibleStart,
                msTimelineStart: e.globalOffsetMS,
              }),
            ),
          );
        }),
        Qt = a.memo(function (e) {
          const {
              msVisibleStart: t,
              msTimelineStart: r,
              pxVisibleDuration: i,
              pxVisibleStart: n,
            } = e,
            { msTickSpacing: s, pxTickSpacing: l } = (function () {
              const e = Xt(),
                t = (0, Ue.q3)(() => e.GetCurrentZoomScale()),
                r = 300,
                i = (e) => Math.abs(r - e / t),
                n = Zt.reduce((e, t) => (i(e) - i(t) < 0 ? e : t)) / 20,
                a = n / t;
              return { msTickSpacing: n, pxTickSpacing: a };
            })(),
            o = Xt(),
            m = Math.ceil((t - r) / s),
            c = r + m * s,
            d = o.ConvertGlobalMSToGlobalPXOffset(c),
            u = (0, a.useMemo)(() => {
              const e = Math.ceil(i / l),
                t = [];
              for (let r = 0; r < e; r++) {
                const e = d + r * l,
                  i = `${c + s * r}`;
                t.push({ key: i, offsetPX: e, iTimelineRelativeTick: m + r });
              }
              return t;
            }, [i, l, c, s, d, m]);
          return u
            ? a.createElement(
                a.Fragment,
                null,
                a.createElement("div", {
                  className: Vt.TimelineBacking,
                  style: { transform: `translateX(${n}px)`, width: i },
                }),
                u.map((e) =>
                  a.createElement(Jt, {
                    key: e.key,
                    timelineRelativeIndex: e.iTimelineRelativeTick,
                    globalOffsetPX: e.offsetPX,
                  }),
                ),
              )
            : null;
        });
      function Jt(e) {
        const { globalOffsetPX: t, timelineRelativeIndex: r } = e,
          i = r % 20 == 0 ? Vt.Major : Vt.Minor;
        return a.createElement(
          "div",
          {
            className: Vt.TimeTick,
            style: { transform: `translateX(${t}px)` },
          },
          a.createElement("div", { className: (0, Te.A)(Vt.TickLine, i) }),
        );
      }
      var $t = r(23533),
        Yt = r(70692),
        er = r(30470);
      const tr = "steam_";
      var rr;
      function ir(e) {
        switch (e) {
          default:
          case rr.White:
            return "#DCDEDF";
          case rr.Red:
            return "#FB7C7C";
          case rr.Orange:
            return "#FBB17C";
          case rr.Yellow:
            return "#FBDF7C";
          case rr.Green:
            return "#9DFB7C";
          case rr.Blue:
            return "#7CD5FB";
          case rr.Purple:
            return "#A57CFB";
          case rr.Brown:
            return "#C18C5B";
          case rr.Gray:
            return "#B8BCBF";
        }
      }
      function nr(e) {
        return Object.keys(e).filter((e) => !Number.isNaN(e));
      }
      !(function (e) {
        (e[(e.White = 0)] = "White"),
          (e[(e.Red = 1)] = "Red"),
          (e[(e.Orange = 2)] = "Orange"),
          (e[(e.Yellow = 3)] = "Yellow"),
          (e[(e.Green = 4)] = "Green"),
          (e[(e.Blue = 5)] = "Blue"),
          (e[(e.Purple = 6)] = "Purple"),
          (e[(e.Brown = 7)] = "Brown"),
          (e[(e.Gray = 8)] = "Gray");
      })(rr || (rr = {}));
      const ar = nr(rr).map((e) => rr[e]);
      class sr {
        m_mapSteamTimelineMarkers = new Map();
        GetMarkerByID(e) {
          const t = e.toLowerCase().startsWith(tr)
            ? e.slice(tr.length).toLowerCase()
            : e.toLowerCase();
          if (this.m_mapSteamTimelineMarkers.has(t))
            return this.m_mapSteamTimelineMarkers.get(t);
          const r = parseInt(t);
          return "number" == typeof r && r >= 0 && r <= 99
            ? { func: (e) => gt.wN({ nNumber: r }), color: rr.Gray }
            : or();
        }
        GetAllUseableMarkerID() {
          return Array.from(this.m_mapSteamTimelineMarkers.keys()).map(
            (e) => tr + e,
          );
        }
        static s_Singleton;
        static Get() {
          return (
            sr.s_Singleton ||
              ((sr.s_Singleton = new sr()),
              sr.s_Singleton.Init(),
              "dev" == er.TS.WEB_UNIVERSE &&
                (window.g_SteamTimelineMarker = sr.s_Singleton)),
            sr.s_Singleton
          );
        }
        AddMarker(e, t, r) {
          const i = r ?? rr.White;
          this.m_mapSteamTimelineMarkers.set(e, { func: t, color: i });
          for (const r of ar) {
            const i = `${e}_${rr[r]}`.toLowerCase();
            this.m_mapSteamTimelineMarkers.set(i, { func: t, color: r });
          }
        }
        Init() {
          this.AddMarker("explosion", gt.Wq, rr.Gray),
            this.AddMarker("attack", gt.LB, rr.Gray),
            this.AddMarker("defend", gt.po, rr.Gray),
            this.AddMarker("combat", gt.t4, rr.Gray),
            this.AddMarker("chest", gt.k8, rr.Gray),
            this.AddMarker("view", gt.Ss, rr.Gray),
            (0, L.Y2)()
              ? this.AddMarker("death", gt.X, rr.Gray)
              : this.AddMarker("death", gt.lQ, rr.Gray),
            this.AddMarker("x", gt.X, rr.Gray),
            this.AddMarker("plus", gt.FW, rr.Gray),
            this.AddMarker("minus", gt.Hs, rr.Gray),
            this.AddMarker("info", gt.R2, rr.Gray),
            this.AddMarker("bolt", gt.y$, rr.Gray),
            this.AddMarker("caution", gt.eT, rr.Gray),
            this.AddMarker("completed", gt.AY, rr.Gray),
            this.AddMarker("checkmark", gt.MG, rr.Gray),
            this.AddMarker("effect", gt.Mj, rr.Gray),
            this.AddMarker("purchase", gt.QY, rr.Gray),
            this.AddMarker("ribbon", gt.y4, rr.Gray),
            this.AddMarker("scroll", gt.OY, rr.Gray),
            this.AddMarker("crown", gt.Oe, rr.Gray),
            this.AddMarker("starburst", gt.bL, rr.Gray),
            this.AddMarker("flag", gt.lN, rr.Gray),
            this.AddMarker("cart", gt.Z3, rr.Gray),
            this.AddMarker("timer", gt.M4, rr.Gray),
            this.AddMarker("chat", gt.ry, rr.Gray),
            this.AddMarker("wrench", gt.Ml, rr.Gray),
            this.AddMarker("transfer", gt.mr, rr.Gray),
            this.AddMarker("edit", gt.ff, rr.Gray),
            this.AddMarker("bookmark", gt.Xh, rr.Gray),
            this.AddMarker("invalid", gt.WO, rr.Gray),
            this.AddMarker("star", gt.FE, rr.Gray),
            this.AddMarker("circle", gt.jl, rr.Gray),
            this.AddMarker("square", gt.M6, rr.Gray),
            this.AddMarker("triangle", gt.lM, rr.Gray),
            this.AddMarker("heart", gt.B1, rr.Gray),
            this.AddMarker("diamond", gt.JB, rr.Gray),
            this.AddMarker("gem", gt.gD, rr.Gray),
            this.AddMarker("group", gt.YJ, rr.Gray),
            this.AddMarker("pair", gt.Rm, rr.Gray),
            this.AddMarker("single", gt.KJ, rr.Gray),
            this.AddMarker("trophy", gt.Oi, rr.Gray),
            this.AddMarker("achievement", gt.Oi, rr.Gray),
            this.AddMarker("screenshot", gt.pw, rr.Gray),
            this.AddMarker("bug", gt.zP, rr.Gray),
            this.AddMarker("fix", gt.Ml, rr.Gray),
            this.AddMarker("person", gt.KJ, rr.Gray),
            this.AddMarker("question", gt.O_, rr.Gray);
        }
      }
      function lr(e) {
        return sr.Get().GetMarkerByID(e);
      }
      function or() {
        return { func: gt.pH, color: rr.Gray };
      }
      function mr(e) {
        return e && e.toLowerCase().startsWith(tr);
      }
      var cr = r(29210),
        dr = r(73515);
      function ur(e) {
        let {
          entry: t,
          strMarkerIcon: r,
          onClick: i,
          onMouseEnter: n,
          onMouseLeave: s,
          onContextMenu: l,
          classNames: o,
          style: m,
          faded: c,
          bSelectedMarker: d,
        } = e;
        return a.createElement(
          "div",
          {
            style: m ?? {},
            className: (0, Te.A)(o, {
              [dr.HighlightIcon]: !0,
              [dr.Selected]: d,
              [dr.Faded]: c,
            }),
            onClick: (e) => {
              i && i(e);
            },
            onContextMenu: l,
            onMouseEnter: n,
            onMouseLeave: s,
          },
          a.createElement(gr, { entry: t, strMarkerIcon: r }),
        );
      }
      function gr(e) {
        let { entry: t, strMarkerIcon: r } = e;
        const i = Rt().GetGameID();
        return (0, Yt.xz)(t)
          ? a.createElement(pr, { achievementEntry: t, strGameID: i })
          : (0, Yt.In)(t)
            ? a.createElement(hr, null)
            : mr(r)
              ? a.createElement(_r, { entry: t, strMarkerIcon: r })
              : a.createElement(Sr, { strMarkerIcon: r, strGameID: i });
      }
      function pr(e) {
        const { achievementEntry: t, strGameID: r } = e,
          i = Ze(new cr.VS(r).GetAppID(), t.achievement_name);
        let n, s;
        if (i) (n = "white"), (s = a.createElement("img", { src: i.iconURL }));
        else {
          const e = { func: gt.Oi, color: rr.White };
          (n = ir(e.color)), (s = e.func({}));
        }
        return a.createElement(
          "div",
          { className: dr.Marker, style: { color: n } },
          s,
        );
      }
      function _r(e) {
        const { entry: t, strMarkerIcon: r } = e;
        let i, n;
        (0, Yt.N$)(t)
          ? ((i = { func: gt.pH, color: rr.Blue }), (n = dr.CustomMarker))
          : (i = lr(r));
        const s = ir(i.color);
        return a.createElement(
          Mr,
          { color: s },
          a.createElement("div", { className: n }, i.func({})),
        );
      }
      function fr(e) {
        const { icon: t, className: r } = e;
        return lr(t).func({ className: r });
      }
      function hr(e) {
        const t = lr("steam_invalid"),
          r = ir(t.color);
        return a.createElement(
          Mr,
          { color: r },
          a.createElement("div", null, t.func({})),
        );
      }
      function Sr(e) {
        const { strMarkerIcon: t, strGameID: r } = e;
        return a.createElement(
          Mr,
          null,
          a.createElement(br, { icon: t, gameID: r }),
        );
      }
      function br(e) {
        const { icon: t, gameID: r, className: i } = e,
          n = (function (e, t) {
            return re
              ? re(e, t)
              : (console.error(
                  "useGameMarkerFromID called in a context where the hook isn't defined.",
                ),
                null);
          })(new cr.VS(r).GetAppID(), t);
        if (mr(t)) return a.createElement(fr, { ...e });
        if (null === n) return null;
        if (void 0 === n) {
          const e = or();
          return a.createElement("div", { className: i }, e.func({}));
        }
        let s = "";
        return (
          (s =
            "string" != typeof n
              ? new XMLSerializer().serializeToString(n)
              : n),
          a.createElement(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 36 36",
              className: (0, Te.A)(i, dr.GameMarkerSVG),
            },
            a.createElement("g", { dangerouslySetInnerHTML: { __html: s } }),
          )
        );
      }
      function Mr(e) {
        const { children: t, color: r } = e;
        return a.createElement(
          "div",
          { className: dr.MarkerCtn },
          a.createElement(
            "div",
            { className: dr.Marker, style: r ? { color: r } : null },
            t,
          ),
        );
      }
      class yr {
        m_reservations = [];
        m_nIconWidth;
        constructor(e) {
          this.m_nIconWidth = e;
        }
        BAllowIcon(e) {
          const t = {
            nStart: e - this.m_nIconWidth / 2,
            nEnd: e + this.m_nIconWidth / 2,
          };
          let r = 0;
          for (; r < this.m_reservations.length; r++) {
            const e = this.m_reservations[r];
            if (e.nStart >= t.nEnd) break;
            if (!((i = t).nStart >= (n = e).nEnd || i.nEnd <= n.nStart))
              return !1;
          }
          var i, n;
          return this.m_reservations.splice(r, 0, t), !0;
        }
      }
      var Tr = r(68451),
        Br = r(88997);
      const vr = (0, a.createContext)({});
      function Rr() {
        return (0, a.useContext)(vr);
      }
      var Gr = r(41972),
        wr = r(60395);
      function Cr(e) {
        const {
            closeModal: t,
            strTimelineID: r,
            entry: i,
            playbackCoordinator: n,
            fnClearSelection: s,
          } = e,
          [l, o] = a.useState(i.title || ""),
          [c, d] = a.useState(i.description || ""),
          u = (0, Se.vs)();
        return u.bLoading
          ? a.createElement(Se.Hh, {
              state: u,
              strDialogTitle: (0, p.we)("#Marker_Dialog"),
              closeModal: t,
            })
          : a.createElement(
              Me.o0,
              {
                strTitle: (0, p.we)("#Marker_Dialog"),
                strMiddleButtonText: (0, p.we)("#Marker_Action_Delete"),
                onCancel: t,
                onOK: async () => {
                  u.fnSetLoading(!0);
                  (await n.UpdateUserMarker(r, i, l, c))
                    ? t()
                    : (u.fnSetError(!0),
                      u.fnSetStrError((0, p.we)("#Marker_UpdateFailed")));
                },
              },
              a.createElement(m.pd, {
                type: "text",
                value: l,
                onChange: (e) => o(e.currentTarget.value),
                label: (0, p.we)("#Marker_Title"),
              }),
              a.createElement(m.pd, {
                type: "text",
                value: c,
                onChange: (e) => d(e.currentTarget.value),
                label: (0, p.we)("#Marker_Description"),
              }),
            );
      }
      var Er = r(54637);
      class Ir {
        m_bCreationWasTemporary;
        m_fnCreate;
        m_creationResult;
        m_bCleanedUp = !1;
        m_nClipLengthSeconds;
        m_strSuggestedClipName;
        m_strGameID;
        m_strSrcClipID;
        m_eInitMethod;
        m_startMetrics;
        m_endMetrics;
        constructor(e, t, r, i, n, a, s, l) {
          (this.m_fnCreate = e),
            (this.m_nClipLengthSeconds = t),
            (this.m_strSuggestedClipName = r),
            (this.m_strGameID = i),
            (this.m_strSrcClipID = n),
            (this.m_eInitMethod = a),
            (this.m_startMetrics = s),
            (this.m_endMetrics = l);
        }
        Request() {
          return {
            create: this.create,
            cleanup: this.cleanup,
            bExistingClip: !1,
            nClipLengthSeconds: this.m_nClipLengthSeconds,
            strSuggestedClipName: this.m_strSuggestedClipName,
            gameID: new cr.VS(this.m_strGameID),
            strSrcClipID: this.m_strSrcClipID,
            eInitMethod: this.m_eInitMethod,
            startMetrics: this.m_startMetrics,
            endMetrics: this.m_endMetrics,
          };
        }
        async create(e, t) {
          return (
            this.m_creationResult ||
              ((this.m_creationResult = await this.m_fnCreate(e, t)),
              (this.m_bCreationWasTemporary = e),
              (function (e, t, r, i, n) {
                je().ReportClipRange(e, t, r, i, n);
              })(
                new cr.VS(this.m_strGameID),
                this.m_eInitMethod,
                this.m_nClipLengthSeconds,
                this.m_startMetrics,
                this.m_endMetrics,
              )),
            Promise.resolve(this.m_creationResult)
          );
        }
        async cleanup() {
          if (this.m_bCleanedUp)
            throw new Error("cleanup called twice on clip creation");
          if (
            ((this.m_bCleanedUp = !0),
            this.m_creationResult?.clipSummary && this.m_bCreationWasTemporary)
          ) {
            const { fnDeleteClip: e } =
              null != je() ? { fnDeleteClip: je().DeleteClip } : {};
            await e(this.m_creationResult.clipSummary.clip_id);
          }
        }
      }
      function kr(e, t, r, i, n, a, s, l, o, m, c) {
        return new Ir(
          (l, o) =>
            (async function (e, t, r, i, n, a, s, l, o) {
              const { fnSaveClip: m } =
                null != je() ? { fnSaveClip: je().SaveClip } : {};
              (0, ze.tG)(`start ${i} @ ${n} upto ${a} @ ${s}`);
              try {
                const c = await m(
                    e,
                    t,
                    r,
                    { timeline_id: i, offset_ms: "" + n },
                    { timeline_id: a, offset_ms: "" + s },
                    l,
                    o,
                  ),
                  { clipSummary: d, result: u } = c;
                return (
                  d
                    ? (0, ze.tG)(`Clip ${d.clip_id} created`)
                    : (0, ze.tG)(`Clip was not created: ${u}`),
                  c
                );
              } catch (e) {
                (0, ze.ZI)(e);
              }
              return { result: _.d.k_EResultFail };
            })(e, t, r, i, n, a, s, l, o),
          l / 1e3,
          r,
          e,
          t,
          o,
          m,
          c,
        ).Request();
      }
      (0, W.Cg)([j.oI], Ir.prototype, "create", null),
        (0, W.Cg)([j.oI], Ir.prototype, "cleanup", null);
      var Pr = r(7450);
      const Or = a.createContext({
        bInContainer: !1,
        bContainerFocus: !1,
        nMouseClientXPX: null,
        globalMouseXPX: null,
        scrollWindowMouseXPX: null,
        fnRegisterMouseEvent: null,
        bContextMenuOpen: !1,
        setContextMenuOpen: () => {},
      });
      function zr(e) {
        const { children: t } = e,
          [r, i] = (0, a.useState)(!1),
          [n, s] = (0, a.useState)(!1),
          [l, o] = (0, a.useState)(!1),
          [m, c] = (0, a.useState)(),
          d = (0, a.useRef)(void 0),
          u = Xt(),
          p = (0, Ue.q3)(() => u.GetScrollableWidthPX()),
          _ = (0, Ue.q3)(() => u.GetVisualWindowStartPX()),
          f = (0, Ue.q3)(() => u.GetScrollWindowWidth()),
          h = (0, Ue.q3)(() => u.GetScrollWindowOffset()),
          S = (0, Ue.q3)(() => u.GetTimelineMarginWidth()),
          b = a.useMemo(() => {
            if (d.current) {
              const e = _ - h - S;
              return (0, et.OB)(Ye.OQ(m + e, 0, p));
            }
            return (0, et.OB)(0);
          }, [S, m, h, _, p]),
          M = a.useMemo(() => {
            if (d.current) {
              const e = d.current.getBoundingClientRect(),
                t = p > f ? h : e.x;
              return (0, et.QP)(Ye.OQ(m - t, 0, f));
            }
            return (0, et.QP)(0);
          }, [m, h, f, p]),
          y = (0, a.useCallback)(
            (e, t) => (
              d.current && d.current.addEventListener(e, t),
              () => d.current?.removeEventListener(e, t)
            ),
            [],
          ),
          T = (0, a.useCallback)(() => i(!0), []),
          B = (0, a.useCallback)(() => i(!1), []),
          v = (0, a.useCallback)((e) => c(e.clientX), []),
          R = (0, a.useCallback)((e) => s(!0), []),
          G = (0, a.useCallback)((e) => s(!1), []);
        (0, a.useEffect)(() => {
          const e = (0, g.qf)(d.current);
          return (
            e.addEventListener("mousemove", v),
            () => e.removeEventListener("mousemove", v)
          );
        }, [v]);
        const w = (0, a.useMemo)(
          () => ({
            bContainerFocus: n,
            bInContainer: r,
            nMouseClientXPX: m,
            globalMouseXPX: b,
            scrollWindowMouseXPX: M,
            fnRegisterMouseEvent: y,
            bContextMenuOpen: l,
            setContextMenuOpen: o,
          }),
          [n, r, l, m, b, M, y],
        );
        return a.createElement(
          Or.Provider,
          { value: w },
          a.createElement(
            "div",
            {
              ref: d,
              onMouseOver: R,
              onFocus: R,
              onMouseOut: G,
              onBlur: G,
              onMouseEnter: T,
              onMouseLeave: B,
              className: Pr.MouseListenerContainer,
            },
            t,
          ),
        );
      }
      function Dr() {
        return (0, a.useContext)(Or);
      }
      function Ar() {
        return Dr().globalMouseXPX;
      }
      function Wr() {
        return Dr().scrollWindowMouseXPX;
      }
      function Fr() {
        return Dr().bInContainer;
      }
      function qr() {
        return Dr().bContainerFocus;
      }
      function Nr() {
        const e = Dr();
        return [e.bContextMenuOpen, e.setContextMenuOpen];
      }
      function xr(e, t) {
        const r = Dr().fnRegisterMouseEvent,
          i = (0, a.useRef)(void 0),
          n = (0, a.useCallback)(() => {
            i.current = r(e, t);
          }, [r, t, e]),
          s = (0, a.useCallback)(() => {
            i.current && i.current();
          }, []);
        (0, a.useEffect)(() => (n(), () => s()), [n, s]);
      }
      function Ur() {
        const e = Xt(),
          t = Rt(),
          r = Ft(),
          i = (0, Ue.q3)(() => !t.ShouldModeShowClipControls()),
          n = Ke(),
          { onMarkerCreated: s, onNavigateToClip: l } = Rr(),
          [o, m] = Nr();
        return a.useCallback(
          (o, c, d, u) =>
            i || n
              ? null
              : (0, Br.lX)(
                  a.createElement(jr, {
                    isCurrentPlayback: d,
                    nGlobalOffsetMS: c,
                    playbackCoordinator: t,
                    timelineView: e,
                    fnSetSelectionClipRange: r,
                    onMarkerCreated: s,
                    onNavigateToClip: l,
                    onContextMenuOpenChange: m,
                  }),
                  o,
                  u,
                ),
          [i, n, t, e, r, s, l, m],
        );
      }
      function jr(e) {
        const {
            playbackCoordinator: t,
            timelineView: r,
            nGlobalOffsetMS: i,
            fnSetSelectionClipRange: n,
            isCurrentPlayback: s,
            onMarkerCreated: l,
            onNavigateToClip: o,
            onContextMenuOpenChange: m,
          } = e,
          c = (0, Ue.q3)(() => t.GetClipsAtGlobalMS(i)),
          d = Lr(r);
        (0, a.useEffect)(() => (m(!0), () => m(!1)), [m]);
        const u = (() => {
            const { strTimelineID: e, nTimelineOffsetMS: r } =
              t.ConvertGlobalOffsetToTimelineRelativeOffset(i.valMS);
            if (!e) return null;
            const n = t.GetLoader().GetTimelineData(e);
            if (!n) return null;
            const a = tt.rJ(n.m_rgPhases, (e) => r.valMS - parseInt(e.time));
            if (a < 0) return null;
            const s = n.m_rgPhases[a];
            return r.valMS >= parseInt(s.time) &&
              r.valMS <= parseInt(s.time) + parseInt(s.duration)
              ? { strTimelineID: e, phase: s }
              : null;
          })(),
          g = (e) => r.SetPhaseToHighlight(e);
        return (
          (0, a.useEffect)(() => () => r.SetPhaseToHighlight(null), [r]),
          a.createElement(
            Tr.tz,
            { refInstance: d },
            a.createElement(
              Tr.kt,
              {
                onSelected: (e) => {
                  t.AddUserMarkerAtGlobalMS(
                    i,
                    "/GameRecording/AddMarker/TimelineCtxMenu",
                    (t, r) => {
                      l && l(t, r, e);
                    },
                  ),
                    t.SetPlaytimeFromGlobalMS(i),
                    t.FocusGlobalMS(i);
                },
                className: Er.TimelineContextMenuItem,
              },
              a.createElement(
                "div",
                { className: (0, Te.A)(Er.MenuItem, Er.AddUserMarker) },
                a.createElement(gt.pH, null),
                (0, p.we)(
                  s
                    ? "#Playback_UserSelectionControls_AddUserMarker"
                    : "#TimelineDialog_AddMarker",
                ),
              ),
            ),
            a.createElement(
              Tr.kt,
              {
                onSelected: () => {
                  const { strTimelineID: e, nTimelineOffsetMS: r } =
                    t.ConvertGlobalOffsetToTimelineRelativeOffset(i.valMS);
                  !(function (e, t, r) {
                    null != je() && je().TakeScreenshot(e, t, r.valMS);
                  })(t.GetGameID(), e, r);
                },
                className: Er.TimelineContextMenuItem,
              },
              a.createElement(
                "div",
                { className: (0, Te.A)(Er.MenuItem, Er.TakeScreenshot) },
                a.createElement(gt.i7, null),
                (0, p.we)(
                  s
                    ? "#Playback_UserSelectionControls_TakeScreenshot"
                    : "#TimelineDialog_TakeScreenshot",
                ),
              ),
            ),
            a.createElement(
              Tr.kt,
              {
                onSelected: () => {
                  n(t, De.Ov.k_EClipRangeMethod_ContextMenu, i, void 0),
                    t.SetPlaytimeFromGlobalMS(i),
                    t.FocusGlobalMS(i);
                },
                className: Er.TimelineContextMenuItem,
              },
              a.createElement(
                "div",
                { className: (0, Te.A)(Er.MenuItem, Er.StartEndClip) },
                a.createElement(gt.Nm, { direction: "left" }),
                (0, p.we)(
                  s
                    ? "#Playback_UserSelectionControls_SetClipStart"
                    : "#TimelineContext_SetClipStart",
                ),
              ),
            ),
            a.createElement(
              Tr.kt,
              {
                onSelected: () => {
                  n(t, De.Ov.k_EClipRangeMethod_ContextMenu, void 0, i),
                    t.SetPlaytimeFromGlobalMS(i),
                    t.FocusGlobalMS(i);
                },
                className: Er.TimelineContextMenuItem,
              },
              a.createElement(
                "div",
                { className: (0, Te.A)(Er.MenuItem, Er.StartEndClip) },
                a.createElement(gt.Nm, { direction: "right" }),
                (0, p.we)(
                  s
                    ? "#Playback_UserSelectionControls_SetClipEnd"
                    : "#TimelineContext_SetClipEnd",
                ),
              ),
            ),
            !!u &&
              a.createElement(
                Tr.kt,
                {
                  onSelected: () => {
                    if (!u) return;
                    const { phase: e, strTimelineID: r } = u;
                    !(function (e, t, r, i) {
                      const n = r + 1,
                        a = n + i - 2;
                      kr(
                        e,
                        void 0,
                        void 0,
                        t,
                        n,
                        t,
                        a,
                        a - n,
                        De.Ov.k_EClipRangeMethod_PhaseRecording,
                        {
                          latestRangeMethod:
                            De.Ov.k_EClipRangeMethod_PhaseRecording,
                          originalRangeMethod:
                            De.Ov.k_EClipRangeMethod_PhaseRecording,
                          relativeMS: 0,
                        },
                        {
                          latestRangeMethod:
                            De.Ov.k_EClipRangeMethod_PhaseRecording,
                          originalRangeMethod:
                            De.Ov.k_EClipRangeMethod_PhaseRecording,
                          relativeMS: 0,
                        },
                      ).create(!1);
                    })(
                      t.GetGameID(),
                      r,
                      parseInt(e.time),
                      parseInt(e.duration),
                    );
                  },
                  className: Er.TimelineContextMenuItem,
                  onMouseOver: () => g([u.strTimelineID, u.phase.time]),
                  onMouseLeave: () => g(null),
                },
                a.createElement(
                  "div",
                  { className: (0, Te.A)(Er.MenuItem, Er.ClipPhase) },
                  a.createElement(gt.O5, null),
                  (0, p.we)("#TimelineDialog_ClipPhase"),
                ),
              ),
            c.length > 0 &&
              a.createElement(
                Tr.kt,
                {
                  onSelected: () => {
                    c.length > 0 &&
                      (xe.ReportTrackedAction(
                        "/GameRecording/Tooltip/ViewClip/TimelineCtxMenu",
                      ),
                      o && o(c[0].strClipID));
                  },
                  className: Er.TimelineContextMenuItem,
                },
                a.createElement(
                  "div",
                  { className: (0, Te.A)(Er.MenuItem, Er.ViewClip) },
                  a.createElement(wr.CeX, null),
                  (0, p.we)("#TimelineDialog_ViewClip"),
                ),
              ),
          )
        );
      }
      function Lr(e) {
        const t = (0, Ue.q3)(() => e.GetAutoScrollPauseTimeout()),
          r = (0, Ue.q3)(() => e.GetVisualWindowStartPX()),
          i = (0, a.useRef)(void 0),
          n = (0, a.useRef)(void 0);
        return (
          (0, a.useEffect)(() => {
            i.current && n.current ? n.current.Hide() : (i.current = !0);
          }, [r]),
          (0, a.useEffect)(() => {
            e.SetAutoScrollPaused(!0);
          }, [e]),
          (0, a.useEffect)(() => {
            t && e.ClearAutoScrollPauseTimeout();
          }, [t, e]),
          n
        );
      }
      function Hr(e) {
        const {
            playbackCoordinator: t,
            timelineView: r,
            markerInfo: i,
            setSelectedMarker: n,
            clearRange: s,
            bLowDiskSpace: l,
            onNavigateToClip: o,
            onNavigateToScreenshot: m,
          } = e,
          c = (0, Ue.q3)(() =>
            r.ConvertGlobalMSToClipOrNone(i.nGlobalMS.valMS),
          ),
          d = (0, Ue.q3)(() =>
            t.ConvertGlobaOffsetToRecordingAndRelativeOffset(i.nGlobalMS.valMS),
          ),
          _ = Lr(r),
          f = (e) => {
            let r = Xr,
              a = Vr;
            (0, Yt.zG)(i.entry) && ((r = 0), (a = parseInt(i.entry.duration)));
            const [s, l] = t
              .GetLoader()
              .CreateGlobalRangeForTimeline(
                i.strTimelineID,
                i.nGlobalMS.valMS,
                r,
                a,
              );
            t.SetPlaytimeFromGlobalMS((0, et.Sb)(s)),
              n?.(i.entry.id, i.strTimelineID, s, l),
              xe.ReportTrackedAction(
                "/GameRecording/HighlightCtxMenu/ClipFromHighlight",
              ),
              e.stopPropagation();
          },
          h = () => {
            c &&
              (xe.ReportTrackedAction(
                `/GameRecording/MarkerCtxMenu/ViewClip/${i.entry.type}`,
              ),
              o && o(c.clipID));
          },
          S = (e) => {
            if (!(0, Yt.N$)(i.entry)) return;
            xe.ReportTrackedAction(
              `/GameRecording/HighlightCtxMenu/Marker/Edit/${i.entry.type}`,
            );
            let r = a.createElement(Cr, {
              entry: i.entry,
              playbackCoordinator: t,
              fnClearSelection: s,
              strTimelineID: i.strTimelineID,
            });
            (0, u.pg)(r, (0, g.uX)(e)), e.stopPropagation(), e.preventDefault();
          },
          b = (e) => {
            (0, Yt.N$)(i.entry) &&
              (xe.ReportTrackedAction(
                `/GameRecording/HighlightCtxMenu/Marker/Delete/${i.entry.type}`,
              ),
              t.RemoveUserMarker(i.strTimelineID, i.entry.id));
          },
          M = () => {
            (0, Yt.sX)(i.entry) &&
              i.entry?.handle &&
              (xe.ReportTrackedAction(
                "/GameRecording/HighlightCtxMenu/Screenshot",
              ),
              m(r.GetGameID(), i.entry.handle));
          };
        let y = [];
        return (
          (0, Yt.N$)(i.entry) &&
            y.push(
              a.createElement(
                Tr.kt,
                {
                  key: "edit",
                  onSelected: S,
                  className: Gr.HighlightContextMenuItem,
                },
                a.createElement(
                  "div",
                  { className: (0, Te.A)(Gr.MenuItem, Gr.EditMarker) },
                  a.createElement(gt.ff, null),
                  (0, p.we)("#Marker_Action_Edit"),
                ),
              ),
            ),
          d?.strRecordingID &&
            !l &&
            y.push(
              a.createElement(
                Tr.kt,
                {
                  key: "clip",
                  onSelected: f,
                  className: Gr.HighlightContextMenuItem,
                },
                a.createElement(
                  "div",
                  { className: (0, Te.A)(Gr.MenuItem, Gr.CreateClip) },
                  a.createElement(gt.Wd, null),
                  (0, p.we)("#TimelineDialog_ClipVideo"),
                ),
              ),
            ),
          (0, Yt.N$)(i.entry) &&
            y.push(
              a.createElement(
                Tr.kt,
                {
                  key: "delete",
                  onSelected: b,
                  className: Gr.HighlightContextMenuItem,
                },
                a.createElement(
                  "div",
                  { className: (0, Te.A)(Gr.MenuItem, Gr.DeleteMarker) },
                  a.createElement(wr.lMJ, null),
                  (0, p.we)("#Marker_Action_Delete"),
                ),
              ),
            ),
          (0, Yt.sX)(i.entry) &&
            y.push(
              a.createElement(
                Tr.kt,
                {
                  key: "view_screenshot",
                  onSelected: M,
                  className: Gr.HighlightContextMenuItem,
                },
                a.createElement(
                  "div",
                  { className: (0, Te.A)(Gr.MenuItem, Gr.ViewScreenshot) },
                  a.createElement(gt.pw, null),
                  (0, p.we)("#TimelineDialog_ViewScreenshot"),
                ),
              ),
            ),
          c &&
            h &&
            y.push(
              a.createElement(
                Tr.kt,
                {
                  key: "view_clip",
                  onSelected: h,
                  className: Gr.HighlightContextMenuItem,
                },
                a.createElement(
                  "div",
                  { className: (0, Te.A)(Gr.MenuItem, Gr.ViewClip) },
                  a.createElement(gt.ai, null),
                  (0, p.we)("#TimelineDialog_ViewClip"),
                ),
              ),
            ),
          y.length ? a.createElement(Tr.tz, { refInstance: _ }, y) : null
        );
      }
      const Xr = 5e3,
        Vr = 3e3;
      function Zr(e) {
        const {
            markerInfo: t,
            view: r,
            coordinator: i,
            gameID: n,
            clipID: s,
            timelineID: l,
            faded: o,
          } = e,
          m = t.nGlobalMS,
          c = (0, Ue.q3)(() => r.ConvertGlobalMSToGlobalPXOffset(m.valMS)),
          d = (0, Ue.q3)(() => {
            const e = r.GetThumbnailComponent();
            return e && e !== xt.Highlight;
          }),
          u = (function () {
            const e = Xt(),
              t = Rt(),
              { setSelectedMarker: r } = Dt(),
              i = Wt(),
              { onNavigateToClip: n, onNavigateToScreenshot: s } = Rr(),
              l = Ke(),
              o = (0, Ue.q3)(() => !t.ShouldModeShowClipControls());
            return a.useCallback(
              (m, c, d) => {
                if (o) return;
                const u = a.createElement(Hr, {
                  markerInfo: c,
                  playbackCoordinator: t,
                  timelineView: e,
                  setSelectedMarker: r,
                  onNavigateToClip: n,
                  onNavigateToScreenshot: s,
                  bLowDiskSpace: l,
                  clearRange: i,
                });
                (0, Br.lX)(u, m, d);
              },
              [o, l, t, e, r, n, s, i],
            );
          })(),
          { selectedMarker: p } = Dt(),
          _ =
            t.entry?.id == p?.strEntryID && t.strTimelineID == p?.strTimelineID,
          { ref: f, ...h } = (function (e, t) {
            const r = a.useRef(void 0),
              i = a.useRef(void 0),
              n = a.useCallback(
                (t) => {
                  if (!r.current) return;
                  const n = r.current.getBoundingClientRect();
                  if (t.clientY >= n.top && t.clientY <= n.bottom)
                    return n.left - t.clientX > 1 || t.clientX - n.right > 1
                      ? (e.SetThumbnailComponent(null),
                        i.current && i.current(),
                        void (i.current = null))
                      : void 0;
                  const a = n.left + 0.5 * n.width;
                  (t.clientX < a - Kr || t.clientX > a + Kr) &&
                    (e.SetThumbnailComponent(null),
                    i.current && i.current(),
                    (i.current = null));
                },
                [e],
              ),
              s = a.useCallback(
                (r) => {
                  if (
                    (e.SetThumbnailComponent(xt.Highlight),
                    e.SetThumbnailEntry(t),
                    !i.current)
                  ) {
                    const e = (0, g.uX)(r);
                    e.addEventListener("mousemove", n),
                      (i.current = () => e.removeEventListener("mousemove", n));
                  }
                  r.stopPropagation();
                },
                [n, t, e],
              ),
              l = a.useCallback(
                (t) => {
                  const n = r.current.getBoundingClientRect(),
                    a = n.left,
                    s = n.right;
                  if (t.clientX - a < 1 || s - t.clientX < 1)
                    return (
                      e.SetThumbnailComponent(null),
                      i.current && i.current(),
                      void (i.current = null)
                    );
                  (0, g.id)(r.current, t.relatedTarget) ||
                    (t.clientY - n.top > 1 &&
                      n.bottom - t.clientY > 1 &&
                      t.clientX - n.left > 1 &&
                      n.right - t.clientX > 1 &&
                      (e.SetThumbnailComponent(null),
                      i.current && i.current(),
                      (i.current = null))),
                    t.stopPropagation();
                },
                [e],
              );
            return (
              a.useEffect(() => () => i.current && i.current(), []),
              { ref: r, onMouseOver: s, onMouseLeave: l }
            );
          })(r, t),
          S = a.useCallback(
            (e) => {
              const n = m.valMS - 5e3,
                a = r.FindTimelineOffsets(l),
                s = Math.max(n, a.globalOffsetMS);
              i.SetPlaytimeFromGlobalMS((0, et.Sb)(s)),
                i.SetDisplayHighlightEntry(t.entry),
                e.stopPropagation(),
                xe.ReportTrackedAction(
                  `/GameRecording/Marker/Click/${t.entry.type}`,
                );
            },
            [i, m.valMS, l, r, t],
          ),
          b = { transform: `translateX( calc( ${c}px - 50% ))` };
        return a.createElement(
          "div",
          {
            className: (0, Te.A)(
              $t.MarkerAndDropline,
              d && $t.NoPointer,
              o && $t.Faded,
            ),
            style: b,
            ref: f,
            onContextMenu: (e) => {
              u(e, t, {
                bDisableMouseOverlay: !0,
                bForcePopup: !0,
                bAlwaysOnTop: !0,
              }),
                e.stopPropagation();
            },
            ...h,
          },
          a.createElement(
            "div",
            { key: m.valMS, className: (0, Te.A)($t.TimelineMarkerCtn) },
            a.createElement(ur, {
              classNames: $t.TimelineMarker,
              key: t.entry.id,
              entry: t.entry,
              strMarkerIcon: t.strMarkerIcon,
              faded: o,
              onClick: S,
              bSelectedMarker: _,
            }),
          ),
          a.createElement(
            "div",
            { className: $t.DroplineCtn },
            a.createElement("div", {
              className: (0, Te.A)($t.TimelineMarkerDropLine),
            }),
          ),
        );
      }
      const Kr = 150;
      function Qr(e) {
        return "achievement" === e.type ? 9e3 : e.priority;
      }
      const Jr = a.memo(function (e) {
          const t = Xt(),
            r = (0, Ue.q3)(() => t.GetVisibleTimelines());
          return a.createElement(
            a.Fragment,
            null,
            r.map((e) =>
              a.createElement(ei, { key: e.timelineID, timeline: e }),
            ),
          );
        }),
        $r = { screenshot: 0, event: 0, achievement: 1, usermarker: 2 };
      function Yr(e, t) {
        if ($r[e.type] !== $r[t.type]) return $r[t.type] - $r[e.type];
        const r = Qr(e),
          i = Qr(t);
        return r != i
          ? i - r
          : e.time != t.time
            ? parseInt(e.time) - parseInt(t.time)
            : e.id.localeCompare(t.id);
      }
      const ei = a.memo(function (e) {
        const { timeline: t } = e,
          r = Xt(),
          i = Rt(),
          n = (0, Ue.q3)(
            () => r.GetVisibleTimelineHighlights(t.timelineID) || [],
          )
            .slice()
            .sort(Yr),
          s = (0, Ue.q3)(() => r.GetTimelineOffsetMS(t.timelineID)),
          l = t.globalOffsetMS - s,
          o = i.GetGameID(),
          m = i.GetClipID(),
          c = 16 * r.GetCurrentZoomScale();
        let d = new yr(c);
        return n.map((e, n) => {
          if ("highlight" !== ti(e)) return null;
          const s = `${e.type}_${e.id}_${t.timelineID}_${n}`,
            c = (function (e, t, r) {
              if (
                ![
                  "event",
                  "usermarker",
                  "screenshot",
                  "achievement",
                  "error",
                ].includes(r.type)
              )
                return (
                  (0, ze.q_)(
                    `Unexpected timeline entry type ${r.type}, returning empty highlight marker`,
                  ),
                  null
                );
              let i = r;
              const n = (0, Yt.xz)(i),
                a = {
                  entry: i,
                  strMarkerIcon: n ? "steam_achievement" : i.icon,
                  nMarkerPriority: Qr(i),
                  strTimelineID: e,
                  strTitle: (!n && i.title) || "",
                  strDescription: (!n && i.description) || "",
                  nGlobalMS: (0, et.Sb)(parseInt(i.time) + t),
                };
              return a;
            })(t.timelineID, l, e),
            u = d.BAllowIcon(c.nGlobalMS.valMS);
          return a.createElement(Zr, {
            gameID: o,
            clipID: m,
            key: s,
            view: r,
            coordinator: i,
            faded: !u,
            timelineID: t.timelineID,
            markerInfo: c,
          });
        });
      });
      function ti(e) {
        switch (e.type) {
          case "usermarker":
          case "achievement":
          case "screenshot":
          case "error":
            return "highlight";
          case "event":
            return parseInt(e.duration) > 0 ? "range_highlight" : "highlight";
          default:
            return "none";
        }
      }
      var ri = r(53298);
      function ii(e) {
        const {
            view: t,
            entry: r,
            nGlobalEntryEndMS: i,
            nGlobalTLStartMS: n,
          } = e,
          s = Rt(),
          l = (0, et.Sb)(parseInt(r.time) + n.valMS),
          o = (0, Ue.q3)(() => {
            const e = t.ConvertGlobalMSToGlobalPXOffset(l.valMS),
              r = t.GetVirtualWindowStartPX();
            return r < e ? e : r;
          }),
          m = (0, Ue.q3)(() => {
            const e = t.ConvertGlobalMSToGlobalPXOffset(i.valMS),
              r = t.GetVirtualWindowEndPX();
            return r < e ? r : e;
          }),
          c = !!s.GetClipID(),
          d = { transform: `translateX( ${o}px )`, width: m - o },
          u = (0, Te.A)({
            [ri.Unspecified]: r.mode === Yt.il.Invalid,
            [ri.Staging]: r.mode === Yt.il.Staging,
            [ri.Menus]: r.mode === Yt.il.Menus,
            [ri.Playing]: r.mode === Yt.il.Playing,
          });
        return a.createElement("div", {
          key: r.id,
          className: (0, Te.A)(
            ri.GameModeMarker,
            u,
            c && ri.GameModeMarkerClip,
          ),
          style: d,
        });
      }
      const ni = a.memo(function (e) {
          const t = Xt(),
            r = (0, Ue.q3)(() => t.GetVisibleTimelines());
          return a.createElement(
            a.Fragment,
            null,
            r.map((e) =>
              a.createElement(ai, { key: e.timelineID, timeline: e }),
            ),
          );
        }),
        ai = a.memo(function (e) {
          const {
              timelineID: t,
              globalOffsetMS: r,
              nDurationMS: i,
            } = e.timeline,
            n = Xt(),
            s = (0, Ue.q3)(() => {
              const e = n.GetVisibleTimelineGameModes(t);
              return e && 0 !== e.length
                ? e
                : [
                    {
                      time: "0",
                      type: "gamemode",
                      mode: Yt.il.Invalid,
                      id: "synthetic",
                    },
                  ];
            }),
            l = (0, et.Sb)(r + i),
            o = r - n.GetTimelineOffsetMS(t);
          let m = [];
          for (let e = 0; e < s.length; e++) {
            const r = (0, et.Sb)(
              e < s.length - 1 ? parseInt(s[e + 1].time) + o : l.valMS - 1,
            );
            m.push(
              a.createElement(ii, {
                key: `gameMode_${t}_${e}`,
                view: n,
                entry: s[e],
                nGlobalEntryEndMS: r,
                nGlobalTLStartMS: (0, et.Sb)(o),
              }),
            );
          }
          return a.createElement(a.Fragment, null, m);
        });
      var si = r(36616),
        li = r(5540);
      const oi = (0, a.memo)(function (e) {
        const t = Rt(),
          r = (0, Ue.q3)(() => t.GetHidePlayer()),
          [i, n] = (0, a.useState)({ bDragActive: !1, bPausedOnDragStart: !1 }),
          s = Xt(),
          l = (0, Ue.q3)(() => {
            if (
              s.GetAutoScrollPaused() ||
              s.BReachedMaxScroll() ||
              s.BReachedMinScroll() ||
              t.BIsVideoElementPaused()
            )
              return !1;
            const e = t.GetGlobalMSPlaytime();
            return (
              s.ConvertGlobalMSToGlobalPXOffset(e.valMS) <
              s.GetMaxScrollLeftPX() + 0.5 * s.GetScrollWindowWidth()
            );
          });
        return r
          ? a.createElement(ci, { setDragActive: n })
          : l
            ? a.createElement(mi, { view: s, setDragActive: n })
            : a.createElement(di, { dragState: i, setDragActive: n });
      });
      function mi(e) {
        const { view: t, setDragActive: r } = e,
          i = (0, Ue.q3)(
            () => t.GetVisualWindowStartPX() + t.GetScrollWindowWidth() / 2,
          );
        return a.createElement(
          _i,
          { playheadPosition: i },
          a.createElement(ui, { setDragActive: r, bDragActive: !1 }),
        );
      }
      const ci = (0, a.memo)(function (e) {
          const { setDragActive: t } = e,
            r = Xt(),
            i = (0, Ue.q3)(() => r.GetScrollableWidthPX()),
            n = (0, j._g)(100),
            s = (0, a.useCallback)(
              (e) => {
                r.GetAutoScrollPaused() || n(() => r.ScrollToOffset(e));
              },
              [n, r],
            );
          return (
            (0, a.useEffect)(() => r.ScrollToEnd(), [r]),
            (0, a.useEffect)(() => s(i), [i, s]),
            a.createElement(
              _i,
              { playheadPosition: i },
              a.createElement(ui, { setDragActive: t, bDragActive: !1 }),
            )
          );
        }),
        di = (0, a.memo)(function (e) {
          const { dragState: t, setDragActive: r } = e,
            { bDragActive: i, bPausedOnDragStart: n } = t,
            s = Rt(),
            l = Xt(),
            o = Ar(),
            m = (function (e, t, r, i, n) {
              const s = (0, a.useRef)(void 0),
                l = (0, Ue.q3)(() => t.GetScrollableWidthPX()),
                o = (0, Ue.q3)(() => t.GetScrollWindowWidth()),
                [m, c] = (0, a.useState)(0),
                d = (0, a.useRef)(void 0),
                u = (0, a.useRef)(void 0),
                { clearPlaybackAnimation: g, startPlaybackAnimation: p } =
                  (function (e, t, r) {
                    const i = (0, a.useRef)(void 0),
                      n = e.GetGameRecordingVideo(),
                      s = (0, a.useRef)(void 0),
                      l = (0, a.useRef)(void 0),
                      o = (0, a.useRef)(void 0),
                      m = (0, a.useRef)(void 0),
                      c = (0, a.useCallback)(() => {
                        if (!i.current) return;
                        const a = e.GetGlobalMSPlaytime();
                        if (a.valMS >= 0) {
                          const e = n.BVideoElementPlaying(),
                            i = n.GetVideoElementCurrentTime(),
                            c = t.GetScrollableWidthPX(),
                            d = t.GetCurrentZoomScale();
                          if (
                            s.current !== a.valMS ||
                            (m.current && m.current != d)
                          ) {
                            const e = t.ConvertGlobalMSToGlobalPXOffset(
                                a.valMS,
                              ),
                              i = Math.min(c, e);
                            r(i), (o.current = i);
                          } else if (
                            s.current &&
                            s.current === a.valMS &&
                            i &&
                            l.current &&
                            l.current !== i &&
                            e
                          ) {
                            const e = s.current + 1e3 * (i - l.current),
                              n = t.ConvertGlobalMSToGlobalPXOffset(e);
                            if (o.current && o.current < n) {
                              const e = Math.min(c, n);
                              r(e);
                            }
                            o.current = n;
                          }
                          e || ((l.current = null), (s.current = a.valMS)),
                            e &&
                              s.current !== a.valMS &&
                              ((l.current = i), (s.current = a.valMS)),
                            (m.current = d);
                        }
                        i.current = requestAnimationFrame(c);
                      }, [e, r, t, n]),
                      d = (0, a.useCallback)(() => {
                        i.current && cancelAnimationFrame(i.current),
                          (i.current = null),
                          (s.current = null),
                          (l.current = null),
                          (o.current = null);
                      }, []),
                      u = (0, a.useCallback)(() => {
                        i.current || (i.current = requestAnimationFrame(c));
                      }, [c]);
                    return {
                      clearPlaybackAnimation: d,
                      startPlaybackAnimation: u,
                    };
                  })(n, t, c);
              (0, a.useEffect)(
                () => () => {
                  d.current &&
                    (cancelAnimationFrame(d.current),
                    (d.current = null),
                    (u.current = null)),
                    g();
                },
                [g],
              );
              const _ = a.useCallback(
                (e, t, r, i, n) => {
                  if (n(t))
                    c(
                      (0, Ye.OQ)(
                        t.GetVisualWindowStartPX() + r,
                        0,
                        t.GetScrollableWidthPX(),
                      ),
                    ),
                      cancelAnimationFrame(d.current),
                      (d.current = null),
                      (u.current = null);
                  else {
                    if (
                      (d.current &&
                        (d.current = requestAnimationFrame((e) =>
                          _(e, t, r, i, n),
                        )),
                      u.current)
                    ) {
                      const r = ((e - u.current) / 500) * i;
                      t.ScrollBy(r),
                        c((e) =>
                          (0, Ye.OQ)(e + r, 0, t.GetScrollableWidthPX()),
                        );
                    }
                    u.current = e;
                  }
                },
                [c],
              );
              return (
                (0, a.useEffect)(() => {
                  const n = o * (1 - Hn),
                    a = o * Hn;
                  if (
                    (d.current &&
                      (cancelAnimationFrame(d.current),
                      (d.current = null),
                      (u.current = null)),
                    r)
                  )
                    if ((g(), e.valPX < a && !t.BReachedMinScroll())) {
                      if (e.valPX <= s.current) {
                        const r = e.valPX - a,
                          i = (0, Ye.OQ)(Math.abs(r / a), 0, 1) * r;
                        d.current = requestAnimationFrame((r) =>
                          _(r, t, e.valPX, i, t.BReachedMinScroll),
                        );
                      }
                      s.current = e.valPX;
                    } else if (e.valPX > n && !t.BReachedMaxScroll()) {
                      if (e.valPX >= s.current) {
                        const r = e.valPX - n,
                          i = (0, Ye.OQ)(Math.abs(r / (o - n)), 0, 1) * r;
                        d.current = requestAnimationFrame((r) =>
                          _(r, t, e.valPX, i, t.BReachedMaxScroll),
                        );
                      }
                      s.current = e.valPX;
                    } else c((0, Ye.OQ)(i.valPX, 0, l));
                  else p();
                }, [r, g, i.valPX, o, l, _, e.valPX, p, t]),
                m
              );
            })(Wr(), l, i, o, s);
          return (
            (0, a.useEffect)(() => {
              if (!i) return;
              l.SetThumbnailPosition(m);
              const e = l.ConvertPXOffsetToGlobalMS(m, !1);
              if (!e) return;
              const t = s.GetLiveEdgeMS();
              s.SetPlaytimeFromGlobalMS(
                t.valMS < e ? t : (0, et.Sb)(e),
                n,
                !0,
                !0,
              );
            }, [m, n, i, s, l]),
            a.createElement(
              "div",
              {
                className: (0, Te.A)(
                  li.PlayheadInteractionCtn,
                  i && li.ActiveCtn,
                ),
              },
              a.createElement(
                _i,
                { className: i ? li.Active : void 0, playheadPosition: m },
                a.createElement(ui, { setDragActive: r, bDragActive: i }),
              ),
            )
          );
        }),
        ui = (0, a.memo)(function (e) {
          const { setDragActive: t, bDragActive: r } = e,
            i = Xt(),
            n = (e) => {
              r || i.SetThumbnailComponent(xt.Playhead), e.stopPropagation();
            },
            s = (e) => {
              r || i.SetThumbnailComponent(null), e.stopPropagation();
            };
          return a.createElement(
            "div",
            {
              className: li.PlayHeadContent,
              onMouseOver: n,
              onMouseOut: s,
              onFocus: n,
              onBlur: s,
            },
            a.createElement(gi, { setDragActive: t }),
          );
        }),
        gi = a.memo(function (e) {
          const { setDragActive: t } = e,
            r = Rt(),
            i = Ur(),
            n = Xt(),
            s = (0, Ue.q3)(() => {
              const e = n.GetThumbnailComponent();
              return e === xt.RangeLeft || e === xt.RangeRight;
            }),
            l = (0, a.useCallback)(
              (e) => {
                if (0 != e.button) return;
                const i = (0, g.uX)(e);
                let a, s;
                const l = () => {
                  const e = r.GetGameRecordingVideo().IsPaused();
                  t({ bDragActive: !0, bPausedOnDragStart: e }),
                    n.SetThumbnailComponent(xt.Playhead),
                    a();
                };
                i.addEventListener("mousemove", l),
                  (a = () => i.removeEventListener("mousemove", l));
                const o = () => {
                  t({ bDragActive: !1, bPausedOnDragStart: !1 }),
                    n.SetThumbnailComponent(null),
                    a(),
                    s();
                };
                i.addEventListener("mouseup", o),
                  (s = () => i.removeEventListener("mouseup", o));
              },
              [r, t, n],
            ),
            o = (0, a.useCallback)(
              (e) => {
                const t = r.GetGlobalMSPlaytime();
                i(e, t, !0, {
                  bDisableMouseOverlay: !0,
                  bForcePopup: !0,
                  bAlwaysOnTop: !0,
                }),
                  e.stopPropagation(),
                  e.preventDefault();
              },
              [r, i],
            );
          return a.createElement(
            "div",
            {
              className: (0, Te.A)(li.PlayHead, s && li.NoPointer),
              onMouseDown: l,
              onContextMenu: o,
            },
            a.createElement(pi, null),
          );
        });
      function pi(e) {
        return a.createElement(
          "svg",
          {
            ...e,
            width: "12",
            height: "32",
            viewBox: "0 0 12 24",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          a.createElement("rect", {
            x: "5",
            y: "4",
            width: "2",
            height: "40",
            fill: "currentColor",
          }),
          a.createElement("path", {
            d: "M6 6L0.803849 -9.78799e-07L11.1962 -7.02746e-08L6 6Z",
            fill: "currentColor",
          }),
        );
      }
      function _i(e) {
        const { className: t, playheadPosition: r, children: i } = e;
        return a.createElement(
          "div",
          {
            className: (0, Te.A)(li.PlayHeadContainer, t),
            style: { transform: `translateX( calc(${r}px - 50% ))` },
          },
          i,
        );
      }
      var fi = r(48419),
        hi = r(4434);
      class Si {
        k_QueueWaitUntilRequestMS = 10;
        k_nMaxBatchSize = 50;
        m_nMaxCacheSize = 18e5 / $e.kh;
        m_LRUTrackerSet = new Set();
        m_mapPromises = new Map();
        m_mapThumbnailImages = new Map();
        m_rgPendingRequest = new Array();
        m_PendingInfoPromise;
        m_PendingInfoResolve = void 0;
        m_PendingTimer = void 0;
        k_AlreadyResolvedOK = Promise.resolve(!0);
        m_rgThumbnailPerf = [];
        constructor() {
          (0, Oe.Gn)(this);
        }
        AddPerfMeasure(e) {
          this.m_rgThumbnailPerf.push(e);
        }
        GetPerfMeasures() {
          if (!this.m_rgThumbnailPerf.length) return null;
          const e = this.m_rgThumbnailPerf.length,
            t = this.m_rgThumbnailPerf.reduce((e, t) => e + t) / e,
            r = Math.sqrt(
              this.m_rgThumbnailPerf
                .map((e) => Math.pow(e - t, 2))
                .reduce((e, t) => e + t) / e,
            ),
            i = Math.max(...this.m_rgThumbnailPerf),
            n = Math.min(...this.m_rgThumbnailPerf);
          return {
            nMean: t,
            nStdDev: r,
            nMax: i,
            nMin: n,
            nLength: e,
            nLastVal: this.m_rgThumbnailPerf[e - 1],
          };
        }
        GetKey(e, t, r, i, n, a, s) {
          const l = n + i;
          return `${e}_${t}_${r}_${s ? l : l - (l % $e.kh)}_${a}_${s}`;
        }
        GetThumbnailData(e) {
          const t = this.m_mapThumbnailImages.get(e);
          return (
            t &&
              (this.m_LRUTrackerSet.has(e) && this.m_LRUTrackerSet.delete(e),
              this.m_LRUTrackerSet.add(e)),
            t
          );
        }
        SetThumbnailData(e, t) {
          if (
            (this.m_LRUTrackerSet.has(e) && this.m_LRUTrackerSet.delete(e),
            this.m_LRUTrackerSet.add(e),
            this.m_mapThumbnailImages.set(e, t),
            this.m_LRUTrackerSet.size >= this.m_nMaxCacheSize)
          ) {
            const e = this.m_LRUTrackerSet.keys().next().value;
            this.m_LRUTrackerSet.delete(e), this.m_mapThumbnailImages.delete(e);
          }
        }
        ClearThumbnailData() {
          this.m_LRUTrackerSet.clear(), this.m_mapThumbnailImages.clear();
        }
        GetThumbnail(e, t, r, i, n, a, s) {
          if (!t) return;
          const l = this.GetKey(e, t, r, i, n, a, s);
          return this.GetThumbnailData(l);
        }
        GetOrQueueThumbnail(e, t, r, i, n, a, s) {
          if (!t) return;
          const l = this.GetKey(e, t, r, i, n, a, s);
          let o = this.GetThumbnailData(l);
          if (!o) {
            let m = `thumbnail_${e}_${a}_${s}`;
            performance.mark(m),
              this.QueueThumbnailRequest(e, t, r, i, n, a, s).then(() => {
                try {
                  const e = performance.measure(`measure_${m}`, m);
                  e && Si.Get().AddPerfMeasure(e.duration);
                } catch (e) {
                  (0, ze.q_)(
                    `CThumbnailCache:: cant measure ${m}, error: ${e}`,
                  );
                }
              }),
              (o = this.GetThumbnailData(l));
          }
          return o;
        }
        QueueThumbnailRequest(e, t, r, i, n, a, s) {
          const l = this.GetKey(e, t, r, i, n, a, s),
            o = this.GetThumbnailData(l);
          if (o && (o.data || o.bIsLoading)) return this.k_AlreadyResolvedOK;
          this.SetThumbnailData(l, { data: null, bIsLoading: !0 }),
            this.m_PendingInfoPromise &&
              (this.m_rgPendingRequest[0].strRecordingID != t ||
                this.m_rgPendingRequest.length > this.k_nMaxBatchSize) &&
              (this.m_PendingTimer && window.clearTimeout(this.m_PendingTimer),
              this.FlushPendingInfo()),
            (this.m_PendingInfoPromise &&
              this.m_rgPendingRequest[0].strRecordingID == t) ||
              ((this.m_PendingInfoPromise = new Promise(
                (e) => (this.m_PendingInfoResolve = e),
              )),
              (this.m_PendingTimer = window.setTimeout(
                () => this.FlushPendingInfo(),
                this.k_QueueWaitUntilRequestMS,
              )));
          const m = {
            gameID: e,
            strRecordingID: t,
            strClipID: r,
            nRecordingOffsetMS: i,
            nRecordingStartOffsetMS: n,
            cPxMajorAxis: a,
            bPreciseTiming: s,
          };
          return (
            this.m_rgPendingRequest.some((e) => {
              return (
                (r = m),
                (t = e).strRecordingID === r.strRecordingID &&
                  t.strClipID === r.strClipID &&
                  t.nRecordingOffsetMS === r.nRecordingOffsetMS &&
                  t.nRecordingStartOffsetMS === r.nRecordingStartOffsetMS &&
                  t.cPxMajorAxis === r.cPxMajorAxis &&
                  t.bPreciseTiming == r.bPreciseTiming
              );
              var t, r;
            }) ||
              (this.m_rgPendingRequest.push(m),
              this.m_mapPromises.set(l, this.m_PendingInfoPromise)),
            this.m_PendingInfoPromise
          );
        }
        async FlushPendingInfo() {
          if (void 0 === this.m_PendingInfoResolve) return;
          const e = this.m_PendingInfoResolve,
            t = this.m_rgPendingRequest;
          (this.m_PendingInfoPromise = void 0),
            (this.m_PendingInfoResolve = void 0),
            (this.m_rgPendingRequest = []),
            (this.m_PendingTimer = void 0),
            await this.InternalLoadMultipleThumbnails(t),
            e();
        }
        async InternalLoadMultipleThumbnails(e) {
          e.sort((e, t) => e.nRecordingOffsetMS - t.nRecordingOffsetMS);
          try {
            const t = e.map((e) => 1e3 * e.nRecordingOffsetMS),
              r = await Xe(
                e[0].strRecordingID,
                e[0].strClipID,
                void 0,
                t,
                e[0].cPxMajorAxis,
                e[0].bPreciseTiming,
              );
            (0, q.wT)(
              r?.length == t.length,
              `CThumbnailCache.InternalLoadMultipleThumbnails request ${t.length} and got back ${r?.length}`,
            );
            for (let i = 0; i < t.length && i < r?.length; ++i) {
              const t = e[i],
                n = this.GetKey(
                  t.gameID,
                  t.strRecordingID,
                  t.strClipID,
                  t.nRecordingOffsetMS,
                  t.nRecordingStartOffsetMS,
                  t.cPxMajorAxis,
                  t.bPreciseTiming,
                );
              let a = r ? r[i].image_data() : null;
              this.SetThumbnailData(n, { data: a, bIsLoading: !1 });
            }
          } catch (t) {
            (0, ze.ZI)("Failed to load multiple request thumbnails", t);
            for (let t = 0; t < e.length; ++t) {
              const r = e[t],
                i = this.GetKey(
                  r.gameID,
                  r.strRecordingID,
                  r.strClipID,
                  r.nRecordingOffsetMS,
                  r.nRecordingStartOffsetMS,
                  r.cPxMajorAxis,
                  e[0].bPreciseTiming,
                );
              this.SetThumbnailData(i, { data: null, bIsLoading: !1 });
            }
          }
        }
        async LoadThumbnail(e, t, r, i, n, a, s) {
          const l = this.GetKey(e, t, r, i, n, a, s),
            o = this.GetThumbnailData(l);
          return (
            !(!o || !o.data) ||
            (this.m_mapPromises.has(l) ||
              this.m_mapPromises.set(
                l,
                this.InternalLoadThumbnail(e, t, r, i, n, a, s),
              ),
            this.m_mapPromises.get(l))
          );
        }
        async InternalLoadThumbnail(e, t, r, i, n, a, s) {
          const l = this.GetKey(e, t, r, i, n, a, s);
          try {
            const e = await Xe(t, r, void 0, [1e3 * i], a, s);
            if (e?.length > 0) {
              let t = e ? e[0].image_data() : null;
              return this.SetThumbnailData(l, { data: t, bIsLoading: !1 }), !0;
            }
            (0, ze.tH)(
              `ThumbnailImage: got empty jpeg ${e.length} list back ${t} @ ${i}`,
            );
          } catch (e) {
            (0, ze.ZI)(
              `ThumbnailImage: Fail to load thumbnail ${t} @ ${i} with ${e}`,
            ),
              this.SetThumbnailData(l, { data: null, bIsLoading: !1 });
          }
          return !1;
        }
        static s_Singleton;
        static Get() {
          return (
            Si.s_Singleton ||
              ((Si.s_Singleton = new Si()),
              "dev" == er.TS.WEB_UNIVERSE &&
                (window.g_ThumbnailCache = Si.s_Singleton)),
            Si.s_Singleton
          );
        }
      }
      function bi(e, t, r, i, n, s, l) {
        const o = (0, Ue.q3)(() =>
          Si.Get().GetOrQueueThumbnail(e, r, t, i, n, s, l),
        );
        return (function (e) {
          const t = (0, a.useRef)(null),
            r = (0, j.CH)(),
            i = (0, hi.m)("useThumbnailAsURL");
          return (
            (0, a.useEffect)(() => {
              if (e && !i?.token?.reason) {
                const i = new Blob([e], { type: "image/jpeg" }),
                  n = URL.createObjectURL(i);
                (t.current = n), r();
              }
              return () => {
                t.current &&
                  (URL.revokeObjectURL(t.current), (t.current = void 0));
              };
            }, [i?.token?.reason, e, r]),
            t.current
          );
        })(o?.data);
      }
      (0, W.Cg)([Oe.sH], Si.prototype, "m_mapThumbnailImages", void 0);
      var Mi = r(91675);
      const yi = parseInt(fi.thumbnailWidth),
        Ti = a.forwardRef(function (e, t) {
          const {
              globalMS: r,
              children: i,
              imgClassName: n,
              className: s,
              ...l
            } = e,
            o = Rt(),
            m = o.GetGameID(),
            c = o.GetClipID(),
            d = (0, Ue.q3)(() => o.GetRecordingMode()),
            u = (0, Ue.q3)(() =>
              o.ConvertGlobaOffsetToRecordingAndRelativeOffset(r),
            ),
            g = (At(), u?.nRecordingOffsetMS),
            _ = bi(m, c, u?.strRecordingID, g, u?.nStartOffsetMS, yi, false),
            [f, h] = (0, a.useState)();
          return (
            (0, a.useEffect)(() => {
              _ && h(_);
            }, [_]),
            a.createElement(
              "div",
              {
                ref: t,
                className: (0, Te.A)(fi.ThumbnailContainerOffset, fi[d], s),
                ...l,
              },
              a.createElement(
                "div",
                {
                  className: (0, Te.A)(
                    fi.ThumbnailContents,
                    u?.strRecordingID && !f && fi.Hide,
                    fi[d],
                  ),
                },
                a.createElement(
                  "div",
                  { className: fi.ImageAndInfoBoxContainer },
                  a.createElement(
                    "div",
                    { className: fi.ImageContainer },
                    u?.strRecordingID
                      ? a.createElement("img", {
                          className: fi.ThumbnailImage,
                          src: f,
                        })
                      : a.createElement(
                          "div",
                          { className: fi.NoRecordedContent },
                          (0, p.we)("#GameRecording_PlayerNoContent"),
                        ),
                    a.createElement(Bi, null),
                  ),
                ),
                a.createElement(
                  "div",
                  { className: (0, Te.A)(fi.TooltipChildren) },
                  i,
                ),
              ),
              a.createElement("div", {
                className: (0, Te.A)(fi.ThumbnailHitBoxPadding),
              }),
            )
          );
        });
      function Bi() {
        const e = Xt(),
          t = (0, Ue.q3)(() => e.GetGameID()),
          r = (0, Ue.q3)(() => e.GetThumbnailComponent()),
          i = (0, Ue.q3)(() => e.GetThumbnailEntry());
        if (!i || r !== xt.Highlight) return null;
        if ((0, Yt.xz)(i.entry))
          return a.createElement(vi, {
            thumbnailEntry: i,
            achievementEntry: i.entry,
            strGameID: t,
          });
        let n = "",
          s = "";
        return (
          (0, Yt.In)(i.entry)
            ? (s =
                (0, p.we)(i.entry.description) || "#GameRecording_UnknownError")
            : (0, Yt.N$)(i.entry)
              ? ((n = i.entry.title
                  ? i.entry.title
                  : (0, p.we)("#Marker_UserMarker_Title")),
                (s = i.entry.description || ""))
              : (0, Yt.eJ)(i.entry) &&
                ((n = i.entry.title || ""), (s = i.entry.description || "")),
          n || s
            ? a.createElement(Ri, {
                title: n,
                description: s,
                thumbnailEntry: i,
              })
            : null
        );
      }
      function vi(e) {
        const { strGameID: t, thumbnailEntry: r, achievementEntry: i } = e,
          n = Ze(new cr.VS(t).GetAppID(), i.achievement_name);
        return n
          ? a.createElement(Ri, {
              title: n.name ?? "",
              description: n.description ?? "",
              thumbnailEntry: r,
            })
          : null;
      }
      function Ri(e) {
        const { title: t, description: r, thumbnailEntry: i } = e;
        return a.createElement(
          "div",
          { className: fi.InfoBoxContainer },
          a.createElement(
            "div",
            { className: fi.Header },
            a.createElement(
              "div",
              { className: fi.Icon },
              a.createElement(gr, {
                entry: i.entry,
                strMarkerIcon: i.strMarkerIcon,
              }),
            ),
            t && a.createElement("div", { className: fi.Title }, t),
          ),
          a.createElement(
            "div",
            { className: fi.DescriptionBlock },
            r && a.createElement("div", { className: fi.Description }, r),
          ),
        );
      }
      const Gi = a.forwardRef(function (e, t) {
        const { globalPX: r, onMouseEnter: i, onMouseLeave: n } = e,
          s = Xt(),
          l = (0, Ue.q3)(() => s.ConvertPXOffsetToGlobalMS(r, !1)),
          o = (0, Ue.q3)(() => s.GetThumbnailComponent()),
          m = Rt(),
          c = (0, Ue.q3)(() => m.GetRecordingMode());
        return a.createElement(
          Ti,
          {
            className: (0, Te.A)(fi.ThumbnailTooltip, fi[c], fi[o]),
            globalMS: l,
            ref: t,
            onMouseEnter: i,
            onMouseLeave: n,
          },
          a.createElement(Ei, { globalMS: l }),
          a.createElement(wi, { globalMS: l }),
          a.createElement(
            "div",
            { className: fi.TooltipInteractionRegion },
            o === xt.Highlight
              ? a.createElement(Ii, null)
              : a.createElement(ki, { globalPX: r }),
            a.createElement(Pi, { globalMS: l }),
          ),
        );
      });
      function wi(e) {
        const { globalMS: t } = e,
          r = Xt(),
          i = (0, Ue.q3)(() => r.GetStateDescriptionAtGlobalMS(t));
        return i?.title
          ? a.createElement("div", { className: fi.StateDescription }, i.title)
          : null;
      }
      function Ci(e, t) {
        return e.priority - t.priority;
      }
      function Ei(e) {
        const { globalMS: t } = e,
          { setSelectedMarker: r } = Dt(),
          i = Xt(),
          n = Rt(),
          s = (0, Ue.q3)(() => i.FindRangeEventsAtGlobalMS(t)),
          l = s.length > 3 ? s.sort(Ci).slice(0, 3) : s;
        return a.createElement(
          a.Fragment,
          null,
          l.map((e, i) =>
            a.createElement(
              "div",
              {
                key: `${e.time}_${i}`,
                className: fi.TooltipRangeContainer,
                onClick: (i) =>
                  ((e, i) => {
                    const a = parseInt(i.duration),
                      { nTimelineOffsetMS: s, strTimelineID: l } =
                        n.ConvertGlobalOffsetToTimelineRelativeOffset(t),
                      o = t - s.valMS + parseInt(i.time),
                      [m, c] = n
                        .GetLoader()
                        .CreateGlobalRangeForTimeline(l, o, 0, a);
                    n.SetPlaytimeFromGlobalMS((0, et.Sb)(m)),
                      r?.(i.id, l, m, c),
                      xe.ReportTrackedAction(
                        "/GameRecording/Tooltip/ClipFromRangeEvent",
                      ),
                      e.stopPropagation();
                  })(i, e),
              },
              e.icon &&
                a.createElement(br, {
                  gameID: n.GetGameID(),
                  icon: e.icon,
                  className: fi.RangeIcon,
                }),
              a.createElement("div", { className: fi.Title }, e.title),
              a.createElement(
                "div",
                { className: fi.Duration },
                (0, Mi.qZ)(parseInt(e.duration) / 1e3, !1),
              ),
            ),
          ),
        );
      }
      function Ii() {
        const e = Rt(),
          t = (0, Ue.q3)(() => e.GetRecordingMode()),
          r = Xt(),
          i = (0, Ue.q3)(() => r.GetThumbnailEntry());
        if (!i) return null;
        const n = r.GetTimelineOffsetMS(i.strTimelineID),
          s = parseInt(i.entry.time),
          l = (0, et.sK)(s - n),
          o = e.MakeRelativeToTimelineEndIfActive(i.strTimelineID, l.valMS);
        let m = "";
        if ((0, Yt.zG)(i.entry)) {
          const e = o + parseInt(i.entry.duration);
          if (o < 0) {
            const t = (0, Mi.qZ)(Math.abs(o / 1e3), !1, !1),
              r = (0, Mi.qZ)(Math.abs(e / 1e3), !1, !1);
            m = (0, p.we)("#Duration_WrittenNegation", t + " - " + r);
          } else {
            m =
              (0, Mi.qZ)(o / 1e3, !1, !1) + " - " + (0, Mi.qZ)(e / 1e3, !1, !1);
          }
        } else m = (0, Mi.qZ)(o / 1e3, !1, !0);
        return a.createElement(
          "div",
          {
            className: (0, Te.A)(fi.TimeDisplayContainer, fi.Highlight, fi[t]),
          },
          m,
        );
      }
      function ki(e) {
        const { globalPX: t } = e,
          r = Xt(),
          i = (0, Ue.q3)(() =>
            r.ConvertPXToTimelineRelativeMS(t, "end-if-active"),
          );
        return Boolean(i)
          ? a.createElement(
              "div",
              { className: fi.TimeDisplayContainer },
              (0, Mi.qZ)(i / 1e3, !1, !0),
            )
          : null;
      }
      function Pi(e) {
        const { globalMS: t } = e,
          r = Xt(),
          i = (0, Ue.q3)(() => r.GetGameID()),
          n = (0, Ue.q3)(() => r.GetThumbnailComponent()),
          s = (0, Ue.q3)(() => r.GetThumbnailEntry());
        let l = [
          a.createElement(Fi, { key: "add_marker", globalMS: t }),
          a.createElement(qi, { key: "view_clip", globalMS: t }),
        ];
        return (
          n == xt.Highlight &&
            s &&
            ((0, Yt.In)(s.entry) || (0, Yt.xz)(s.entry) || (0, Yt.eJ)(s.entry)
              ? (l = [
                  a.createElement(Oi, {
                    key: "create_marker_clip",
                    markerInfo: s,
                  }),
                  a.createElement(zi, { key: "view_clip", markerInfo: s }),
                ])
              : (0, Yt.sX)(s.entry)
                ? (l = [
                    a.createElement(Oi, {
                      key: "create_marker_clip",
                      markerInfo: s,
                    }),
                    a.createElement(Wi, {
                      key: "view_screen",
                      entry: s.entry,
                      gameID: i,
                    }),
                    a.createElement(zi, { key: "view_clip", markerInfo: s }),
                  ])
                : (0, Yt.N$)(s.entry) &&
                  (l = [
                    a.createElement(Ai, { key: "edit_user", markerInfo: s }),
                    a.createElement(Oi, {
                      key: "create_marker_clip",
                      markerInfo: s,
                    }),
                    a.createElement(Di, { key: "delete_user", markerInfo: s }),
                    a.createElement(zi, { key: "view_clip", markerInfo: s }),
                  ])),
          a.createElement("div", { className: fi.TooltipButtons }, l)
        );
      }
      function Oi(e) {
        const { setSelectedMarker: t } = Dt(),
          { markerInfo: r } = e,
          i = Rt(),
          n = (0, Ue.q3)(() => i.ShouldModeShowClipControls()),
          s = (0, Ue.q3)(() =>
            i.ConvertGlobaOffsetToRecordingAndRelativeOffset(r.nGlobalMS.valMS),
          ),
          l = Ke(),
          o = qt();
        return s?.strRecordingID && n
          ? a.createElement(
              ie.he,
              {
                toolTipContent: (0, p.we)(
                  l
                    ? "#RecordingState_Clip_LowDiskSpace"
                    : "#TimelineDialog_ClipVideo",
                ),
                direction: "top",
                bTopmost: !0,
              },
              a.createElement(
                "div",
                {
                  className: (0, Te.A)(fi.Button, fi.CreateClipButton),
                  onClick: (e) => {
                    let n = Xr,
                      a = Vr;
                    (0, Yt.zG)(r.entry) &&
                      ((n = 0), (a = parseInt(r.entry.duration)));
                    const [s, l] = i
                      .GetLoader()
                      .CreateGlobalRangeForTimeline(
                        r.strTimelineID,
                        r.nGlobalMS.valMS,
                        n,
                        a,
                      );
                    i.SetPlaytimeFromGlobalMS((0, et.Sb)(s)),
                      t?.(r.entry.id, r.strTimelineID, s, l),
                      o(),
                      xe.ReportTrackedAction(
                        "/GameRecording/Tooltip/ClipFromHighlight",
                      ),
                      e.stopPropagation();
                  },
                },
                a.createElement(gt.Wd, null),
              ),
            )
          : null;
      }
      function zi(e) {
        const { markerInfo: t } = e,
          r = Xt(),
          i = (0, Ue.q3)(() =>
            r.ConvertGlobalMSToClipOrNone(t.nGlobalMS.valMS),
          ),
          { onNavigateToClip: n } = Rr();
        return i
          ? a.createElement(
              ie.he,
              {
                toolTipContent: (0, p.we)("#TimelineDialog_ViewClip"),
                direction: "top",
                bTopmost: !0,
              },
              a.createElement(
                "div",
                {
                  className: (0, Te.A)(fi.Button, fi.GoToClipFromMarker),
                  onClick: () => {
                    i &&
                      (xe.ReportTrackedAction(
                        `/GameRecording/Tooltip/ViewClip/${t.entry.type}`,
                      ),
                      n(i.clipID));
                  },
                },
                a.createElement(wr.CeX, null),
              ),
            )
          : null;
      }
      function Di(e) {
        const { markerInfo: t } = e,
          r = Rt(),
          i = Xt();
        return a.createElement(
          ie.he,
          {
            toolTipContent: (0, p.we)("#Marker_Action_Delete"),
            direction: "top",
            bTopmost: !0,
          },
          a.createElement(
            "div",
            {
              className: (0, Te.A)(fi.Button, fi.DeleteMarker),
              onClick: (e) => {
                (0, Yt.N$)(t.entry) &&
                  (xe.ReportTrackedAction(
                    `/GameRecording/Marker/Delete/${t.entry.type}`,
                  ),
                  r.RemoveUserMarker(t.strTimelineID, t.entry.id),
                  i.SetThumbnailComponent(null));
              },
            },
            a.createElement(wr.lMJ, null),
          ),
        );
      }
      function Ai(e) {
        const { markerInfo: t } = e,
          r = Rt(),
          i = Wt();
        return a.createElement(
          ie.he,
          {
            toolTipContent: (0, p.we)("#Marker_Action_Edit"),
            direction: "top",
            bTopmost: !0,
          },
          a.createElement(
            "div",
            {
              className: (0, Te.A)(fi.Button, fi.EditMarker),
              onClick: (e) => {
                if (!(0, Yt.N$)(t.entry)) return;
                xe.ReportTrackedAction(
                  `/GameRecording/Marker/Edit/${t.entry.type}`,
                );
                let n = a.createElement(Cr, {
                  entry: t.entry,
                  playbackCoordinator: r,
                  fnClearSelection: i,
                  strTimelineID: t.strTimelineID,
                });
                (0, u.pg)(n, (0, g.uX)(e)),
                  e.stopPropagation(),
                  e.preventDefault();
              },
            },
            a.createElement(gt.ff, null),
          ),
        );
      }
      function Wi(e) {
        const { entry: t, gameID: r } = e,
          i = t.handle,
          { onNavigateToScreenshot: n } = Rr();
        return a.createElement(
          ie.he,
          {
            toolTipContent: (0, p.we)("#TimelineDialog_ViewScreenshot"),
            direction: "top",
            bTopmost: !0,
          },
          a.createElement(
            "div",
            {
              className: (0, Te.A)(fi.Button, fi.ViewScreenshot),
              onClick: () => {
                i &&
                  (xe.ReportTrackedAction("/GameRecording/Tooltip/Screenshot"),
                  n(r, i));
              },
            },
            a.createElement(gt.pw, null),
          ),
        );
      }
      function Fi(e) {
        const { globalMS: t } = e,
          r = Rt(),
          i = (0, Ue.q3)(() =>
            r.ConvertGlobaOffsetToRecordingAndRelativeOffset(t),
          );
        if (!i?.strRecordingID) return null;
        return a.createElement(
          ie.he,
          {
            toolTipContent: (0, p.we)("#TimelineDialog_AddMarker"),
            direction: "top",
          },
          a.createElement(
            "div",
            {
              className: (0, Te.A)(fi.Button, fi.AddMarker),
              onClick: () => {
                r.AddUserMarkerAtGlobalMS(
                  (0, et.Sb)(t),
                  "/GameRecording/AddMarker/Thumbnail",
                  null,
                ),
                  r.SetPlaytimeFromGlobalMS((0, et.Sb)(t));
              },
            },
            a.createElement(gt.pH, null),
          ),
        );
      }
      function qi(e) {
        const { globalMS: t } = e,
          r = Xt(),
          i = (0, Ue.q3)(() => r.ConvertGlobalMSToClipOrNone(t)),
          { onNavigateToClip: n } = Rr();
        return i
          ? a.createElement(
              ie.he,
              {
                toolTipContent: (0, p.we)("#TimelineDialog_ViewClip"),
                direction: "top",
              },
              a.createElement(
                "div",
                {
                  className: (0, Te.A)(fi.Button, fi.GoToClip),
                  onClick: () => {
                    i &&
                      (xe.ReportTrackedAction(
                        "/GameRecording/Tooltip/ViewClip/timeline",
                      ),
                      n(i.clipID));
                  },
                },
                a.createElement(wr.CeX, null),
              ),
            )
          : null;
      }
      const Ni = a.memo(function (e) {
          const t = Dr(),
            r = qr(),
            i = Xt(),
            n = Rt(),
            s = Ur(),
            l = (0, a.useCallback)(
              (e) => {
                if (!r) return;
                const t = e.currentTarget.getBoundingClientRect(),
                  a = Ye.OQ(e.clientX - t.x, 0, t.width),
                  s = i.ConvertPXOffsetToGlobalMS(a, !1);
                s &&
                  n.SetPlaytimeFromGlobalMS((0, et.Sb)(s), void 0, void 0, !0);
              },
              [r, n, i],
            ),
            o = (0, a.useCallback)(
              (e) => {
                if (!r) return;
                const t = e.currentTarget.getBoundingClientRect(),
                  n = Ye.OQ(e.clientX - t.x, 0, t.width),
                  a = i.ConvertPXOffsetToGlobalMS(n, !1);
                a &&
                  (s(e, (0, et.Sb)(a), !1, {
                    bDisableMouseOverlay: !0,
                    bForcePopup: !0,
                    bAlwaysOnTop: !0,
                  }),
                  e.preventDefault(),
                  e.stopPropagation());
              },
              [r, i, s],
            );
          return (
            xr("click", l),
            xr("contextmenu", o),
            a.createElement(xi, { globalMouseXPX: t.globalMouseXPX.valPX || 0 })
          );
        }),
        xi = a.memo(function (e) {
          const { globalMouseXPX: t } = e,
            r = Fr(),
            i = Xt(),
            n = qr(),
            s = (0, Ue.q3)(() => {
              if (i.GetThumbnailComponent()) return i.GetThumbnailPosition();
            }),
            [l, o] = (0, a.useState)(),
            [m, c] = (0, a.useState)();
          return (
            (0, a.useEffect)(() => {
              if (!isNaN(s)) return void o(s);
              !m && r && o(t);
            }, [m, r, n, t, s]),
            a.createElement(
              "div",
              {
                className: si.GhostPlayheadCtn,
                style: { transform: `translateX( calc(${l}px - 50%))` },
              },
              a.createElement(Ui, {
                globalPX: l,
                setInteractingWithThumbnail: c,
                bInteractingWithThumbnail: m,
              }),
            )
          );
        });
      function Ui(e) {
        const {
            globalPX: t,
            setInteractingWithThumbnail: r,
            bInteractingWithThumbnail: i,
          } = e,
          n = Xt(),
          s = Rt(),
          l = (0, Ue.q3)(() => "Overlay" === s.GetRecordingMode()),
          o = (0, Ue.q3)(() => n.ConvertPXOffsetToGlobalMS(t, !1)),
          m = (0, Ue.q3)(() => n.GetTimelineParentCtnRef()),
          c = (0, a.useRef)(void 0),
          d = (0, a.useRef)(void 0),
          u = (0, a.useRef)(void 0),
          p = (0, Ue.q3)(() => n.GetThumbnailComponent()),
          _ = qr(),
          f = (0, ie.fS)({
            toolTipContent: a.createElement(Gi, {
              globalPX: t,
              ref: c,
              onMouseEnter: () => r(!0),
              onMouseLeave: (e) => r(!1),
            }),
            direction: l ? "bottom" : "top",
            nDelayShowMS: 0,
            nBodyDistance: 0,
            nAllowOffscreenPx: 0,
          }),
          { setHovered: h, setTarget: S } = f.stateHandlers,
          b = (0, a.useCallback)(() => {
            h(!1),
              r(!1),
              u.current && u.current(),
              (u.current = null),
              n.GetAutoScrollPaused() && n.SetAutoScrollPauseTimeout(),
              n.SetThumbnailComponent(null);
          }, [r, h, n]),
          M = (0, a.useCallback)(
            (e, t) => {
              if (!d.current || !c.current) return;
              const r = d.current.getBoundingClientRect(),
                i = r.left,
                n = r.right;
              let a = r.top,
                s = r.bottom;
              if (c.current) {
                const e = c.current.getBoundingClientRect();
                l ? (s = e.bottom) : (a = e.top);
              }
              (e <= i || e >= n || t <= a || t >= s) && b();
            },
            [l, b],
          ),
          y = (0, a.useCallback)(
            (e) => {
              const t = n.GetThumbnailComponent();
              (t && t !== xt.Highlight) || M(e.clientX, e.clientY);
            },
            [M, n],
          ),
          T = (0, a.useCallback)(
            (e) => {
              M(e.clientX, e.clientY);
            },
            [M],
          );
        xr(
          "mouseenter",
          (0, a.useCallback)(() => {
            h(!0), S(d.current);
            const e = (0, g.qf)(d.current);
            e &&
              !u.current &&
              (e.addEventListener("mousemove", y),
              e.addEventListener("mouseup", T),
              (u.current = () => {
                e.removeEventListener("mousemove", y),
                  e.removeEventListener("mouseup", T);
              }));
          }, [y, T, h, S]),
        ),
          (0, a.useEffect)(() => {
            const e = (e) => {
              const t = n.GetThumbnailComponent();
              (t && t === xt.Playhead) ||
                t === xt.RangeLeft ||
                t === xt.RangeRight ||
                (c.current && !(0, g.id)(c.current, e.relatedTarget) && b());
            };
            return (
              m && m.addEventListener("mouseleave", e),
              () => m && m.removeEventListener("mouseleave", e)
            );
          }, [b, m, n]),
          (0, a.useEffect)(() => b, [b]);
        const B = (_ || i) && o && !p;
        return a.createElement(
          "div",
          { ref: d, className: si.TooltipHoverSource },
          a.createElement(pi, {
            className: (0, Te.A)(si.GhostPlayhead, B && si.Show),
          }),
          !!o && f.tooltip,
        );
      }
      var ji = r(2508);
      const Li = 500;
      var Hi;
      !(function (e) {
        (e.none = "none"), (e.left = "left"), (e.right = "right");
      })(Hi || (Hi = {}));
      const Xi = (0, a.memo)(function () {
          const [e, t] = (0, a.useState)(Hi.none),
            r = Pt(),
            i = It(),
            n = kt();
          return r && i && n
            ? a.createElement(
                "div",
                { className: ji.RangeControls },
                a.createElement(Vi, {
                  activeControlState: e,
                  setActiveControlState: t,
                }),
              )
            : null;
        }),
        Vi = (0, a.memo)(function (e) {
          const { activeControlState: t, setActiveControlState: r } = e,
            [i, n] = (0, a.useState)(),
            [s, l] = (0, a.useState)(),
            o = It(),
            m = kt(),
            c = Xt(),
            d = (0, Ue.q3)(() => c.ConvertGlobalMSToGlobalPXOffset(o.valMS)),
            u = (0, Ue.q3)(() => c.ConvertGlobalMSToGlobalPXOffset(m.valMS)),
            g = (0, a.useCallback)(
              (e) => {
                n(e), c.SetAutoScrollPauseTimeout();
              },
              [c],
            ),
            p = (0, a.useCallback)(
              (e) => {
                l(e), c.SetAutoScrollPauseTimeout();
              },
              [c],
            ),
            _ = (0, a.useCallback)(
              (e) => {
                t === Hi.none && e.stopPropagation();
              },
              [t],
            ),
            f = (0, a.useCallback)(
              (e) => {
                t === Hi.none && e.stopPropagation();
              },
              [t],
            );
          return a.createElement(
            "div",
            {
              className: (0, Te.A)(
                ji.RangeSelectorCtn,
                t !== Hi.none && ji.Active,
              ),
              onMouseOver: _,
              onMouseOut: f,
              onFocus: _,
              onBlur: f,
            },
            a.createElement(
              "div",
              { className: ji.TrackRangeControls },
              a.createElement(Ki, {
                isActive: t === Hi.left,
                setControlState: r,
                setRangeControlPX: g,
                pxOffset: i,
              }),
              a.createElement(en, {
                startOffsetPX: (t === Hi.left && i) || d,
                endOffsetPX: (t === Hi.right && s) || u,
                className: ji.SelectedRangeMask,
              }),
              a.createElement(Ji, {
                isActive: t === Hi.right,
                setControlState: r,
                setRangeControlPX: p,
                pxOffset: s,
              }),
            ),
          );
        });
      function Zi(e, t, r) {
        const i = t.GetVisualWindowStartPX() - t.GetTimelineMarginWidth(),
          n = i + t.GetVisualWidth(),
          a = Math.max(0, i + 3),
          s = Math.min(t.GetScrollableWidthPX(), n - 3);
        r(Ye.OQ(e, a, s));
      }
      const Ki = (0, a.memo)(function (e) {
        const {
            isActive: t,
            setControlState: r,
            setRangeControlPX: i,
            pxOffset: n,
          } = e,
          s = It();
        return t
          ? a.createElement(Qi, {
              setControlState: r,
              setRangeControlPX: i,
              pxOffset: n,
            })
          : a.createElement(Yi, {
              offsetMS: s.valMS,
              direction: Hi.left,
              setControlState: r,
              setRangeControlPX: i,
            });
      });
      function Qi(e) {
        const { setControlState: t, setRangeControlPX: r, pxOffset: i } = e,
          n = Ot(),
          s = kt(),
          l = Xt(),
          o = Ar();
        return (
          (function (e, t, r, i, n, s) {
            const l = (0, a.useRef)(void 0),
              o = (0, a.useRef)(!1),
              m = (0, a.useRef)(void 0),
              c = (0, a.useRef)(void 0),
              d = (0, Ue.q3)(() => t.GetScrollableWidthPX()),
              u = (0, Ue.q3)(() => t.GetScrollWindowWidth());
            (0, a.useEffect)(
              () => () => {
                m.current &&
                  (cancelAnimationFrame(m.current),
                  (m.current = null),
                  (c.current = null));
              },
              [],
            );
            const g = a.useCallback(
              (e, t, r, i, n) => {
                if (n(t))
                  s(
                    Ye.OQ(
                      t.GetVisualWindowStartPX() + r,
                      0,
                      t.GetScrollableWidthPX(),
                    ),
                  ),
                    cancelAnimationFrame(m.current),
                    (m.current = null),
                    (c.current = null);
                else {
                  if (
                    (m.current &&
                      (m.current = requestAnimationFrame((e) =>
                        g(e, t, r, i, n),
                      )),
                    c.current)
                  ) {
                    const r = ((e - c.current) / Li) * i;
                    t.ScrollBy(r),
                      s((e) => Ye.OQ(e + r, 0, t.GetScrollableWidthPX()));
                  }
                  c.current = e;
                }
              },
              [s],
            );
            (0, a.useEffect)(() => {
              m.current &&
                (cancelAnimationFrame(m.current),
                (m.current = null),
                (c.current = null));
              const a = u * (1 - Hn),
                p = u * Hn,
                _ = t.ConvertGlobalMSToGlobalPXOffset(r.valMS),
                f = t.ConvertGlobalMSToScrollWindowPXOffset(r.valMS);
              if (i.valPX > _)
                return (
                  s(_), n(Hi.right), void t.SetThumbnailComponent(xt.RangeRight)
                );
              if (e.valPX < p && !t.BReachedMinScroll()) {
                if (e.valPX > l.current) o.current = !0;
                else if (e.valPX < l.current || !o.current) {
                  const r = Math.min(p, f),
                    i = e.valPX - r,
                    n = Ye.OQ(Math.abs(i / r), 0, 1) * i;
                  (m.current = requestAnimationFrame((r) =>
                    g(r, t, e.valPX, n, t.BReachedMinScroll),
                  )),
                    (o.current = !1);
                }
                Zi(i.valPX, t, s);
              } else if (e.valPX > a && f > a && !t.BReachedMaxScroll()) {
                if (e.valPX < l.current) o.current = !0;
                else if (e.valPX > l.current || !o.current) {
                  const i = (e) => {
                      const t = e.ConvertGlobalMSToScrollWindowPXOffset(
                        r.valMS,
                      );
                      return e.BReachedMaxScroll() || t <= a;
                    },
                    n = e.valPX - a,
                    s = Ye.OQ(Math.abs(n / (u - a)), 0, 1) * n;
                  (m.current = requestAnimationFrame((r) =>
                    g(r, t, e.valPX, s, i),
                  )),
                    (o.current = !1);
                }
                Zi(i.valPX, t, s);
              } else s(Ye.OQ(i.valPX, 0, d));
              l.current = e.valPX;
            }, [i.valPX, r.valMS, e.valPX, n, t, s, d, g, u]);
          })(Wr(), l, s, o, t, r),
          (0, a.useEffect)(() => {
            isNaN(i) ||
              (l.SetThumbnailPosition(i),
              n(
                De.Ov.k_EClipRangeMethod_Drag,
                (0, et.Sb)(l.ConvertPXOffsetToGlobalMS(i)),
              ));
          }, [i, n, l]),
          a.createElement(tn, { offsetPX: i, direction: Hi.left })
        );
      }
      const Ji = (0, a.memo)(function (e) {
        const {
            isActive: t,
            setControlState: r,
            setRangeControlPX: i,
            pxOffset: n,
          } = e,
          s = kt();
        return t
          ? a.createElement($i, {
              setControlState: r,
              setRangeControlPX: i,
              pxOffset: n,
            })
          : a.createElement(Yi, {
              offsetMS: s.valMS,
              direction: Hi.right,
              setControlState: r,
              setRangeControlPX: i,
            });
      });
      function $i(e) {
        const { setControlState: t, setRangeControlPX: r, pxOffset: i } = e,
          n = zt(),
          s = It(),
          l = Xt(),
          o = Ar();
        return (
          (function (e, t, r, i, n, s) {
            const l = (0, a.useRef)(void 0),
              o = (0, a.useRef)(!1),
              m = (0, a.useRef)(void 0),
              c = (0, a.useRef)(void 0),
              d = (0, Ue.q3)(() => t.GetScrollableWidthPX()),
              u = (0, Ue.q3)(() => t.GetScrollWindowWidth());
            (0, a.useEffect)(
              () => () => {
                m.current &&
                  (cancelAnimationFrame(m.current),
                  (m.current = null),
                  (c.current = null));
              },
              [],
            );
            const g = a.useCallback(
              (e, t, r, i, n) => {
                if (n(t))
                  s(
                    Ye.OQ(
                      t.GetVisualWindowStartPX() + r,
                      0,
                      t.GetScrollableWidthPX(),
                    ),
                  ),
                    cancelAnimationFrame(m.current),
                    (m.current = null),
                    (c.current = null);
                else {
                  if (
                    (m.current &&
                      (m.current = requestAnimationFrame((e) =>
                        g(e, t, r, i, n),
                      )),
                    c.current)
                  ) {
                    const r = ((e - c.current) / Li) * i;
                    t.ScrollBy(r),
                      s((e) => Ye.OQ(e + r, 0, t.GetScrollableWidthPX()));
                  }
                  c.current = e;
                }
              },
              [s],
            );
            (0, a.useEffect)(() => {
              m.current &&
                (cancelAnimationFrame(m.current),
                (m.current = null),
                (c.current = null));
              const a = u * (1 - Hn),
                p = u * Hn,
                _ = t.ConvertGlobalMSToGlobalPXOffset(r.valMS),
                f = t.ConvertGlobalMSToScrollWindowPXOffset(r.valMS);
              if (i.valPX < _)
                return (
                  s(_), n(Hi.left), void t.SetThumbnailComponent(xt.RangeLeft)
                );
              if (e.valPX > a && !t.BReachedMaxScroll()) {
                if (e.valPX < l.current) o.current = !0;
                else if (e.valPX > l.current || !o.current) {
                  const r = Math.max(a, f),
                    i = e.valPX - r,
                    n = Ye.OQ(Math.abs(i / (u - r)), 0, 1) * i;
                  (m.current = requestAnimationFrame((r) =>
                    g(r, t, e.valPX, n, t.BReachedMaxScroll),
                  )),
                    (o.current = !1);
                }
                Zi(i.valPX, t, s);
              } else if (
                e.valPX < p &&
                f < p &&
                e.valPX <= l.current &&
                !t.BReachedMinScroll()
              ) {
                if (e.valPX > l.current) o.current = !0;
                else if (e.valPX < l.current || !o.current) {
                  const i = e.valPX - p,
                    n = Ye.OQ(Math.abs(i / p), 0, 1) * i,
                    a = (e) =>
                      e.ConvertGlobalMSToScrollWindowPXOffset(r.valMS) > p ||
                      e.BReachedMinScroll();
                  (m.current = requestAnimationFrame((r) =>
                    g(r, t, e.valPX, n, a),
                  )),
                    (o.current = !1);
                }
                Zi(i.valPX, t, s);
              } else s(Ye.OQ(i.valPX, 0, d));
              l.current = e.valPX;
            }, [r.valMS, e.valPX, n, t, s, d, u, i.valPX, g]);
          })(Wr(), l, s, o, t, r),
          (0, a.useEffect)(() => {
            isNaN(i) ||
              (l.SetThumbnailPosition(i),
              n(
                De.Ov.k_EClipRangeMethod_Drag,
                (0, et.Sb)(l.ConvertPXOffsetToGlobalMS(i)),
              ));
          }, [i, n, l]),
          a.createElement(tn, { offsetPX: i, direction: Hi.right })
        );
      }
      function Yi(e) {
        const {
            offsetMS: t,
            direction: r,
            setControlState: i,
            setRangeControlPX: n,
          } = e,
          s = Xt(),
          l = (0, Ue.q3)(() => s.ConvertGlobalMSToGlobalPXOffset(t));
        (0, a.useEffect)(
          () => (
            n(void 0),
            () => {
              n(l);
            }
          ),
          [l, n],
        );
        const o = (0, a.useCallback)(
            (e) => {
              const t = (0, g.uX)(e);
              let n, a;
              const l = () => {
                i(r),
                  s.SetThumbnailComponent(
                    r === Hi.left ? xt.RangeLeft : xt.RangeRight,
                  ),
                  n();
              };
              t.addEventListener("mousemove", l),
                (n = () => t.removeEventListener("mousemove", l));
              const o = () => {
                i(Hi.none), s.SetThumbnailComponent(null), n(), a();
              };
              t.addEventListener("mouseup", o),
                (a = () => t.removeEventListener("mouseup", o));
            },
            [r, i, s],
          ),
          m = (e) => {
            s.SetThumbnailComponent(
              r === Hi.left ? xt.RangeLeft : xt.RangeRight,
            );
          },
          c = (e) => {
            s.SetThumbnailComponent(null);
          };
        return a.createElement(
          "div",
          {
            className: ji.InactiveSelectedRangeControl,
            onMouseDown: o,
            onMouseOver: m,
            onFocus: m,
            onMouseOut: c,
            onBlur: c,
          },
          a.createElement(tn, { offsetPX: l, direction: r }),
        );
      }
      const en = (0, a.memo)(function (e) {
          const { startOffsetPX: t, endOffsetPX: r, className: i } = e;
          if (isNaN(t) || isNaN(r)) return null;
          const n = { width: r - t || 0, transform: `translateX(${t}px)` };
          return a.createElement("div", {
            className: (0, Te.A)(ji.RangeMask, i),
            style: n,
          });
        }),
        tn = (0, a.memo)(function (e) {
          const { direction: t, offsetPX: r } = e,
            i = { transform: `translateX( calc( ${r}px - 50%) )` },
            n = Xt(),
            s = (0, Ue.q3)(() => n.GetThumbnailComponent() === xt.Playhead);
          return a.createElement(
            "div",
            { style: i, className: (0, Te.A)(ji.RangeControl) },
            a.createElement(
              "div",
              {
                className: (0, Te.A)(
                  ji.RangeIcon,
                  "left" === t && ji.Left,
                  s && ji.Hide,
                ),
              },
              a.createElement(rn, { innerFill: "#171d25", direction: t }),
            ),
          );
        });
      function rn(e) {
        return a.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 3 36",
            fill: "none",
            style: {
              transform: `rotate(${"right" === e.direction ? 180 : 0}deg)`,
            },
          },
          a.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 0)",
          }),
          a.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 10)",
          }),
          a.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 20)",
          }),
          a.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 30)",
          }),
        );
      }
      var nn = r(28361);
      const an = a.memo(function (e) {
        const t = Xt(),
          r = (0, Ue.q3)(() => t.GetVisibleWindowRelativeTimelines()),
          i = Rt().GetRecordingMode();
        let n = [],
          s = "";
        for (let e of r) {
          let r = t.GetTimeRecorded(e.timelineID),
            i = (0, p._l)(r);
          i != s && (n.push({ timeline: e, strLabel: i }), (s = i));
        }
        for (let e = n.length - 2; e >= 0; e--) {
          let t = n[e];
          n[e + 1].timeline.nVisibleStartPX - t.timeline.nVisibleStartPX >=
            100 || n.splice(e, 1);
        }
        return a.createElement(
          a.Fragment,
          null,
          n.map((e) =>
            a.createElement(sn, {
              key: e.timeline.timelineID,
              startPX: e.timeline.nVisibleStartPX,
              label: e.strLabel,
              recordingMode: i,
            }),
          ),
        );
      });
      function sn(e) {
        const { label: t, startPX: r, recordingMode: i } = e;
        let n = i == mt.Overlay;
        return a.createElement(
          "div",
          {
            className: (0, Te.A)(nn.TimelineRelativeDate, n && nn.Overlay),
            style: { transform: `translateX(${r}px)` },
          },
          t,
        );
      }
      var ln = r(78760);
      const on = (0, a.memo)(function (e) {
        const t = Xt(),
          r = (0, Ue.q3)(() => t.GetVisibleRecordings());
        return a.createElement(
          a.Fragment,
          null,
          r.map((e) =>
            a.createElement(mn, {
              key: e.recordingID,
              startPX: e.nStartPX,
              endPX: e.nEndPX,
              isActive: e.bIsActive,
              recordingType: e.recordingType,
            }),
          ),
        );
      });
      function mn(e) {
        const { isActive: t, endPX: r, startPX: i, recordingType: n } = e,
          s = { width: r - i || 0, transform: `translateX(${i}px)` },
          l = At(),
          o = n === dt.vb.k_EGameRecordingType_Clip,
          m = n === dt.vb.k_EGameRecordingType_ManualRecording;
        return a.createElement(
          a.Fragment,
          null,
          a.createElement("div", {
            className: (0, Te.A)(
              ln.RecordingDecorator,
              o && ln.Clip,
              m && ln.Manual,
              l && ln.ClipMode,
            ),
            style: s,
          }),
          t && a.createElement(cn, { endPX: r }),
        );
      }
      function cn(e) {
        const { endPX: t } = e,
          r = Rt(),
          i = Xt(),
          n = (0, Ue.q3)(() => "Overlay" === r.GetRecordingMode()),
          s = ht(r.GetGameID()),
          l = (0, Ue.q3)(() => r.GetIsLiveEdge() && !r.GetHidePlayer()),
          o = (0, Ue.q3)(() => {
            const e = r.GetLiveEdgeBufferWindowStartMS();
            return i.ConvertGlobalMSToGlobalPXOffset(e.valMS);
          });
        if (!n || s !== ot.BackgroundRecording) return null;
        const m = { width: t - o || 0, transform: `translateX(${o}px)` };
        return a.createElement("div", {
          className: (0, Te.A)(ln.LiveRecordingBuffer, l && ln.IsLive),
          style: m,
        });
      }
      var dn = r(10564);
      const un = (0, a.memo)(function (e) {
          const t = Xt(),
            r = (0, Ue.q3)(() => t.GetVisibleClips());
          return a.createElement(
            a.Fragment,
            null,
            r.map((e) =>
              a.createElement(gn, {
                key: e.clipID,
                startPX: e.pxClipStart,
                endPX: e.pxClipEnd,
              }),
            ),
          );
        }),
        gn = (0, a.memo)(function (e) {
          const { endPX: t, startPX: r } = e,
            i = { width: t - r || 0, transform: `translateX(${r}px)` };
          return a.createElement("div", {
            className: dn.ClipDecorator,
            style: i,
          });
        });
      var pn = r(99550);
      const _n = (0, a.forwardRef)(function (e, t) {
          const r = Xt();
          return (0, Ue.q3)(() => !r.BEmpty())
            ? a.createElement(hn, { ...e, timelineView: r, ref: t })
            : a.createElement(fn, { ref: t });
        }),
        fn = (0, a.forwardRef)(function (e, t) {
          return a.createElement("div", {
            ref: t,
            className: (0, Te.A)(pn.ScrollbarPlaceholder, e.className),
          });
        }),
        hn = (0, a.forwardRef)(function (e, t) {
          const r = Rt(),
            { children: i, className: n, timelineView: s, disableZoom: l } = e,
            [o, m] = (0, a.useState)(),
            c = a.useCallback(
              (e) => {
                const t = e.target.getBoundingClientRect();
                s.SetScrollWindowOffset(t.x),
                  s.SetScrollWindowWidth(t.width),
                  m(t);
              },
              [s],
            ),
            d = (0, j.wY)(c),
            u = a.useCallback(
              (e) => {
                if (e.ctrlKey && !l) {
                  const t = o ? (e.clientX - o.x) / o.width : 0.5;
                  e.deltaY > 0
                    ? s.ZoomOut(e.deltaY / 100, t)
                    : s.ZoomIn(-e.deltaY / 100, t);
                } else s.ScrollBy(e.deltaY);
              },
              [l, o, s],
            );
          return (
            (function (e, t) {
              const r = (0, Ue.q3)(
                () =>
                  !t.GetAutoScrollPaused() &&
                  e.GetGameRecordingVideo().BVideoElementPlaying(),
              );
              (0, a.useEffect)(() => {
                if (!r) return () => {};
                let i = !1,
                  n = e.GetGlobalMSPlaytime(),
                  a = Date.now();
                const s = (r) => {
                  const l = Date.now(),
                    o = l - a;
                  t.ScrollToCenteredGlobalMS(n.valMS + o);
                  const m = e.GetGlobalMSPlaytime();
                  m.valMS !== n.valMS && ((n = m), (a = l)),
                    i || requestAnimationFrame(s);
                };
                return requestAnimationFrame(s), () => (i = !0);
              }, [e, t, r]);
            })(r, s),
            a.createElement(
              "div",
              {
                ref: t,
                onWheel: u,
                onMouseOver: () => s.SetAutoScrollPaused(!0),
                onFocus: () => {},
                onMouseLeave: () => s.SetAutoScrollPauseTimeout(),
              },
              a.createElement(
                "div",
                { className: pn.LeftControlsAndContent },
                a.createElement(
                  "div",
                  { ref: d, className: (0, Te.A)(pn.ContentAndGradient, n) },
                  i,
                  a.createElement(Sn, { timelineView: s }),
                ),
                r.GetRecordingMode() === mt.Overlay &&
                  a.createElement(_t, null),
              ),
              a.createElement(
                "div",
                { className: pn.ScrollbarAndSiblings },
                !r.GetGamepadMode() && a.createElement(bn, null),
              ),
            )
          );
        });
      function Sn(e) {
        const { timelineView: t } = e,
          r = (0, Ue.q3)(() => t.GetVisualWindowStartPX()),
          i = (0, Ue.q3)(() => t.BReachedMaxScroll());
        return a.createElement(
          "div",
          { className: pn.ScrollGradientCtn },
          a.createElement("div", {
            className: (0, Te.A)(pn.FrontGradient, 0 === r && pn.HideGradient),
          }),
          a.createElement("div", {
            className: (0, Te.A)(pn.EndGradient, i && pn.HideGradient),
          }),
        );
      }
      function bn() {
        const [e, t] = (0, a.useState)({
            scrollBarWidth: 0,
            scrollBarXOffset: 0,
          }),
          r = a.useCallback((e) => {
            const r = e.target.getBoundingClientRect();
            t({ scrollBarWidth: r.width, scrollBarXOffset: r.x });
          }, []),
          i = Xt(),
          n = (0, Ue.q3)(
            () => i.GetScrollableWidthPX() + 2 * i.GetTimelineMarginWidth(),
          ),
          s = (0, Ue.q3)(() => i.GetVisualWidth()),
          l = (0, a.useMemo)(
            () => (s * e.scrollBarWidth) / n || 0,
            [s, e.scrollBarWidth, n],
          ),
          o = (0, j.wY)(r);
        return a.createElement(
          "div",
          {
            className: (0, Te.A)(
              pn.ScrollBarCtn,
              Math.round(l) === Math.round(e.scrollBarWidth) &&
                pn.HideScrollBar,
            ),
            ref: o,
          },
          a.createElement(Mn, { timelineView: i, scrollSize: e }),
          a.createElement(vn, {
            scrollSize: e,
            timelineView: i,
            timelineWidth: n,
            thumbWidth: l,
          }),
        );
      }
      function Mn(e) {
        const { timelineView: t, scrollSize: r } = e,
          i = Rt(),
          n = (function (e, t) {
            const r = (0, a.useRef)(void 0),
              i = (0, a.useRef)(void 0),
              n = (0, Ue.q3)(() => e.GetScrollableWidthPX()),
              s = (0, a.useCallback)(
                (e) => (0, et.OB)((n * e) / t.scrollBarWidth),
                [t.scrollBarWidth, n],
              ),
              l = (0, a.useCallback)(() => {
                if (!r.current) return;
                const t = e.GetScrollWindowWidth(),
                  n = e.GetVisualWindowStartPX() + t / 2;
                if (
                  r.current.valPX > n - 0.1 * t &&
                  r.current.valPX < n + 0.1 * t
                )
                  return;
                const a = 0.005 * e.GetScrollableWidthPX(),
                  s = r.current.valPX - n;
                if (Math.abs(s) > a) {
                  const t = s > 0 ? a : -a;
                  e.ScrollToOffsetCentered(n + t),
                    (i.current = requestAnimationFrame(() => l()));
                } else e.ScrollToOffsetCentered(r.current.valPX);
              }, [e]),
              o = (0, a.useCallback)(
                (e) => {
                  (r.current = s(e.clientX - t.scrollBarXOffset)),
                    (i.current = requestAnimationFrame(() => l()));
                },
                [s, l, t.scrollBarXOffset],
              ),
              m = (0, a.useCallback)(() => {
                i.current && cancelAnimationFrame(i.current);
              }, []),
              c = (0, a.useCallback)(
                (e) => {
                  r.current = s(e.clientX - t.scrollBarXOffset);
                },
                [s, t.scrollBarXOffset],
              );
            return (
              (0, a.useEffect)(
                () => () => {
                  i.current && cancelAnimationFrame(i.current);
                },
                [],
              ),
              { onMouseDown: o, onMouseMove: c, onMouseUp: m, onMouseLeave: m }
            );
          })(t, r),
          s = (0, Ue.q3)(() => t.GetTimelineMarginWidth()),
          l = (0, Ue.q3)(() => t.GetScrollableWidthPX()),
          o = (0, a.useCallback)(
            (e) => {
              const t = e + s;
              return Ye.OQ((t * r.scrollBarWidth) / l, 0, r.scrollBarWidth);
            },
            [r.scrollBarWidth, s, l],
          );
        return a.createElement(
          "div",
          { className: pn.ScrollTrack, ...n },
          a.createElement(yn, {
            timelineView: t,
            playbackCoordinator: i,
            fnConvertGlobalPXToTrackPX: o,
            scrollBarWidth: r.scrollBarWidth,
          }),
          a.createElement(Bn, {
            timelineView: t,
            fnConvertGlobalPXToTrackPX: o,
          }),
        );
      }
      function yn(e) {
        const {
            timelineView: t,
            playbackCoordinator: r,
            fnConvertGlobalPXToTrackPX: i,
            scrollBarWidth: n,
          } = e,
          s = (0, Ue.q3)(() => r.GetHidePlayer()),
          l = (0, Ue.q3)(() => {
            const e = r.GetGlobalMSPlaytime();
            if (e && t.BInitialized()) {
              const r = Math.floor(t.ConvertGlobalMSToGlobalPXOffset(e.valMS));
              return i(r);
            }
            return null;
          });
        if (!l) return null;
        return a.createElement(
          "div",
          {
            className: pn.PlayHeadAnnotation,
            onClick: () => {
              let e = r.GetGlobalMSPlaytime();
              s && (e = r.GetLiveEdgeMS()), t.ScrollToCenteredGlobalMS(e.valMS);
            },
            style: { transform: `translateX(${s ? n : l}px)` },
          },
          a.createElement(Tn, null),
        );
      }
      function Tn() {
        return a.createElement(
          "svg",
          {
            width: "52",
            height: "31",
            viewBox: "0 0 52 31",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          a.createElement("path", {
            d: "M26 31L51.1147 0.25H0.885263L26 31Z",
            fill: "#D9D9D9",
          }),
        );
      }
      function Bn(e) {
        const { timelineView: t, fnConvertGlobalPXToTrackPX: r } = e,
          i = At(),
          n = Et(),
          s = (0, Ue.q3)(() => {
            if (i && t.BInitialized()) {
              const e = Math.floor(
                  t.ConvertGlobalMSToGlobalPXOffset(n.nGlobalStartMS.valMS),
                ),
                i = Math.floor(
                  t.ConvertGlobalMSToGlobalPXOffset(n.nGlobalEndMS.valMS),
                );
              if (!isNaN(e) && !isNaN(i)) {
                return { rangeStartPX: r(e), rangeEndPX: r(i) };
              }
            }
            return null;
          });
        if (!s) return null;
        return a.createElement("div", {
          className: pn.RangeAnnotation,
          onClick: () => {
            t.ScrollToCenteredGlobalMS(n.nGlobalStartMS.valMS);
          },
          style: {
            width: s.rangeEndPX - s.rangeStartPX,
            transform: `translateX(${s.rangeStartPX}px)`,
          },
        });
      }
      function vn(e) {
        const {
            scrollSize: t,
            timelineWidth: r,
            thumbWidth: i,
            timelineView: n,
          } = e,
          {
            thumbPositionPX: s,
            onMouseDown: l,
            bHiglightThumb: o,
          } = (function (e, t, r, i) {
            const [n, s] = (0, a.useState)(!1),
              [l, o] = (0, a.useState)(0),
              m = (0, Ue.q3)(() => {
                const n = i.BInitialized(),
                  a = i.GetVisualWindowStartPX();
                return n
                  ? Ye.OQ((a * e.scrollBarWidth) / t, 0, e.scrollBarWidth - r)
                  : 0;
              }),
              [c, d] = (0, a.useState)(!1),
              u = (0, a.useRef)(void 0);
            (0, a.useEffect)(() => {
              if (i.GetAutoScrollPaused())
                return (
                  d(!0),
                  (u.current = window.setTimeout(() => {
                    d(!1);
                  }, 500)),
                  () => window.clearTimeout(u.current)
                );
            }, [m, i]);
            const p = (0, a.useCallback)(
                (t) => {
                  o(m), s(!0);
                  const r = t.nativeEvent.offsetX,
                    n = i.GetTimelineParentCtnRef() ?? (0, g.uX)(t);
                  let a, l, c;
                  const d = (t) => {
                    o(t.clientX - e.scrollBarXOffset - r);
                  };
                  n.addEventListener("mousemove", d),
                    (a = () => n.removeEventListener("mousemove", d));
                  const u = () => {
                    s(!1), a(), l(), c();
                  };
                  n.addEventListener("mouseup", u),
                    n.addEventListener("mouseleave", u),
                    (l = () => n.removeEventListener("mouseup", u)),
                    (c = () => n.removeEventListener("mouseleave", u));
                },
                [m, e.scrollBarXOffset, i],
              ),
              _ = (0, a.useMemo)(
                () => (n ? Ye.OQ(l, 0, e.scrollBarWidth - r) : m),
                [l, n, m, e.scrollBarWidth, r],
              );
            return (
              (0, a.useEffect)(() => {
                if (n) {
                  const r = (t * _) / e.scrollBarWidth;
                  i.ScrollToOffset(r);
                }
              }, [n, e.scrollBarWidth, _, i, t]),
              { thumbPositionPX: _, onMouseDown: p, bHiglightThumb: c }
            );
          })(t, r, i, n);
        return a.createElement("div", {
          className: (0, Te.A)(pn.ScrollThumb, o && pn.Highlight),
          style: { width: i, transform: `translateX(${s}px)` },
          onMouseDown: l,
        });
      }
      var Rn = r(88006),
        Gn = (r(2596), r(13871), r(72739), r(23809));
      class wn {
        m_tours = {};
        m_strActiveTour = "";
        m_storage;
        m_bReady = !1;
        constructor() {
          (0, Oe.Gn)(this);
        }
        async Init(e) {
          if (this.m_storage) return;
          this.m_storage = e;
          const t = await En(e);
          Object.keys(t || {}).forEach((e) => {
            const r = !!t[e];
            this.m_tours[e] = {
              ...(this.m_tours[e] || { stops: {} }),
              bSeen: r,
            };
          }),
            (this.m_bReady = !0);
        }
        UpdateStop(e, t, r, i) {
          this.m_tours[e] || (this.m_tours[e] = { bSeen: !1, stops: {} }),
            (this.m_tours[e].stops[t] = { options: r, elem: i });
        }
        BHasSeenTour(e) {
          return !this.m_bReady || (this.m_tours[e] && this.m_tours[e].bSeen);
        }
        GetTrackedStops(e) {
          return this.m_tours[e]?.stops || {};
        }
        ActivateTour(e) {
          this.m_strActiveTour &&
            this.m_strActiveTour !== e &&
            this.DismissTour(this.m_strActiveTour),
            (this.m_strActiveTour = e);
        }
        DismissTour(e) {
          this.m_tours[e] &&
            (this.MarkTourSeen(e),
            (this.m_tours[e].bSeen = !0),
            this.m_strActiveTour === e && (this.m_strActiveTour = ""));
        }
        MarkTourSeen(e) {
          return In(this.m_storage, e, Date.now());
        }
        MarkTourUnseen(e) {
          return In(this.m_storage, e, void 0);
        }
      }
      (0, W.Cg)([Oe.sH], wn.prototype, "m_tours", void 0),
        (0, W.Cg)([Oe.sH], wn.prototype, "m_strActiveTour", void 0),
        (0, W.Cg)([Oe.sH], wn.prototype, "m_bReady", void 0),
        (0, W.Cg)([Oe.XI.bound], wn.prototype, "UpdateStop", null),
        (0, W.Cg)([Oe.XI], wn.prototype, "ActivateTour", null),
        (0, W.Cg)([Oe.XI], wn.prototype, "DismissTour", null);
      const Cn = "tour_history";
      async function En(e) {
        const t = await e.GetObject(Cn);
        return t && "object" == typeof t ? t : {};
      }
      async function In(e, t, r) {
        const i = await En(e);
        return e.StoreObject(Cn, { ...i, [t]: r });
      }
      const kn = new wn();
      function Pn() {
        const e = (0, Gn.rX)();
        return (
          (0, a.useEffect)(() => {
            kn.Init(e);
          }, [e]),
          kn
        );
      }
      function On(e) {
        const t = Pn(),
          { bShowTour: r, stopElems: i } = (0, Ue.q3)(() => ({
            bShowTour: !t.BHasSeenTour(e),
            stopElems: t.GetTrackedStops(e),
          }));
        return {
          bShowTour: r,
          stopElems: i,
          onInteraction: (0, a.useCallback)(() => t.MarkTourSeen(e), [t, e]),
          onDismiss: (0, a.useCallback)(() => t.DismissTour(e), [t, e]),
          onActivate: (0, a.useCallback)(() => t.ActivateTour(e), [t, e]),
          updateStop: t.UpdateStop,
        };
      }
      function zn(e) {
        const { name: t, tour: r, options: i, children: n } = e,
          { updateStop: s } = On(r),
          l = (0, a.useCallback)((e) => s(r, t, i, e), [s, r, t]);
        return (0, a.cloneElement)(a.Children.only(n), { ref: l });
      }
      var Dn = r(62745);
      function An(e) {
        const t = Xt(),
          r = (0, Ue.q3)(() => t.GetVisibleTimelines());
        return a.createElement(
          a.Fragment,
          null,
          r.flatMap((e) =>
            e.phaseOffsets.map((t, r) =>
              a.createElement(Wn, {
                ...t,
                timeline: e,
                key: `${e.timelineID}_${r}`,
              }),
            ),
          ),
        );
      }
      function Wn(e) {
        const {
          timelineOffsetMS: t,
          nDurationMS: r,
          phase: i,
          timeline: n,
        } = e;
        return a.createElement(
          Fn,
          { ...e },
          a.createElement(Nn, null),
          a.createElement(qn, null),
          a.createElement(Nn, null),
        );
      }
      function Fn(e) {
        const {
            children: t,
            timeline: r,
            timelineOffsetMS: i,
            nDurationMS: n,
            phase: s,
          } = e,
          l = Xt(),
          o = Rt(),
          m = Ar()?.valPX || -1,
          c = Fr(),
          [d] = Nr(),
          {
            pxStart: u,
            pxWidth: g,
            bHighlight: p,
          } = (0, Ue.q3)(() => {
            const e = l.GetPhaseToHighlight();
            return {
              pxStart: l.ConvertGlobalMSToGlobalPXOffset(r.globalOffsetMS + i),
              pxWidth: l.ConvertDurationMSToDeltaPX(n),
              bHighlight:
                e &&
                e[0] === r.timelineID &&
                e[1] === s.background_timeline_offset,
            };
          }),
          _ = (c || d) && m >= u && m <= u + g,
          [f, h] = (function () {
            const e = Rt();
            return [
              (0, Ue.q3)(() => e?.GetPhasePreview() || null),
              (t) => e?.SetPhasePreview(t),
            ];
          })(),
          S = () => {
            const e = o.GetLoader(),
              t = e.GetTimelineData(r.timelineID),
              n = e.GetTimelineMetadata(r.timelineID),
              a = t.m_rgPhases.find((e) => parseInt(e.time) === i);
            a && h({ entry: a, timeline: n });
          },
          b = () => h(void 0);
        return a.createElement(
          "div",
          {
            className: (0, Te.A)(
              Dn.Positioner,
              _ && Dn.MouseWithin,
              p && Dn.Highlight,
            ),
            style: { transform: `translateX( ${u}px )`, width: `${g}px` },
            onMouseOver: S,
            onMouseLeave: b,
            onFocus: S,
            onBlur: b,
          },
          t,
        );
      }
      function qn(e) {
        return a.createElement("div", { className: Dn.Body });
      }
      function Nn(e) {
        return a.createElement("div", { className: Dn.Edge });
      }
      var xn = r(14296);
      function Un(e) {
        const t = Xt(),
          r = (0, Ue.q3)(() => t.GetVisibleTimelines());
        return a.createElement(
          a.Fragment,
          null,
          r.map((e) => a.createElement(jn, { timeline: e, key: e.timelineID })),
        );
      }
      function jn(e) {
        const { timeline: t } = e,
          r = Xt(),
          i = (0, Ue.q3)(
            () => r.GetVisibleTimelineHighlights(t.timelineID) || [],
          ),
          n = (0, Ue.q3)(() => r.GetTimelineOffsetMS(t.timelineID)),
          s = t.globalOffsetMS - n;
        return a.createElement(
          a.Fragment,
          null,
          i
            .filter((e) => "range_highlight" === ti(e))
            .map((e) =>
              a.createElement(Ln, {
                entry: e,
                timeline: t,
                timelineView: r,
                key: e.id,
                timelineOffset: s,
              }),
            ),
        );
      }
      function Ln(e) {
        const { timelineView: t, entry: r, timelineOffset: i } = e,
          n = i + parseInt(r.time),
          { pxStart: s, pxWidth: l } = (0, Ue.q3)(() => ({
            pxStart: t.ConvertGlobalMSToGlobalPXOffset(n),
            pxWidth: t.ConvertDurationMSToDeltaPX(parseInt(r.duration)),
          })),
          o = { width: `${l}px`, transform: `translateX( ${s}px )` };
        return a.createElement(
          "svg",
          { className: xn.RangeHighlight, style: o },
          a.createElement("line", {
            x1: "0",
            x2: l,
            y1: "0",
            y2: "0",
            fill: "none",
            stroke: "#ffc82c",
            "stroke-width": "3",
            "stroke-dasharray": "3 6",
            "stroke-dashoffset": "0",
            "stroke-linecap": "square",
          }),
        );
      }
      const Hn = 0.08;
      function Xn(e) {
        const {
            loader: t,
            className: r,
            clipSummaries: i,
            refTimelineParentCtn: n,
            disableZoom: s,
          } = e,
          l = (0, Ue.q3)(() => t.BInitialized()),
          o = Rt();
        if (!l)
          return a.createElement("div", { className: Gt.LoadingTimeline });
        let m = (0, Te.A)(
          Gt.ScrollAndControlsCtn,
          o.GetGamepadMode() && Gt.GamepadMode,
          r,
        );
        return a.createElement(
          Ht,
          {
            loader: t,
            clipSummaries: i,
            playbackCoordinator: o,
            refTimelineParentCtn: n,
          },
          a.createElement(
            "div",
            { className: m, dir: "ltr" },
            a.createElement(Qn, null),
            a.createElement(Jn, null),
            a.createElement(
              zn,
              {
                tour: "recording_timeline",
                name: "timeline",
                options: { position: "left", offset: 30 },
              },
              a.createElement(
                _n,
                { className: Gt.TimelineScrollContainer, disableZoom: s },
                a.createElement(Vn, null),
              ),
            ),
          ),
        );
      }
      const Vn = (0, a.memo)(function (e) {
        const t = Xt();
        return (0, Ue.q3)(() => t.BInitialized())
          ? a.createElement(Zn, null)
          : null;
      });
      function Zn() {
        const e = Xt(),
          t = (0, Ue.q3)(() => e.GetScrollableWidthPX()),
          r = (0, Ue.q3)(() => e.GetVisualWindowStartPX()),
          i = (0, Ue.q3)(() => e.GetTimelineMarginWidth());
        return a.createElement(
          "div",
          {
            className: Gt.ContentContainer,
            style: {
              minWidth: t || 0,
              marginRight: i,
              marginLeft: i,
              transform: `translateX(${-r}px)`,
            },
          },
          a.createElement(
            Kn,
            { id: "recordings", className: Gt.RecordingDecorators },
            a.createElement(on, null),
          ),
          a.createElement(
            Kn,
            { id: "clips", className: Gt.ClipDecorators },
            a.createElement(un, null),
          ),
          a.createElement(
            Kn,
            { id: "game_modes", className: Gt.GameModes },
            a.createElement(ni, null),
          ),
          a.createElement(
            Kn,
            { id: "date_decorators", className: Gt.DateDecorator },
            a.createElement(an, null),
          ),
          a.createElement(
            Kn,
            { id: "ticks", className: Gt.BackgroundTicks },
            a.createElement(Kt, null),
          ),
          a.createElement(
            zr,
            null,
            a.createElement(
              Kn,
              { id: "highlights", className: Gt.Highlights },
              a.createElement(Jr, null),
            ),
            a.createElement(
              Kn,
              { id: "range_selection", className: Gt.RangeSelector },
              a.createElement(Xi, null),
            ),
            a.createElement(
              Kn,
              { id: "seek_scrub", className: Gt.SeekScrubber },
              a.createElement(Ni, null),
            ),
            a.createElement(
              Kn,
              { id: "play_head", className: Gt.PlayHead },
              a.createElement(oi, null),
            ),
            a.createElement(
              Kn,
              { id: "phases", className: Gt.Phases },
              a.createElement(An, null),
            ),
            a.createElement(
              Kn,
              { id: "range_highlights", className: Gt.RangeHighlights },
              a.createElement(Un, null),
            ),
          ),
        );
      }
      function Kn(e) {
        const { children: t, id: r, className: i } = e;
        return a.createElement(
          "div",
          { id: r, className: (0, Te.A)(i, Gt.AbsoluteLayer) },
          a.createElement("div", { className: Gt.RelativeLayer }, t),
        );
      }
      function Qn(e) {
        const t = Rt().GetRenderGlyph();
        return t ? t(Rn.pR.TRIGGER_LEFT, !1, !1, Gt.PositionLeft) : null;
      }
      function Jn(e) {
        const t = Rt().GetRenderGlyph();
        return t ? t(Rn.pR.TRIGGER_RIGHT, !1, !1, Gt.PositionRight) : null;
      }
      const $n = JSON.parse(
        '{"daterecorded":1713552945,"starttime":0,"entries":[{"id":"1","time":"1000","type":"gamemode","mode":3},{"id":"2","time":"7000","type":"event","title":"bolt","description":"steam_bolt","icon":"steam_bolt","priority":2,"duration":"0","possible_clip":2},{"id":"3","time":"8500","type":"event","title":"gem","description":"steam_gem","icon":"steam_gem","priority":1,"duration":"0","possible_clip":2},{"id":"4","time":"11000","type":"event","title":"star","description":"steam_star","icon":"steam_star","priority":4,"duration":"0","possible_clip":2},{"id":"6","time":"13000","type":"event","title":"heart","description":"steam_heart","icon":"steam_heart","priority":2,"duration":"0","possible_clip":2},{"id":"7","time":"15500","type":"event","title":"checkmark","description":"steam_checkmark","icon":"steam_checkmark","priority":3,"duration":"0","possible_clip":2},{"id":"8","time":"18000","type":"gamemode","mode":1},{"id":"9","time":"25000","type":"event","title":"crown","description":"steam_crown","icon":"steam_crown","priority":10,"duration":"0","possible_clip":2},{"id":"10","time":"27000","type":"event","title":"ribbon","description":"steam_ribbon","icon":"steam_ribbon","priority":9,"duration":"0","possible_clip":2},{"id":"11","time":"32000","type":"event","title":"chest","description":"steam_chest","icon":"steam_chest","priority":8,"duration":"0","possible_clip":2},{"id":"13","time":"34500","type":"event","title":"defend","description":"steam_defend","icon":"steam_defend","priority":8,"duration":"0","possible_clip":2},{"id":"14","time":"36000","type":"event","title":"timer","description":"steam_timer","icon":"steam_timer","priority":10,"duration":"0","possible_clip":2},{"id":"15","time":"46000","type":"event","title":"defend","description":"steam_defend","icon":"steam_defend","priority":10,"duration":"0","possible_clip":2},{"id":"17","time":"50000","type":"usermarker","icon":"steam_marker","priority":0},{"id":"18","time":"51500","type":"event","title":"defend","description":"steam_defend","icon":"steam_defend","priority":10,"duration":"0","possible_clip":2},{"id":"19","time":"52500","type":"event","title":"explosion","description":"steam_explosion","icon":"steam_explosion","priority":10,"duration":"0","possible_clip":2}],"endtime":60000}',
      );
      function Yn(e) {
        const { appid: t, markerID: r } = e,
          i = (function (e) {
            const [t] = (0, a.useState)(() => new $e.SX());
            return (
              (0, a.useEffect)(() => {
                const r = [
                    {
                      timeline_id: "mocktimeline_1",
                      game_id: "clip_1",
                      date_recorded: 1713811258,
                      duration_ms: "60000",
                      recordings: [
                        {
                          recording_id: "recording_1",
                          duration_ms: "15000",
                          start_offset_ms: "5000",
                        },
                        {
                          recording_id: "recording_2",
                          duration_ms: "15000",
                          start_offset_ms: "25000",
                        },
                        {
                          recording_id: "recording_3",
                          duration_ms: "15000",
                          start_offset_ms: "45000",
                        },
                      ],
                    },
                  ],
                  i = { ...$n, entries: $n.entries.map((e) => e) };
                t.LoadTimelinesForTestClip(0, void 0, `${e}`, r),
                  t.SetTimelineData(r[0].timeline_id, i);
              }, [e, t]),
              t
            );
          })(t);
        return (
          (0, a.useEffect)(() => {
            const e = i.GetTimelines()[0].metadata.timeline_id;
            i.RemoveTimelineEvent(e, "5"),
              i.RemoveTimelineEvent(e, "12"),
              i.RemoveTimelineEvent(e, "16"),
              i.AddEventToTimeline(e, 12500, r, "5", 9, r, r, 0),
              i.AddEventToTimeline(e, 33500, r, "12", 2, r, r, 0),
              i.AddEventToTimeline(e, 48500, r, "16", 9, r, r, 0);
          }, [r, i]),
          a.createElement(
            vt,
            { loader: i, fnGetManifest: () => "", mode: mt.Partner },
            a.createElement(Xn, { loader: i, disableZoom: !0 }),
          )
        );
      }
      const ea = 31;
      function ta(e) {
        return /^[a-z0-9_-]{1,31}$/.test(e);
      }
      var ra;
      async function ia(e) {
        return new Promise((t, r) => {
          if (!e) return t((0, p.we)("#TimelineMarkers_Error_NotFound"));
          {
            const r = new FileReader();
            (r.onloadend = () => {
              const n = e.type,
                a = e.name;
              if (
                ("image/png" === n || a.endsWith(".png")) &&
                r.result.toString().startsWith("data:image/png;base64,")
              ) {
                const n = new Image();
                (n.onload = function () {
                  n.width != n.height
                    ? (console.error("Image wrong width, must be square"),
                      t((0, p.we)("#TimelineMarkers_Error_PNGDimensions")))
                    : n.width < oe
                      ? (console.error("Image too small"),
                        t((0, p.we)("#TimelineMarkers_Error_PNGSize", oe)))
                      : n.width > le
                        ? (function (e, t, r, i) {
                            const n = new FileReader();
                            (n.onload = (n) => {
                              const a = new Image();
                              (a.onload = () => {
                                const n = document.createElement("canvas");
                                let s = a.width,
                                  l = a.height;
                                s > l
                                  ? s > t && ((l *= t / s), (s = t))
                                  : l > r && ((s *= r / l), (l = r)),
                                  (n.width = s),
                                  (n.height = l),
                                  n.getContext("2d").drawImage(a, 0, 0, s, l);
                                const o = n.toDataURL(e.type);
                                i(o);
                              }),
                                (a.src = n.target?.result);
                            }),
                              n.readAsDataURL(e);
                          })(e, le, le, (e) => {
                            t({
                              image: e,
                              image_type: i.k_ETimelineImageType_PNG,
                              strFilenameWithoutExtension: na(a).substring(
                                0,
                                ea,
                              ),
                            });
                          })
                        : t({
                            image: r.result,
                            image_type: i.k_ETimelineImageType_PNG,
                            strFilenameWithoutExtension: na(a).substring(0, ea),
                          });
                }),
                  (n.src = r.result);
              } else
                "image/svg+xml" === n || a.endsWith(".svg")
                  ? t({
                      image: r.result,
                      image_type: i.k_ETimelineImageType_SVG_XML,
                      strFilenameWithoutExtension: na(a).substring(0, ea),
                    })
                  : (console.error("unknown content types: " + n),
                    t((0, p.we)("#TimelineMarkers_Error_UnknownFileType", n)));
            }),
              "image/svg+xml" === e.type || e.name.endsWith(".svg")
                ? r.readAsText(e)
                : r.readAsDataURL(e);
          }
        });
      }
      function na(e) {
        const t = e.lastIndexOf(".");
        return -1 !== t && t > e.lastIndexOf("/") ? e.slice(0, t) : e;
      }
      function aa(e) {
        const { appid: t, closeModal: r } = e,
          [i, n] = (0, a.useState)(() => [
            {
              markerid: "",
              image: null,
              image_type: null,
              timeline_marker_id: null,
            },
          ]),
          [s, l] = (0, a.useState)(ra.k_IconEditorHidden),
          { publicAssetSetID: o, hiddenAssetSetID: c } = J(t),
          { fnCreateTimelineMarkerDefinition: d } = ce(),
          u = (0, a.useRef)(void 0),
          [g, f] = (0, a.useState)(null),
          h = (0, Se.vs)(),
          S = (0, a.useCallback)(
            async (e) => {
              const t = [{ ...i[0] }],
                r = e.length;
              for (let n = 0; n < e.length; ++n) {
                const a = e[n],
                  s = await ia(a);
                if ("string" == typeof s) {
                  f(s);
                  break;
                }
                if (0 == n) {
                  if (
                    ((t[0].image = s.image),
                    (t[0].image_type = s.image_type),
                    r > 1 || 0 == i[0].markerid.length)
                  ) {
                    const e = s.strFilenameWithoutExtension.substring(0, ea);
                    (t[0].markerid = e),
                      (t[0].timeline_marker_id = `temp_${n}_${e}`);
                  }
                } else {
                  const e = s.strFilenameWithoutExtension.substring(0, ea);
                  t.push({
                    image: s.image,
                    image_type: s.image_type,
                    markerid: e,
                    timeline_marker_id: `temp_${n}_${e}`,
                  });
                }
              }
              n(t);
            },
            [i],
          ),
          b = (0, a.useCallback)(
            async (e) => {
              f(null);
              if ((e.currentTarget?.files?.length || 0) > 0) {
                const t = new Array();
                for (let r = 0; r < e.currentTarget.files.length; ++r)
                  t.push(e.currentTarget.files[r]);
                S(t);
              }
            },
            [S],
          );
        return h.bLoading
          ? a.createElement(Se.Hh, {
              state: h,
              strDialogTitle: (0, p.we)("#TimelineMarkers_Dialog_Create"),
              closeModal: r,
            })
          : a.createElement(
              Me.o0,
              {
                strTitle: (0, p.we)("#TimelineMarkers_Dialog_Create"),
                bOKDisabled: i.some(
                  (e) => !ta(e.markerid) || !e.image || e.image?.length < 10,
                ),
                bDisableBackgroundDismiss: !0,
                onCancel: r,
                strOKButtonText: (0, p.we)("#Button_Create"),
                onOK: async () => {
                  h.fnSetLoading(!0);
                  let e = s == ra.k_IconEditorPublic ? o : c;
                  if (
                    (s != ra.k_IconEditorPublic || o
                      ? s != ra.k_IconEditorHidden ||
                        c ||
                        (e = (await Y(t, !1)).assetSetID)
                      : (e = (await Y(t, !0)).assetSetID),
                    !e)
                  )
                    return (
                      console.error(
                        "IconCreateEditDialog failed to create hidden sets " +
                          s,
                      ),
                      h.fnSetError(!0),
                      void h.fnSetStrError(
                        (0, p.we)("#OptIn_Appeals_Dialog_Failed"),
                      )
                    );
                  let r = !0;
                  for (let n = 0; n < i.length; ++n) {
                    const a = i[n];
                    if (
                      (await d(t, e, a.markerid, a.image, a.image_type)) !=
                      _.d.k_EResultOK
                    ) {
                      h.fnSetError(!0),
                        h.fnSetStrError(
                          (0, p.we)("#OptIn_Appeals_Dialog_Failed"),
                        ),
                        (r = !1);
                      break;
                    }
                  }
                  r &&
                    (h.fnSetSuccess(!0),
                    h.fnSetStrSuccess(
                      (0, p.we)("#TimelineMarkers_Dialog_CreateSuccess"),
                    ));
                },
              },
              a.createElement(
                "div",
                { className: Be.DialogBody },
                a.createElement(
                  "div",
                  { className: Be.DialogIntro },
                  a.createElement(
                    "div",
                    null,
                    (0, p.we)("#TimelineMarkers_Dialog_Create_Description"),
                  ),
                  a.createElement(
                    "ul",
                    null,
                    a.createElement(
                      "li",
                      null,
                      a.createElement(
                        "strong",
                        null,
                        (0, p.we)("#TimelineMarkers_Dialog_Name_Title"),
                      ),
                      " - ",
                      (0, p.we)("#TimelineMarkers_Dialog_Name_ttip", se),
                    ),
                    a.createElement(
                      "li",
                      null,
                      a.createElement(
                        "strong",
                        null,
                        (0, p.we)("#TimelineMarkers_Dialog_SVG"),
                      ),
                      " - ",
                      (0, p.we)("#TimelineMarkers_Dialog_SVG_create_desc"),
                    ),
                  ),
                ),
                Boolean(g) &&
                  a.createElement(
                    "div",
                    { className: be.ErrorStylesBackground },
                    g,
                  ),
                a.createElement("br", null),
                a.createElement("br", null),
                a.createElement(
                  "h3",
                  null,
                  (0, p.we)("#TimelineMarkers_Dialog_Title_UploadIcons"),
                ),
                a.createElement("input", {
                  type: "file",
                  accept: ".svg,.png",
                  style: { display: "none" },
                  multiple: !0,
                  name: "fileupload",
                  ref: u,
                  onChange: b,
                }),
                a.createElement(
                  m.$n,
                  { onClick: () => u.current.click() },
                  a.createElement(ye.xv8, null),
                  " ",
                  (0, p.we)("#TimelineMarkers_Dialog_SVG_mutli_button"),
                ),
                a.createElement(
                  "div",
                  { className: Be.DragTargetCtn },
                  a.createElement(sa, { fnHandleFiles: S }),
                ),
                Boolean(i?.length > 0 && i[0].image?.length > 0) &&
                  a.createElement(
                    "h3",
                    null,
                    (0, p.we)("#TimelineMarkers_Dialog_IconCreateTitle"),
                  ),
                i.map((e, r) =>
                  a.createElement(la, {
                    marker: e,
                    key: "" + r,
                    appid: t,
                    setMarkerID: (e) => {
                      const t = [...i];
                      (t[r].markerid = e), n(t);
                    },
                  }),
                ),
                a.createElement("br", null),
                a.createElement("br", null),
                a.createElement(ca, {
                  createVisibilityState: s,
                  setCreateVisibilityState: l,
                }),
              ),
            );
      }
      function sa(e) {
        const { fnHandleFiles: t } = e,
          [r, i] = (0, a.useState)(!1);
        return a.createElement(
          "div",
          {
            className: (0, Te.A)(
              Be["drag-drop-box"],
              r && Be.dragging,
              ve.DragBox,
            ),
            onDragEnter: (e) => {
              e.preventDefault(), i(!0);
            },
            onDragOver: (e) => {
              e.preventDefault();
            },
            onDragLeave: () => {
              i(!1);
            },
            onDrop: (e) => {
              e.preventDefault(), i(!1);
              const r = Array.from(e.dataTransfer.files);
              t(r);
            },
          },
          a.createElement(
            "p",
            null,
            (0, p.we)("#TimelineMarkers_Dialog_SVG_draganddrop"),
          ),
        );
      }
      function la(e) {
        const { marker: t, appid: r, setMarkerID: i } = e;
        return (
          (0, a.useEffect)(
            () => (
              ge(t.timeline_marker_id, t),
              () => {
                pe(t.timeline_marker_id);
              }
            ),
            [t],
          ),
          t?.image
            ? a.createElement(
                a.Fragment,
                null,
                a.createElement(ma, {
                  markerID: t.markerid,
                  strErrorMessage: null,
                  imageContent: t.image,
                  imageType: t.image_type,
                }),
                a.createElement(
                  "div",
                  { className: Be.PreviewCtn },
                  a.createElement(
                    "div",
                    null,
                    a.createElement(
                      m.JU,
                      null,
                      (0, p.we)("#TimelineMarkers_Dialog_Icon_Title"),
                    ),
                    a.createElement(Ge, {
                      imageBase64OrUntrustedSVG: t.image,
                      imageType: t.image_type,
                    }),
                  ),
                  a.createElement(m.pd, {
                    type: "text",
                    value: t.markerid,
                    maxChars: se,
                    label: (0, p.we)("#TimelineMarkers_Dialog_Name_Title"),
                    placeholder: (0, p.we)(
                      "#TimelineMarkers_Dialog_Name_placeholder",
                    ),
                    onChange: (e) => i(e.currentTarget.value || ""),
                  }),
                ),
                a.createElement(
                  m.JU,
                  null,
                  (0, p.we)("#TimelineMarkers_Dialog_Icon_TimelinePreview"),
                ),
                a.createElement(Yn, {
                  appid: r,
                  markerID: t.timeline_marker_id,
                }),
              )
            : null
        );
      }
      function oa(e) {
        const {
            appid: t,
            closeModal: r,
            bDisallowMarkerIDEdit: i,
            oTimelineMarkerDef: n,
          } = e,
          [s, l] = (0, a.useState)(n.markerid),
          {
            fnUpdateTimelineMarkerDefinition: o,
            fnDeleteTimelineMarkerDefinition: c,
          } = ce(),
          [d, g] = (0, a.useState)(n.image),
          [f, h] = (0, a.useState)(n.image_type),
          [S, b] = (0, a.useState)(0),
          M = (0, a.useRef)(void 0),
          [y, T] = (0, a.useState)(null),
          B = (0, p.we)("#TimelineMarkers_Dialog_Edit", s);
        (0, a.useEffect)(() => {
          if (d && f && S && s) {
            const e = `temp_${S}_${n.timeline_marker_id}`;
            ge(e, {
              image: d,
              image_type: f,
              timeline_marker_id: e,
              markerid: s,
            });
          }
          return () => {
            if (S) {
              pe(`temp_${S}_${n.timeline_marker_id}`);
            }
          };
        }, [d, f, s, S, n.timeline_marker_id]);
        const v = (0, a.useCallback)(async (e) => {
            T(null);
            const t = e.currentTarget?.files?.[0],
              r = await ia(t);
            "string" == typeof r
              ? T(r)
              : (g(r.image), h(r.image_type), b((e) => e + 1));
          }, []),
          R = (0, Se.vs)();
        if (R.bLoading)
          return a.createElement(Se.Hh, {
            state: R,
            strDialogTitle: B,
            closeModal: r,
          });
        let G, w;
        if (!i || n.unpublished_changes) {
          let e = null;
          const r = (function (e, t) {
            return me.Get().GetAppMarkers(e, t);
          })(n.asset_set_id, n.markerid);
          r.oPublishedMarker && n.unpublished_changes
            ? ((G = (0, p.we)("#Button_Revert")),
              (e = (0, p.we)("#TimelineMarkers_Dialog_RevertSuccess")))
            : ((e = (0, p.we)("#TimelineMarkers_Dialog_DeleteSuccess")),
              (G = (0, p.we)("#Button_Delete"))),
            (w = async () => {
              (0, u.pg)(
                a.createElement(Me.o0, {
                  strTitle: G,
                  strDescription: (0, p.we)("#Dialog_AreYouSure"),
                  onOK: async () => {
                    R.fnSetLoading(!0);
                    (await c(t, n.asset_set_id, n.timeline_marker_id)) !=
                    _.d.k_EResultOK
                      ? (R.fnSetError(!0),
                        R.fnSetStrError(
                          (0, p.we)("#OptIn_Appeals_Dialog_Failed"),
                        ))
                      : (R.fnSetSuccess(!0), R.fnSetStrSuccess(e));
                  },
                }),
                window,
              );
            });
        }
        return a.createElement(
          Me.o0,
          {
            strTitle: B,
            bOKDisabled: !ta(s) || d?.length < 10,
            bDisableBackgroundDismiss: !0,
            onCancel: r,
            onMiddleButton: w,
            strMiddleButtonText: G,
            strOKButtonText: (0, p.we)("#Button_Update"),
            onOK: async () => {
              R.fnSetLoading(!0),
                (await o(t, n.asset_set_id, n.timeline_marker_id, s, d, f)) ==
                _.d.k_EResultOK
                  ? (R.fnSetSuccess(!0),
                    R.fnSetStrSuccess(
                      (0, p.we)("#TimelineMarkers_Dialog_UpdateSuccess"),
                    ))
                  : (R.fnSetError(!0),
                    R.fnSetStrError((0, p.we)("#OptIn_Appeals_Dialog_Failed")));
            },
          },
          a.createElement(
            "div",
            { className: Be.DialogBody },
            a.createElement(ma, {
              markerID: s,
              strErrorMessage: y,
              imageContent: d,
              imageType: f,
            }),
            a.createElement(
              "h3",
              null,
              (0, p.we)("#TimelineMarkers_Dialog_Name_Title"),
            ),
            i
              ? a.createElement(
                  "p",
                  null,
                  (0, p.we)("#TimelineMarkers_Dialog_Name_Disabled"),
                )
              : a.createElement(
                  "p",
                  null,
                  (0, p.we)("#TimelineMarkers_Dialog_Name", se),
                ),
            a.createElement(m.pd, {
              type: "text",
              value: s,
              disabled: i,
              maxChars: se,
              className: Be.Identifier,
              placeholder: (0, p.we)(
                "#TimelineMarkers_Dialog_Name_placeholder",
              ),
              tooltip: (0, p.we)("#TimelineMarkers_Dialog_Name_ttip"),
              onChange: (e) => l(e.currentTarget.value || ""),
            }),
            a.createElement("br", null),
            a.createElement("br", null),
            a.createElement(
              "h3",
              null,
              (0, p.we)("#TimelineMarkers_Dialog_SVG"),
            ),
            a.createElement(
              "p",
              null,
              (0, p.we)("#TimelineMarkers_Dialog_SVG_desc"),
            ),
            a.createElement(
              "div",
              { className: Be.PreviewCtn },
              a.createElement(Ge, {
                imageBase64OrUntrustedSVG: d,
                imageType: f,
              }),
              a.createElement("input", {
                type: "file",
                accept: ".svg,.png",
                style: { display: "none" },
                multiple: !1,
                name: "fileupload",
                ref: M,
                onChange: v,
              }),
              a.createElement(
                m.$n,
                { onClick: () => M.current.click() },
                a.createElement(ye.xv8, null),
                " ",
                (0, p.we)("#TimelineMarkers_Dialog_SVG_button"),
              ),
            ),
            a.createElement(Yn, {
              appid: t,
              markerID: S
                ? `temp_${S}_${n.timeline_marker_id}`
                : n.timeline_marker_id,
            }),
          ),
        );
      }
      function ma(e) {
        const {
            markerID: t,
            strErrorMessage: r,
            imageContent: n,
            imageType: s,
          } = e,
          l = ta(t),
          o = t?.trimStart().startsWith("steam_");
        let m;
        if (s == i.k_ETimelineImageType_SVG_XML) {
          const e = new DOMParser()
            .parseFromString(n, "image/svg+xml")
            .querySelector("svg");
          let t = 0,
            r = 0,
            i = 0,
            a = 0;
          if (e) {
            const n = e.viewBox;
            if (n && n.baseVal) {
              const e = n.baseVal;
              (t = e.x), (r = e.y), (i = e.width), (a = e.height);
            }
            (0 != i && 0 != a) ||
              ((t = e.x.baseVal.value),
              (r = e.y.baseVal.value),
              (i = e.width.baseVal.value),
              (a = e.height.baseVal.value)),
              (Math.abs(t - 0) > 0.5 ||
                Math.abs(r - 0) > 0.5 ||
                Math.abs(i - 36) > 0.5 ||
                Math.abs(a - 36) > 0.5) &&
                (m = `(${t}, ${r})-(${t + i}, ${r + a})`);
          }
        }
        return a.createElement(
          a.Fragment,
          null,
          Boolean(!l && t.length > 0) &&
            a.createElement(
              "div",
              { className: be.ErrorStylesBackground },
              (0, p.we)("#TimelineMarkers_Dialog_Name_error"),
            ),
          Boolean(o) &&
            a.createElement(
              "div",
              { className: be.ErrorStylesBackground },
              (0, p.we)("#TimelineMarkers_Dialog_Name_error2"),
            ),
          Boolean(m) &&
            a.createElement(
              "div",
              { className: be.WarningStylesBackground },
              (0, p.we)("#TimelineMarkers_Dialog_SVG_warning_dimensions", m),
            ),
        );
      }
      function ca(e) {
        const { createVisibilityState: t, setCreateVisibilityState: r } = e,
          i = a.useId();
        return a.createElement(
          a.Fragment,
          null,
          a.createElement(
            "h3",
            { id: i },
            (0, p.we)("#TimelineMarkers_Dialog_Visibility"),
          ),
          a.createElement(
            m.zW,
            {
              labelId: i,
              value: t,
              onChange: (e) => {
                r(e);
              },
            },
            a.createElement(
              "div",
              { className: Be.RadioColumn },
              a.createElement(
                m.a,
                { value: ra.k_IconEditorPublic },
                (0, p.oW)(
                  "#TimelineMarkers_Dialog_Public",
                  a.createElement("b", null),
                ),
              ),
              a.createElement(
                m.a,
                { value: ra.k_IconEditorHidden },
                (0, p.oW)(
                  "#TimelineMarkers_Dialog_Hidden",
                  a.createElement("b", null),
                ),
              ),
            ),
          ),
        );
      }
      !(function (e) {
        (e.k_IconEditorPublic = "public"), (e.k_IconEditorHidden = "hidden");
      })(ra || (ra = {}));
      var da = r(87275);
      const ua = "publicmissing";
      function ga(e) {
        const { appid: t } = e,
          { publicAssetSetID: r } = J(t),
          i = _e(t);
        return a.createElement(
          "div",
          null,
          a.createElement(
            "div",
            { className: da.Columns },
            a.createElement(
              "div",
              { className: da.LeftCol },
              a.createElement(
                "div",
                { className: (0, Te.A)(d().SectionTitle) },
                (0, p.we)("#TimelineMarkers_Public_title"),
              ),
              a.createElement(
                "div",
                null,
                (0, p.we)("#TimelineMarkers_Public_desc1"),
              ),
              a.createElement("br", null),
              a.createElement(
                "div",
                null,
                (0, p.we)("#TimelineMarkers_Public_desc2"),
              ),
            ),
            a.createElement(
              "div",
              { className: da.Ctn },
              a.createElement(
                "div",
                { className: da.GridCtn },
                Boolean(r)
                  ? a.createElement(Ee, {
                      assetSetID: r,
                      appid: t,
                      bDraggable: !1,
                      strMessageOnEmpty: (0, p.we)(
                        "#TimelineMarkers_Public_none",
                      ),
                    })
                  : a.createElement(
                      "div",
                      null,
                      (0, p.we)("#TimelineMarkers_Public_none"),
                    ),
                i?.length > 0 &&
                  a.createElement(Pe, {
                    assetSetID: r || ua,
                    appid: t,
                    strMessage: (0, p.we)(
                      "#TimelineMarkers_drag_target_public",
                    ),
                  }),
              ),
            ),
          ),
        );
      }
      const pa = /^assetsetid_(.+)_markerid_(.+)$/,
        _a = /^droptarget_assetsetid_(.+)_appid_(.+)$/;
      async function fa(e, t) {
        if (!e.destination)
          return void (
            "dev" == er.TS.WEB_UNIVERSE &&
            console.log("TimelineMarkerDrop: Dev Only: Destination missing?")
          );
        const r = e.draggableId.match(pa),
          i = e.destination.droppableId.match(_a);
        if (!(r?.length > 2 && i?.length > 2))
          return void (
            "dev" == er.TS.WEB_UNIVERSE &&
            console.log(
              "TimelineMarkerDrop: Dev Only: failed to parse",
              e.draggableId,
              e.destination.droppableId,
            )
          );
        ha(r[1], r[2], i[1], Number.parseInt(i[2]));
      }
      async function ha(e, t, r, i) {
        if (e == r)
          return (
            "dev" == er.TS.WEB_UNIVERSE &&
              console.log(
                "TimelineMarkerDrop: Dev Only: No-op, source and target are the same asset set id.",
              ),
            r
          );
        if (r == ua) {
          const e = await Y(i, !0);
          if (e.eResult != _.d.k_EResultOK) {
            const t = (0, N.H)({ success: e.eResult });
            return (
              console.error(
                "TimelineMarkerDrop failed to create public asset set: " +
                  t.strErrorMsg,
                t,
              ),
              r
            );
          }
          r = e.assetSetID;
        }
        const {
          fnCreateTimelineMarkerDefinition: n,
          fnDeleteTimelineMarkerDefinition: a,
          fnUpdateTimelineMarkerDefinition: s,
        } = ce();
        let l = de(e, t),
          o = _.d.k_EResultOK;
        if (((m = r), (c = t), me.Get().BDoesAssetSetHaveMarkerID(m, c))) {
          const e = de(r, t);
          o = await s(i, r, e.timeline_marker_id, t, l.image, l.image_type);
        } else o = await n(i, r, t, l.image, l.image_type);
        var m, c;
        if (o != _.d.k_EResultOK)
          return console.error("TimelineMarkerDrop failed on step 1" + o), r;
        if (l.unpublished_changes) {
          if (((o = await a(i, e, l.timeline_marker_id)), o != _.d.k_EResultOK))
            return (
              console.error("TimelineMarkerDrop failed on step 2: " + o), r
            );
          l = de(e, t);
        }
        return l &&
          !l?.unpublished_changes &&
          ((o = await a(i, e, l.timeline_marker_id)), o != _.d.k_EResultOK)
          ? (console.error("TimelineMarkerDrop failed on step 3: " + o), r)
          : ("dev" == er.TS.WEB_UNIVERSE &&
              console.log("drag&drop complete successfully"),
            r);
      }
      var Sa = r(36952);
      function ba(e) {
        const { appid: t } = e,
          r = _e(t),
          { hiddenAssetSetID: i } = J(t),
          n = (0, a.useMemo)(
            () =>
              r?.filter((e) => e.unpublished_changes && e.asset_set_id != i)
                .length || 0,
            [r, i],
          );
        return 0 == n
          ? null
          : a.createElement(
              "div",
              { className: Sa.PublishNoteCtn },
              a.createElement(
                "div",
                { className: Sa.CalloutTitle },
                (0, p.Yp)("#TimelineMarkers_Publishing_title", n),
              ),
              a.createElement(
                "div",
                null,
                (0, p.we)("#TimelineMarkers_Publishing_desc"),
              ),
              a.createElement(
                m.jn,
                {
                  onClick: (e) => {
                    window.location.href = `${er.TS.PARTNER_BASE_URL}apps/publishing/${t}`;
                  },
                },
                (0, p.we)("#TimelineMarkers_Publishing_action"),
              ),
            );
      }
      function Ma(e) {
        const { appid: t, assetSetID: r, closeModal: i } = e,
          n = $(t, r),
          { fnCreateAssetSet: s, fnUpdateAssetSet: l } = K(),
          [o, c] = (0, a.useState)(n.name),
          [d, u] = (0, a.useState)(n.desc),
          g = o.trimStart().toLowerCase().startsWith("steam_"),
          f = 0 == o.trim().length,
          h = (0, p.we)(
            r ? "#AssetSet_Dialog_Edit_Title" : "#AssetSet_Dialog_Create_Title",
          ),
          S = (0, Se.vs)();
        return S.bLoading
          ? a.createElement(Se.Hh, {
              state: S,
              strDialogTitle: h,
              closeModal: i,
            })
          : a.createElement(
              Me.o0,
              {
                strTitle: h,
                strDescription: (0, p.we)(
                  "#TimelineMarkers_Hidden_new_asset_set_desc",
                ),
                strOKButtonText: (0, p.we)("#Button_Save"),
                onOK: async () => {
                  S.fnSetLoading(!0), (n.name = o), (n.desc = d), (n.appid = t);
                  let e = null;
                  try {
                    let t;
                    r
                      ? (t = await l(n))
                      : ((n.branches = []), (t = await s(n))),
                      t != _.d.k_EResultOK && (e = (0, N.H)({ sucess: t }));
                  } catch (t) {
                    e = (0, N.H)(t);
                  }
                  e
                    ? (console.error("Branch Set error " + e.strErrorMsg, e),
                      S.fnSetError(!0),
                      S.fnSetStrError(
                        (0, p.we)("#OptIn_Appeals_Dialog_Failed"),
                      ))
                    : S.fnSetSuccess(!0);
                },
                onCancel: i,
                bDisableBackgroundDismiss: !1,
                bOKDisabled: g || f || S.bLoading,
              },
              g &&
                a.createElement(
                  "div",
                  { className: be.ErrorStylesWithIcon },
                  (0, p.we)("#AssetSet_Dialog_Disallowed"),
                ),
              f &&
                a.createElement(
                  "div",
                  { className: be.ErrorStylesWithIcon },
                  (0, p.we)("#AssetSet_Dialog_MustHaveName"),
                ),
              a.createElement(m.pd, {
                type: "text",
                label: (0, p.we)("#AssetSet_Dialog_Edit_Name"),
                value: o,
                onChange: (e) => {
                  c(e?.currentTarget?.value || "");
                },
              }),
              a.createElement(m.pd, {
                type: "text",
                label: (0, p.we)("#AssetSet_Dialog_Edit_Description"),
                value: d,
                onChange: (e) => {
                  u(e?.currentTarget?.value || "");
                },
              }),
            );
      }
      function ya(e) {
        const { appid: t } = e,
          { hiddenAssetSetID: r } = J(t);
        return a.createElement(
          "div",
          { className: (0, Te.A)(Re.Unassigned, da.Ctn) },
          a.createElement(
            "div",
            { className: da.Title },
            a.createElement(
              "div",
              { className: da.TopRow },
              a.createElement(
                "div",
                { className: da.TitleText },
                (0, p.we)("#TimelineMarkers_Hidden_section_info"),
              ),
              a.createElement(Ta, { appid: t }),
              a.createElement(ne, { appid: t, assetSetID: r }),
            ),
          ),
          a.createElement(
            "div",
            null,
            Boolean(r)
              ? a.createElement(Ee, {
                  appid: t,
                  assetSetID: r,
                  strMessageOnEmpty: (0, p.we)("#TimelineMarkers_Hidden_none"),
                  bDraggable: !0,
                })
              : a.createElement(
                  "div",
                  { className: Re.NoHidden },
                  (0, p.we)("#TimelineMarkers_Hidden_none"),
                ),
          ),
          a.createElement(
            "div",
            { className: (0, Te.A)(Re.DragCtn, Re.Row) },
            a.createElement(
              "div",
              { className: Re.BurgerWrapper },
              a.createElement(ye.wVV, { size: "10px" }),
            ),
            " ",
            (0, p.we)("#TimelineMarkers_drag_source_public"),
          ),
        );
      }
      function Ta(e) {
        const { appid: t } = e,
          { hiddenAssetSetID: r } = J(t),
          i = fe(t, r);
        return a.createElement(
          m.$n,
          {
            disabled: !r || !i || 0 == i.size,
            onClick: (e) =>
              (0, u.pg)(a.createElement(Ba, { appid: t }), (0, g.uX)(e)),
          },
          "",
          " ",
          (0, p.we)("#TimelineMarkers_MoveAllHiddenToPublic"),
        );
      }
      function Ba(e) {
        const { appid: t, closeModal: r } = e,
          { hiddenAssetSetID: i, publicAssetSetID: n } = J(t),
          s = fe(t, i),
          l = (0, Se.vs)();
        return l.bLoading
          ? a.createElement(Se.Hh, {
              state: l,
              strDialogTitle: (0, p.we)(
                "#TimelineMarkers_MoveAllHiddenToPublic",
              ),
              closeModal: r,
            })
          : a.createElement(Me.o0, {
              strTitle: (0, p.we)("#TimelineMarkers_MoveAllHiddenToPublic"),
              strDescription: (0, p.we)("#Dialog_AreYouSure"),
              onCancel: r,
              bOKDisabled: !s,
              onOK: async () => {
                l.fnSetLoading(!0);
                const e = Array.from(s);
                let r = n;
                for (let n = 0; n < e.length; ++n) {
                  const a = e[n];
                  r = await ha(i, a, r, t);
                }
                l.fnSetSuccess(!0);
              },
            });
      }
      function va(e) {
        const { appid: t } = e;
        return a.createElement(
          "div",
          { className: Re.CreateNewCtn },
          a.createElement(
            "div",
            null,
            (0, p.we)("#TimelineMarkers_Hidden_new_asset_set_desc"),
          ),
          a.createElement(
            m.$n,
            {
              onClick: (e) =>
                (0, u.pg)(a.createElement(Ma, { appid: t }), (0, g.uX)(e)),
            },
            (0, p.we)("#TimelineMarkers_Hidden_new_asset_set"),
          ),
        );
      }
      function Ra(e) {
        const { oAssetSet: t } = e;
        return t.name == X
          ? a.createElement(
              "span",
              null,
              (0, p.we)("#TimelineMarkers_Public_title"),
            )
          : t.name == V
            ? a.createElement(
                "span",
                null,
                (0, p.we)("#TimelineMarkers_Hidden_title"),
              )
            : a.createElement("span", null, t.name);
      }
      class Ga {
        m_vecBranches = new Array();
        m_mapBranchNameToDetails = new Map();
        GetBranchDetails() {
          return this.m_vecBranches;
        }
        GetBranchDetailsByName(e) {
          return this.m_mapBranchNameToDetails.get(e);
        }
        static s_Singleton;
        static Get() {
          return (
            Ga.s_Singleton ||
              ((Ga.s_Singleton = new Ga()),
              Ga.s_Singleton.Init(),
              "dev" == L.TS.WEB_UNIVERSE &&
                (window.g_BranchNameStore = Ga.s_Singleton)),
            Ga.s_Singleton
          );
        }
        Init() {
          let e = (0, L.Tc)("branch_details", "application_config");
          this.ValidateStoreDefault(e) &&
            ((this.m_vecBranches = e),
            this.m_vecBranches.forEach((e) =>
              this.m_mapBranchNameToDetails.set(e.name, e),
            ));
        }
        ValidateStoreDefault(e) {
          const t = e;
          return !!(
            t &&
            Array.isArray(t) &&
            t.length > 0 &&
            "string" == typeof t[0].name
          );
        }
      }
      var wa = r(82237);
      function Ca(e) {
        const { oAssetSet: t } = e;
        return a.createElement(
          "div",
          { className: wa.BranchDefCtn },
          a.createElement(
            "div",
            { className: wa.BranchDesc },
            (0, p.we)("#TimelineMarkers_Hidden_controls"),
          ),
          t.branches?.length > 0
            ? a.createElement(
                a.Fragment,
                null,
                t.branches.map((e) =>
                  a.createElement(
                    "span",
                    { key: e, className: wa.BranchName },
                    a.createElement(Ia, { branchName: e }),
                  ),
                ),
              )
            : a.createElement(
                "div",
                null,
                (0, p.we)("#TimelineMarkers_Hidden_nobranches"),
              ),
          a.createElement("br", null),
          a.createElement(
            m.$n,
            {
              onClick: (e) => {
                (0, u.pg)(a.createElement(Ea, { oAssetSet: t }), (0, g.uX)(e));
              },
            },
            (0, p.we)("#TimelineMarkers_Hidden_updatebranches"),
          ),
          a.createElement(
            m.$n,
            { onClick: () => {} },
            (0, p.we)("#TimelineMarkers_Hidden_publishbranch"),
          ),
        );
      }
      function Ea(e) {
        const { oAssetSet: t, closeModal: r } = e,
          i = Ga.Get().GetBranchDetails(),
          [n, s] = (0, a.useState)(new Set(t.branches || [])),
          { fnAddBranchToAssetSet: l, fnRemoveBranchFromAssetSet: o } = K(),
          c = (0, Se.vs)();
        return c.bLoading
          ? a.createElement(Se.Hh, {
              state: c,
              strDialogTitle: (0, p.we)(
                "#TimelineMarkers_Hidden_updatebranches",
              ),
              closeModal: r,
            })
          : a.createElement(
              Me.o0,
              {
                strTitle: (0, p.we)("#TimelineMarkers_Hidden_updatebranches"),
                strDescription: (0, p.we)("#AssetSet_Branch_Dialog_Desc"),
                onCancel: r,
                onOK: async () => {
                  c.fnSetLoading(!0);
                  const e = Array.from(n);
                  let r = 0,
                    i = 0;
                  for (let i = 0; i < e.length; ++i) {
                    const n = e[i];
                    if (!t.branches?.includes(n)) {
                      if (
                        (await l(t.appid, t.assetset_id, n)) != _.d.k_EResultOK
                      )
                        return void c.fnSetError(!0);
                      r++;
                    }
                  }
                  const a = [...(t.branches || [])];
                  for (let e = 0; e < a.length; ++e) {
                    const r = a[e];
                    if (!n.has(r)) {
                      if (
                        (await o(t.appid, t.assetset_id, r)) != _.d.k_EResultOK
                      )
                        return void c.fnSetError(!0);
                      i++;
                    }
                  }
                  0 == r && 0 == i
                    ? c.fnSetStrSuccess(
                        (0, p.we)("#AssetSet_Branch_Dialog_nochange"),
                      )
                    : c.fnSetStrSuccess(
                        (0, p.we)("#AssetSet_Branch_Dialog_updated", r, i),
                      ),
                    c.fnSetSuccess(!0);
                },
              },
              a.createElement("br", null),
              i.map((e) =>
                a.createElement(m.Yh, {
                  key: e.name,
                  label: a.createElement(Ia, { branchName: e.name }),
                  tooltip: e.description,
                  checked: n.has(e.name),
                  onChange: (t) => {
                    const r = new Set(n);
                    t ? r.add(e.name) : r.delete(e.name), s(r);
                  },
                }),
              ),
            );
      }
      function Ia(e) {
        const { branchName: t } = e,
          r = ((i = t), Ga.Get().GetBranchDetailsByName(i));
        var i;
        return a.createElement(
          "span",
          { className: wa.Lock },
          r?.password?.length > 0 &&
            a.createElement(
              ie.he,
              {
                toolTipContent: (0, p.we)("#AssetSet_Branch_Dialog_password"),
                bTopmost: !0,
              },
              a.createElement("span", null, " "),
            ),
          t,
        );
      }
      function ka(e) {
        const { appid: t, assetSetID: r, closeModal: i } = e,
          n = $(t, r),
          s = (function (e) {
            const [t, r] = (0, a.useState)(() => Z.Get().GetAllAssetSets(e));
            return (0, j.hL)(Z.Get().GetAppAssetSetListChangeCallback(e), r), t;
          })(t),
          l = _e(t),
          [o, c] = (0, a.useState)(null),
          { fnCreateTimelineMarkerDefinition: d } = ce(),
          { hiddenAssetSetID: u } = J(t),
          g = (0, a.useMemo)(() => {
            const e = new Set();
            ue(n.assetset_id).forEach((t) => e.add(t));
            const t = new Map();
            s.forEach((e) => {
              e.assetset_id != n.assetset_id && t.set(e.assetset_id, e);
            });
            return l
              .filter(
                (t) =>
                  !(
                    (t.unpublished_changes && t.asset_set_id != u) ||
                    e.has(t.markerid)
                  ),
              )
              .map((e) => ({
                label: a.createElement(
                  a.Fragment,
                  null,
                  a.createElement(we, { svgXmlUntrusted: e.image }),
                  e.markerid,
                  " ",
                  "(",
                  a.createElement(Ra, { oAssetSet: t.get(e.asset_set_id) }),
                  ")",
                ),
                data: e,
              }));
          }, [n.assetset_id, s, l, u]),
          f = (0, Se.vs)();
        return f.bLoading
          ? a.createElement(Se.Hh, {
              state: f,
              strDialogTitle: (0, p.we)("#TimelineMarker_Clone_title"),
              closeModal: i,
            })
          : a.createElement(
              Me.o0,
              {
                strTitle: (0, p.we)("#TimelineMarker_Clone_title"),
                strDescription: (0, p.we)("#TimelineMarker_Clone_desc", n.name),
                onCancel: i,
                bOKDisabled: !o,
                onOK: async () => {
                  f.fnSetLoading(!0);
                  (await d(t, r, o.markerid, o.image, o.image_type)) ==
                  _.d.k_EResultOK
                    ? (f.fnSetStrSuccess(
                        (0, p.we)("#TimelineMarker_Clone_success"),
                      ),
                      f.fnSetSuccess(!0))
                    : f.fnSetError(!0);
                },
              },
              a.createElement("br", null),
              a.createElement("br", null),
              a.createElement(m.m, {
                rgOptions: g,
                selectedOption: o,
                onChange: (e) => c(e.data),
              }),
            );
      }
      var Pa = r(95034);
      function Oa(e) {
        const { appid: t } = e,
          r = (function (e) {
            const [t, r] = (0, a.useState)(() =>
              Z.Get().GetAllNonSpecialAssetSets(e),
            );
            return (
              (0, j.hL)(Z.Get().GetAppAssetSetListChangeCallback(e), (e) =>
                r(e.filter((e) => e.name != V && e.name != X)),
              ),
              t
            );
          })(t),
          [i] = (0, Pa.QD)("branchset", !1);
        return a.createElement(
          "div",
          { className: da.RestrictedIconsSection },
          a.createElement(
            "div",
            { className: da.Columns },
            a.createElement(
              "div",
              { className: da.LeftCol },
              a.createElement(
                "div",
                { className: d().SectionTitle },
                (0, p.we)("#TimelineMarkers_Hidden_title"),
              ),
              a.createElement(
                "div",
                null,
                (0, p.we)("#TimelineMarkers_Hidden_desc2"),
              ),
            ),
            a.createElement(ya, { appid: t }),
          ),
          i &&
            a.createElement(
              "div",
              { className: da.Columns },
              a.createElement(
                "div",
                { className: da.LeftCol },
                a.createElement(
                  "div",
                  { className: d().SectionTitle },
                  (0, p.we)("#TimelineMarkers_Hidden_branchsets_title"),
                ),
                a.createElement(va, { appid: t }),
              ),
              a.createElement(
                "div",
                { className: da.RightCol },
                r?.map((e) =>
                  a.createElement(za, {
                    key: e.assetset_id,
                    appid: t,
                    assetSetID: e.assetset_id,
                  }),
                ),
              ),
            ),
        );
      }
      function za(e) {
        const { appid: t, assetSetID: r } = e,
          i = $(t, r);
        return a.createElement(
          "div",
          { className: da.Ctn },
          a.createElement(
            "div",
            { className: da.Title },
            a.createElement(
              "div",
              { className: da.TopRow },
              a.createElement(
                ie.he,
                { toolTipContent: i.desc },
                a.createElement("div", { className: da.TitleText }, i.name),
              ),
              a.createElement(ne, {
                appid: i.appid,
                assetSetID: i.assetset_id,
              }),
            ),
            a.createElement(Ca, { oAssetSet: i }),
          ),
          a.createElement(
            "div",
            { className: da.CtnGridAndBranchSelection },
            a.createElement(
              "div",
              { className: da.GridCtn },
              a.createElement(Ee, {
                assetSetID: i.assetset_id,
                appid: i.appid,
                strMessageOnEmpty: "",
                bDraggable: !0,
              }),
              a.createElement(Pe, {
                assetSetID: i.assetset_id,
                appid: i.appid,
                strMessage: (0, p.we)("#TimelineMarkers_drag_target"),
              }),
            ),
            a.createElement(
              "div",
              null,
              a.createElement(
                m.$n,
                {
                  onClick: (e) =>
                    (0, u.pg)(
                      a.createElement(ka, { appid: t, assetSetID: r }),
                      (0, g.uX)(e),
                    ),
                },
                (0, p.we)("#TimelineMarker_Clone_title"),
              ),
            ),
          ),
        );
      }
      function Da(e) {
        const { appId: t } = e,
          r = Number.parseInt(t);
        return a.createElement(
          "div",
          { className: Sa.EditorCtn },
          a.createElement(
            s.JY,
            { onDragEnd: fa },
            a.createElement(Aa, { appid: r }),
            a.createElement(ba, { appid: r }),
            a.createElement(ga, { appid: r }),
            a.createElement(Oa, { appid: r }),
          ),
        );
      }
      function Aa(e) {
        const { appid: t } = e;
        return a.createElement(
          "div",
          { className: Sa.HeaderCtn },
          a.createElement(
            "div",
            { className: o().ColumnCtn },
            a.createElement(
              "div",
              { className: o().LeftCol },
              a.createElement(
                "div",
                { className: o().ColHeader },
                (0, p.we)("#TimelineMarkers_Editor_title"),
              ),
              a.createElement(
                "div",
                { className: o().SectionCtn },
                (0, p.we)("#TimelineMarkers_Editor_desc"),
              ),
            ),
            a.createElement(
              "div",
              { className: o().RightCol },
              a.createElement(
                "div",
                { className: o().ColHeader },
                a.createElement(
                  "a",
                  {
                    href: `${er.TS.PARTNER_BASE_URL}doc/features/timeline`,
                    className: (0, Te.A)(o().Button, d().Button),
                    target: "_blank",
                  },
                  (0, p.we)("#AssetRequest_General_SeeDocs"),
                ),
              ),
              a.createElement(
                "div",
                { className: o().SectionCtn },
                a.createElement(
                  m.jn,
                  {
                    onClick: (e) =>
                      (0, u.pg)(
                        a.createElement(aa, { appid: t }),
                        (0, g.uX)(e),
                      ),
                  },
                  (0, p.we)("#TimelineMarkers_Editor_createnew"),
                ),
                a.createElement(
                  "div",
                  null,
                  (0, p.we)("#TimelineMarkers_Editor_createnew_desc"),
                ),
              ),
            ),
          ),
        );
      }
    },
    86318: (e, t, r) => {
      "use strict";
      r.d(t, {
        ZI: () => o,
        fX: () => s,
        q_: () => a,
        tG: () => m,
        tH: () => l,
        xv: () => c,
      });
      const i = new (r(60778).wd)("GR");
      function n(e) {
        return (...t) => {
          const r = `[${(performance.now() / 1e3).toFixed(3)}]`;
          e(r, ...t);
        };
      }
      const a = n(i.Debug),
        s = n(i.Info),
        l = n(i.Warning),
        o = n(i.Error),
        m = a;
      function c() {
        return i.IsDebugEnabled();
      }
    },
    70692: (e, t, r) => {
      "use strict";
      r.d(t, {
        In: () => d,
        N$: () => u,
        Te: () => l,
        eJ: () => m,
        hT: () => s,
        il: () => i,
        rU: () => p,
        sX: () => g,
        xz: () => c,
        zG: () => o,
      });
      var i,
        n,
        a = r(53184);
      function s(e) {
        return "gamemode" === e.type;
      }
      function l(e) {
        return "state_description" === e.type;
      }
      function o(e) {
        return "event" === e.type && parseInt(e.duration) > 0;
      }
      function m(e) {
        return "event" === e.type;
      }
      function c(e) {
        return "achievement" === e.type;
      }
      function d(e) {
        return "error" === e.type;
      }
      function u(e) {
        return "usermarker" === e.type;
      }
      function g(e) {
        return "screenshot" === e.type;
      }
      function p(e) {
        let t = { id: e.entry_id, time: e.time, type: void 0 };
        switch (e.type) {
          case a.Bw.k_ETimelineEntryType_GameMode: {
            let r = t;
            (r.type = "gamemode"), (r.mode = e.game_mode);
            break;
          }
          case a.Bw.k_ETimelineEntryType_UserMarker: {
            let r = t;
            (r.type = "usermarker"),
              (r.icon = "steam_marker"),
              (r.priority = e.marker_priority);
            break;
          }
          case a.Bw.k_ETimelineEntryType_Achievement: {
            let r = t;
            (r.type = "achievement"), (r.achievement_name = e.achievement_name);
            break;
          }
          case a.Bw.k_ETimelineEntryType_Error: {
            let r = t;
            (r.type = "error"), (r.description = e.marker_description);
            break;
          }
          case a.Bw.k_ETimelineEntryType_StateDescription: {
            let r = t;
            (r.type = "state_description"), (r.title = e.timestamp_title);
            break;
          }
          case a.Bw.k_ETimelineEntryType_Event: {
            let r = t;
            (r.type = "event"),
              (r.icon = e.marker_icon),
              (r.title = e.range_title),
              (r.description = e.marker_description),
              (r.priority = e.marker_priority),
              (r.duration = e.range_duration),
              (r.possible_clip = e.range_possible_clip);
            break;
          }
          case a.Bw.k_ETimelineEntryType_Screenshot: {
            let r = t;
            (r.type = "screenshot"),
              (r.icon = e.marker_icon),
              (r.priority = e.marker_priority),
              (r.handle = e.screenshot_handle);
            break;
          }
          default:
            return null;
        }
        return t;
      }
      !(function (e) {
        (e[(e.Invalid = 0)] = "Invalid"),
          (e[(e.Playing = 1)] = "Playing"),
          (e[(e.Staging = 2)] = "Staging"),
          (e[(e.Menus = 3)] = "Menus");
      })(i || (i = {})),
        (function (e) {
          (e[(e.Invalid = 0)] = "Invalid"),
            (e[(e.None = 1)] = "None"),
            (e[(e.Standard = 2)] = "Standard"),
            (e[(e.Featured = 3)] = "Featured");
        })(n || (n = {}));
    },
    4926: (e, t, r) => {
      "use strict";
      function i(e) {
        return { type: "global", valMS: e };
      }
      function n(e) {
        return { type: "timeline", valMS: e };
      }
      function a(e) {
        return (t) => t.type === e;
      }
      r.d(t, { OB: () => s, QP: () => l, Sb: () => i, sK: () => n });
      a("global"), a("timeline"), a("recording"), a("clip");
      function s(e) {
        return { type: "global", valPX: e };
      }
      function l(e) {
        return { type: "scrollWindow", valPX: e };
      }
      function o(e) {
        return (t) => t.type === e;
      }
      o("global"), o("clientWindow"), o("virtualWindow"), o("scrollWindow");
    },
    39393: (e, t, r) => {
      "use strict";
      r.d(t, { SX: () => y, kh: () => b });
      var i = r(34629),
        n = r(41735),
        a = r.n(n),
        s = r(53184),
        l = r(62490),
        o = r(86318),
        m = r(70692),
        c = r(37085),
        d = r(14771),
        u = r(6144),
        g = r(6419),
        p = r(4926),
        _ = (r(90626), r(14947)),
        f = r(29210),
        h = r(51006),
        S = r(81393);
      const b = 3e3,
        M = b + 1e3;
      class y {
        constructor() {
          (0, _.Gn)(this);
        }
        m_bInitialized = !1;
        m_rgListeners = [];
        m_gameID;
        m_clipID;
        m_ulFirstTimelineOffsetMS = 0;
        m_rgTimelineMetadata = [];
        m_mapTimelineData = new Map();
        m_mapRunningTimelines = new Map();
        m_schUpdateRunning = new u.LU();
        m_fnTimelineURLBuilder;
        BInitialized() {
          return this.m_bInitialized;
        }
        GetTimelines() {
          return this.m_rgTimelineMetadata;
        }
        GetTimelineMetadataIndex(e) {
          return this.m_rgTimelineMetadata.findIndex(
            (t) => t.metadata.timeline_id === e,
          );
        }
        GetTimelineMetadata(e) {
          return this.m_rgTimelineMetadata.find(
            (t) => t.metadata.timeline_id === e,
          );
        }
        GetGameID() {
          return this.m_gameID;
        }
        GetClipID() {
          return this.m_clipID;
        }
        BIsTimelineRunning(e) {
          return this.m_mapRunningTimelines.has(e);
        }
        AddEventListener(e) {
          return this.m_rgListeners.push(e), () => l.x9(this.m_rgListeners, e);
        }
        async LoadTimelinesForBackgroundVideo(e) {
          this.m_gameID = e;
          const t = await s.xM.GetTimelinesForApp({ game_id: e }),
            { timelines: r = [] } = t.Body().toObject();
          this.m_mapRunningTimelines.forEach((e, t) => {
            r.find((e) => e.timeline_id == t) || r.push(e.m_metadata);
          }),
            this.UpdateTimelineMetadata(r),
            (this.m_fnTimelineURLBuilder = (e) =>
              `https://steamloopback.host/gamerecordings/timelines/${e}.json`),
            (this.m_bInitialized = !0),
            this.FireEvent("OnLoaderInitialized");
        }
        async LoadTimelinesForClip(e) {
          this.m_clipID = e;
          const t = await s.xM.GetTimelinesForClip({ clip_id: e });
          if (t.GetEResult() != c.d.k_EResultOK)
            throw new Error("Unable to load clip " + e);
          const {
            timelines: r = [],
            game_id: i,
            first_timeline_start_offset_ms: n,
          } = t.Body().toObject();
          (this.m_gameID = i), this.UpdateTimelineMetadata(r);
          for (let t of this.m_rgTimelineMetadata) {
            (0, o.q_)(`Loaded clip ${e} timeline ${t.metadata.timeline_id}`);
            for (let e of t.metadata.recordings)
              (0, o.q_)(
                `Clip recording ${e.recording_id} duration ${e.duration_ms}`,
              );
          }
          (this.m_ulFirstTimelineOffsetMS = parseInt(n)),
            (this.m_fnTimelineURLBuilder = (e) =>
              `https://steamloopback.host/gamerecordings/clips/${this.m_clipID}/timelines/${e}.json`),
            (this.m_bInitialized = !0),
            this.FireEvent("OnLoaderInitialized");
        }
        UpdateTimelineMetadata(e) {
          const t = e.slice().sort((e, t) => e.date_recorded - t.date_recorded);
          let r = [],
            i = 0;
          const n = {};
          t.forEach((t) => {
            t.recordings || (t.recordings = []),
              n[t.timeline_id]
                ? console.error(
                    "Duplicate timelines found in UpdateTimelineMetadata()",
                    t.timeline_id,
                    e,
                  )
                : (r.push({ nGlobalOffsetMS: (0, p.Sb)(i), metadata: t }),
                  (i += parseInt(t.duration_ms)),
                  (n[t.timeline_id] = !0));
          }),
            (this.m_rgTimelineMetadata = r);
        }
        LoadTimelinesForSharedClip(e) {
          this.SetPreloadedTimelines(
            0,
            e.clip_id,
            e.game_id,
            e.timelines,
            void 0,
          );
        }
        LoadTimelinesForTestGame(e, t) {
          this.SetPreloadedTimelines(
            0,
            void 0,
            e,
            t,
            (e) =>
              `https://steamloopback.host/gamerecordings/timelines/${e}.json`,
          );
        }
        LoadTimelinesForTestClip(e, t, r, i) {
          this.SetPreloadedTimelines(e, t, r, i, void 0);
        }
        SetPreloadedTimelines(e, t, r, i, n) {
          (this.m_gameID = r),
            (this.m_clipID = t),
            (this.m_ulFirstTimelineOffsetMS = e);
          const a = i.slice();
          this.m_mapRunningTimelines.forEach((e, t) => {
            a.find((e) => e.timeline_id == t) || a.push(e.m_metadata);
          }),
            this.UpdateTimelineMetadata(a),
            (this.m_fnTimelineURLBuilder = n),
            (this.m_bInitialized = !0),
            this.FireEvent("OnLoaderInitialized");
        }
        FireEvent(e, ...t) {
          for (let r of this.m_rgListeners) {
            let i = r[e];
            i instanceof Function && i.apply(r, t);
          }
        }
        async LoadTimelineData(e) {
          let t = this.m_mapTimelineData.get(e);
          if (t && "loading" === t.m_strState) return void (await t.m_promise);
          if (t && "error" == t.m_strState) return;
          if (this.IsActiveTimeline(e) && "loaded" == t.m_strState) return;
          const r = {
            m_rgGameModeChanges: [],
            m_rgStateDescriptions: [],
            m_rgEntries: [],
            m_rgPhases: [],
          };
          if (this.m_fnTimelineURLBuilder) {
            const t = this.m_fnTimelineURLBuilder(e),
              i = a()
                .get(t, { withCredentials: !1 })
                .then(
                  (t) => {
                    if (200 == t.status && t.data) {
                      !(function (e) {
                        if (!Array.isArray(e.entries)) {
                          let t = [];
                          e.entries &&
                            "object" == typeof e.entries &&
                            ((t = Object.values(e.entries)),
                            (t = t.filter(
                              (e) => e && "object" == typeof e && "time" in e,
                            )),
                            t.sort(
                              (e, t) => parseInt(e.time) - parseInt(t.time),
                            )),
                            (e.entries = t);
                        }
                      })(t.data);
                      const r = this.ProcessTimelineEntries(t.data);
                      this.m_mapTimelineData.set(e, r);
                    } else
                      this.m_mapTimelineData.set(e, {
                        ...r,
                        m_strState: "error",
                      });
                  },
                  (t) => {
                    this.m_mapTimelineData.set(e, {
                      ...r,
                      m_strState: "error",
                    });
                  },
                )
                .finally(() => this.FireEvent("OnTimelineLoaded", e));
            this.m_mapTimelineData.set(e, {
              m_strState: "loading",
              m_promise: i,
              ...r,
            });
          } else this.m_mapTimelineData.set(e, { m_strState: "loaded", ...r });
        }
        ProcessTimelineEntries(e) {
          let t = {
            m_strState: "loaded",
            m_rgGameModeChanges: [],
            m_rgStateDescriptions: [],
            m_rgEntries: [],
            m_rgPhases: [],
          };
          if (e.entries) {
            const r = [],
              i = [],
              n = [],
              a = [];
            for (const t of e.entries)
              switch (t.type) {
                case "phase":
                  n.push(t);
                  break;
                case "gamemode":
                  r.push(t);
                  break;
                case "state_description":
                  i.push(t);
                  break;
                case "achievement":
                case "error":
                case "event":
                case "screenshot":
                case "usermarker":
                  a.push(t);
                  break;
                default:
                  console.error(`Unknown timeline entry type ${t.type}`);
              }
            const s = (e, t) => parseInt(e.time) - parseInt(t.time);
            (t.m_rgGameModeChanges = r.sort(s)),
              (t.m_rgStateDescriptions = i.sort(s)),
              (t.m_rgPhases = n.sort(s)),
              (t.m_rgEntries = a.sort(s)),
              t.m_rgGameModeChanges.length > 0 &&
                parseInt(t.m_rgGameModeChanges[0].time) < 1e4 &&
                (t.m_rgGameModeChanges[0].time = "0");
          }
          return t;
        }
        static ApplyTimelineRounding(e, t) {
          if (0 === t) return e;
          const r = e % t;
          return 0 == r ? e : e + (t - r);
        }
        FindTimelineAtOffset(e, t) {
          const r = e + this.m_ulFirstTimelineOffsetMS;
          let i = 0;
          for (let e of this.m_rgTimelineMetadata) {
            const n = this.GetTimelineStartBeforeGlobalZeroMS(
              e.metadata.timeline_id,
            );
            let a = parseInt(e.metadata.duration_ms) + n;
            if (i + a > r)
              return {
                timeline: e,
                nTimelineOffsetMS: r - i,
                ulGlobalToTimelineOffset: n,
              };
            i += y.ApplyTimelineRounding(a, t);
          }
          return null;
        }
        GetGlobalOffsetDataForTimeline(e, t) {
          let r = 0;
          for (let i of this.m_rgTimelineMetadata) {
            let n = parseInt(i.metadata.duration_ms),
              a = y.ApplyTimelineRounding(n, t);
            if (i.metadata.timeline_id == e)
              return { nGlobalOffsetMS: r, nRoundedDurationMS: a };
            r += a;
          }
          return null;
        }
        CreateGlobalRangeForTimeline(e, t, r, i) {
          let n = t - r,
            a = t + i;
          return this.ClampGlobalRangeToTimeline(e, n, a);
        }
        ClampGlobalRangeToTimeline(e, t, r) {
          let i = this.GetGlobalOffsetDataForTimeline(e, 0);
          return i
            ? [
                Math.max(t, i.nGlobalOffsetMS),
                Math.min(r, i.nGlobalOffsetMS + i.nRoundedDurationMS - 1),
              ]
            : [0, 0];
        }
        GetTimelineOffsetFromGlobal(e, t) {
          const r = this.m_ulFirstTimelineOffsetMS + e;
          let i = 0;
          for (let e of this.m_rgTimelineMetadata) {
            const n = this.GetTimelineStartBeforeGlobalZeroMS(
                e.metadata.timeline_id,
              ),
              a = parseInt(e.metadata.duration_ms) + n;
            if (r < i + y.ApplyTimelineRounding(a, t))
              return {
                strTimelineID: e.metadata.timeline_id,
                nTimelineOffsetMS: (0, p.sK)(r - i - n),
              };
            i += a;
          }
          return { strTimelineID: void 0, nTimelineOffsetMS: (0, p.sK)(NaN) };
        }
        ConvertRecordingOffsetToGlobalOffset(e, t, r) {
          let i = 0;
          for (let n of this.m_rgTimelineMetadata) {
            let a = parseInt(n.metadata.duration_ms);
            const s = this.GetTimelineStartBeforeGlobalZeroMS(
              n.metadata.timeline_id,
            );
            let l = y.ApplyTimelineRounding(a, r);
            for (let r of n.metadata.recordings)
              if (r.recording_id === e) {
                let e =
                  (isNaN(parseInt(r.recording_zero_timeline_offset_ms))
                    ? 0
                    : parseInt(r.recording_zero_timeline_offset_ms) - s) + t;
                return (
                  (i += e),
                  {
                    nGlobalOffsetMS: i,
                    nRoundedDurationMS: l,
                    strTimelineID: n.metadata.timeline_id,
                    nTimelineOffsetMS: e,
                  }
                );
              }
            i += l;
          }
          return null;
        }
        IsActiveTimeline(e) {
          return !!e && this.m_mapRunningTimelines.has(e);
        }
        MakeRelativeToTimelineEndIfActive(e, t) {
          if (!this.IsActiveTimeline(e)) return t;
          const r = this.GetTimelineMetadata(e);
          if (!r) return t;
          let i = parseInt(r.metadata.duration_ms);
          return Math.min(t - i, 0);
        }
        IsActiveRecording(e) {
          for (let t of this.m_rgTimelineMetadata)
            for (let r of t.metadata.recordings)
              if (r.recording_id === e) {
                const r = this.m_mapRunningTimelines.get(
                  t.metadata.timeline_id,
                );
                return (
                  !(!r || !r.m_runningRecording) &&
                  r.m_runningRecording.recording_id === e
                );
              }
          return !1;
        }
        GetRunningTimelineDurationMS(e) {
          let t = this.m_mapRunningTimelines.get(e);
          if (!t) return 0;
          let r =
              performance.now() -
              t.m_perfCounterStart +
              t.m_nPerfCounterOffsetMS,
            i = parseInt(t.m_metadata.duration_ms) || 0;
          return Math.max(r, i);
        }
        GetRunningTimelineForRecording(e, t) {
          const r = this.m_mapRunningTimelines.get(e);
          return r &&
            r.m_runningRecording &&
            r.m_runningRecording.recording_id === t
            ? r
            : null;
        }
        ConvertGlobaOffsetToRecordingAndRelativeOffset(e) {
          if (!this.m_bInitialized) return null;
          let t = this.FindTimelineAtOffset(e, 0);
          if (!t) return null;
          let r = t.nTimelineOffsetMS - t.ulGlobalToTimelineOffset;
          for (let e of t.timeline.metadata.recordings) {
            let i = parseInt(e.start_offset_ms);
            if (i + parseInt(e.duration_ms) < r || i > r) continue;
            let n = parseInt(e.recording_zero_timeline_offset_ms),
              a = Math.max(r - i, 0);
            return (
              isNaN(n) || (a = Math.max(t.nTimelineOffsetMS - n, 0)),
              {
                strRecordingID: e.recording_id,
                nRecordingOffsetMS: a,
                nStartOffsetMS: i,
              }
            );
          }
          return null;
        }
        async FindRecordingAndOffsetForEntry(e) {
          for (const t of this.m_mapRunningTimelines.keys()) {
            if (!this.IsActiveTimeline(t)) continue;
            await this.LoadTimelineData(t);
            const r = this.m_mapTimelineData.get(t),
              i = this.m_mapRunningTimelines.get(t);
            if (r && i) {
              for (const t of r.m_rgEntries)
                if (t.id == e) {
                  const e = parseInt(t.time);
                  for (const t of i.m_metadata.recordings) {
                    const r = parseInt(t.start_offset_ms),
                      i = r + parseInt(t.duration_ms);
                    if (e >= r && e <= i)
                      return {
                        strRecordingID: t.recording_id,
                        nRecordingOffsetMS: e,
                        nStartOffsetMS: r,
                      };
                  }
                }
              break;
            }
          }
        }
        GetClosestNextRecordingInGlobalTimeline(e) {
          for (let t of this.m_rgTimelineMetadata)
            for (let r of t.metadata.recordings) {
              if (
                parseInt(r.start_offset_ms) + t.nGlobalOffsetMS.valMS >
                e.valMS
              )
                return r;
            }
          return null;
        }
        GetClosestPreviousRecordingInGlobalTimeline(e) {
          let t = null;
          for (let r of this.m_rgTimelineMetadata)
            for (let i of r.metadata.recordings) {
              if (
                parseInt(i.start_offset_ms) + r.nGlobalOffsetMS.valMS >
                e.valMS
              )
                return t;
              t = i;
            }
          return t;
        }
        ConvertRecordingTimeMStoPreTrimTimeMS(e, t) {
          for (let r of this.m_rgTimelineMetadata)
            for (let i of r.metadata.recordings)
              if (i.recording_id === e) {
                const e = parseInt(i.recording_zero_timeline_offset_ms),
                  n = this.GetTimelineStartBeforeGlobalZeroMS(
                    r.metadata.timeline_id,
                  );
                return !n || isNaN(e) ? t : t + n - e;
              }
          return t;
        }
        GetTimelineDataOrStartLoad(e) {
          if (!e) return null;
          let t = this.m_mapTimelineData.get(e);
          return (
            t ||
              (this.LoadTimelineData(e), (t = this.m_mapTimelineData.get(e))),
            t
          );
        }
        GetTimelineData(e) {
          return this.m_mapTimelineData.get(e);
        }
        SetTimelineData(e, t) {
          const r = this.ProcessTimelineEntries(t);
          this.m_mapTimelineData.set(e, r);
        }
        GetClosestPreviousEntryInTimeline(e, t) {
          const r = this.GetTimelineMetadata(e),
            i = this.GetTimelineStartBeforeGlobalZeroMS(e),
            n = this.GetTimelineDataOrStartLoad(e);
          let a = null;
          if (n && "loaded" === n.m_strState) {
            const e = n.m_rgEntries.filter((e) => {
                const t = parseInt(e.time);
                return t < i + parseInt(r.metadata.duration_ms) && t > i;
              }),
              s = l.rJ(e, (e) => t.valMS - 1 - parseInt(e.time));
            -1 !== s && (a = e[s]);
          }
          return { entry: a, timelineState: n?.m_strState };
        }
        GetClosestNextEntryInTimeline(e, t) {
          const r = this.GetTimelineMetadata(e),
            i = this.GetTimelineStartBeforeGlobalZeroMS(e),
            n = this.GetTimelineDataOrStartLoad(e);
          let a = null;
          if (n && "loaded" === n.m_strState) {
            const e = n.m_rgEntries.filter((e) => {
                const t = parseInt(e.time);
                return t < i + parseInt(r.metadata.duration_ms) && t > i;
              }),
              s = l.rJ(e, (e) => t.valMS - parseInt(e.time));
            s < e.length - 1 && (a = e[s + 1]);
          }
          return { entry: a, timelineState: n?.m_strState };
        }
        GetClosestPreviousEntryInGlobalTimeline(e) {
          const t = this.GetTimelineOffsetFromGlobal(e, 0),
            r = this.GetTimelineData(t.strTimelineID);
          if (!r || "loaded" !== r.m_strState)
            return {
              timelineID: t?.strTimelineID,
              timelineState: r?.m_strState,
              entry: null,
              globalMS: null,
            };
          const i = this.GetTimelineStartBeforeGlobalZeroMS(t.strTimelineID),
            n = t.nTimelineOffsetMS.valMS + i,
            a = l.rJ(r.m_rgEntries, (e) => n - parseInt(e.time));
          if (-1 !== a) {
            const e = r.m_rgEntries[a],
              n =
                this.GetTimelineMetadata(t.strTimelineID).nGlobalOffsetMS
                  .valMS -
                i +
                parseInt(e.time);
            return n < 0
              ? {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                }
              : {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: e,
                  globalMS: (0, p.Sb)(n),
                };
          }
          let s = this.GetTimelineMetadataIndex(t.strTimelineID);
          if (s < 1)
            return {
              timelineID: t.strTimelineID,
              timelineState: r.m_strState,
              entry: null,
              globalMS: null,
            };
          for (let e = s - 1; e >= 0; e--) {
            const t = this.m_rgTimelineMetadata[e],
              r = this.GetTimelineData(t.metadata.timeline_id);
            if (r) {
              if ("loaded" !== r.m_strState)
                return {
                  timelineID: t.metadata.timeline_id,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                };
              if (r.m_rgEntries.length) {
                const e = r.m_rgEntries[r.m_rgEntries.length - 1],
                  i = this.GetTimelineStartBeforeGlobalZeroMS(
                    t.metadata.timeline_id,
                  ),
                  n = t.nGlobalOffsetMS.valMS - i + parseInt(e.time);
                return n < 0
                  ? {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: null,
                      globalMS: null,
                    }
                  : {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: e,
                      globalMS: (0, p.Sb)(n),
                    };
              }
            }
          }
          return {
            timelineID: this.m_rgTimelineMetadata[0].metadata.timeline_id,
            timelineState: "loaded",
            entry: null,
            globalMS: null,
          };
        }
        GetClosestNextEntryInGlobalTimeline(e) {
          const t = this.GetTimelineOffsetFromGlobal(e, 0),
            r = this.GetTimelineData(t.strTimelineID);
          if (!r || "loaded" !== r.m_strState)
            return {
              timelineID: t?.strTimelineID,
              timelineState: r?.m_strState,
              entry: null,
              globalMS: null,
            };
          const i = this.GetTimelineStartBeforeGlobalZeroMS(t.strTimelineID),
            n = t.nTimelineOffsetMS.valMS + i,
            a = l.rJ(r.m_rgEntries, (e) => n - parseInt(e.time)) + 1;
          if (a <= r.m_rgEntries.length - 1) {
            const e = r.m_rgEntries[a],
              n =
                this.GetTimelineMetadata(t.strTimelineID).nGlobalOffsetMS
                  .valMS -
                i +
                parseInt(e.time);
            return n < this.GetGlobalTimelineEndMS().valMS
              ? {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: e,
                  globalMS: (0, p.Sb)(n),
                }
              : {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                };
          }
          const s = this.m_rgTimelineMetadata.length;
          let o = this.GetTimelineMetadataIndex(t.strTimelineID);
          if (-1 === o || o === s - 1)
            return {
              timelineID: t.strTimelineID,
              timelineState: r.m_strState,
              entry: null,
              globalMS: null,
            };
          for (let e = o + 1; e < s; e++) {
            const t = this.m_rgTimelineMetadata[e],
              r = this.GetTimelineData(t.metadata.timeline_id);
            if (r) {
              if ("loaded" !== r.m_strState)
                return {
                  timelineID: t.metadata.timeline_id,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                };
              if (r.m_rgEntries.length) {
                const e = r.m_rgEntries[0],
                  i = this.GetTimelineStartBeforeGlobalZeroMS(
                    t.metadata.timeline_id,
                  ),
                  n = t.nGlobalOffsetMS.valMS - i + parseInt(e.time);
                return n < this.GetGlobalTimelineEndMS().valMS
                  ? {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: e,
                      globalMS: (0, p.Sb)(n),
                    }
                  : {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: null,
                      globalMS: null,
                    };
              }
            }
          }
          return {
            timelineID: this.m_rgTimelineMetadata[s - 1].metadata.timeline_id,
            timelineState: "loaded",
            entry: null,
            globalMS: null,
          };
        }
        FindRangeEventsAtGlobalMS(e) {
          const t = this.GetTimelineOffsetFromGlobal(e, 0),
            r = this.GetTimelineDataOrStartLoad(t.strTimelineID);
          if (!r || "loaded" !== r.m_strState) return [];
          const i = [];
          for (const e of r.m_rgEntries) {
            if (parseInt(e.time) > t.nTimelineOffsetMS.valMS) break;
            if ("event" !== e.type || 0 == parseInt(e.duration)) continue;
            const r = parseInt(e.time),
              n = r + parseInt(e.duration);
            r <= t.nTimelineOffsetMS.valMS &&
              n >= t.nTimelineOffsetMS.valMS &&
              i.push(e);
          }
          return i;
        }
        GetStateDescriptionAtGlobalMS(e) {
          const t = this.GetTimelineOffsetFromGlobal(e.valMS, 0),
            r = this.GetTimelineDataOrStartLoad(t.strTimelineID);
          if (!r || "loaded" !== r.m_strState) return null;
          const i = l.rJ(
            r.m_rgStateDescriptions,
            (e) => t.nTimelineOffsetMS.valMS - parseInt(e.time),
          );
          return i > -1 ? r.m_rgStateDescriptions[i] : null;
        }
        AdvanceGameModeIndex(e) {
          let t = e.m_iGameModeChanges;
          for (; t + 1 < e.m_data.m_rgGameModeChanges.length; ) {
            let r = e.m_data.m_rgGameModeChanges[t + 1];
            if (parseInt(r.time) > e.m_nTimelineOffsetMS) break;
            t++;
          }
          e.m_iGameModeChanges = t;
        }
        AdvanceEntriesIndex(e) {
          for (
            -1 == e.m_iEntries && e.m_iEntries++;
            e.m_iEntries < e.m_data.m_rgEntries.length;
          ) {
            let t = e.m_data.m_rgEntries[e.m_iEntries];
            if (parseInt(t.time) >= e.m_nTimelineOffsetMS) break;
            e.m_iEntries++;
          }
        }
        CreateTimelineIterator(e, t) {
          let r = this.FindTimelineAtOffset(e, t);
          if (!r)
            return {
              m_timeline: null,
              m_data: null,
              m_nTimelineOffsetMS: 0,
              m_iGameModeChanges: -1,
              m_iEntries: -1,
            };
          let i = this.GetTimelineDataOrStartLoad(
              r.timeline.metadata.timeline_id,
            ),
            n = -1,
            a = -1;
          if ("loaded" == i?.m_strState) {
            let e = (e) => r.ulGlobalToTimelineOffset - parseInt(e.time);
            (n = l.rJ(i.m_rgGameModeChanges, e)), (a = l.rJ(i.m_rgEntries, e));
          }
          let s = {
            m_timeline: r.timeline.metadata,
            m_data: i,
            m_nTimelineOffsetMS: Math.max(r.ulGlobalToTimelineOffset, 0),
            m_iGameModeChanges: n,
            m_iEntries: a,
          };
          return this.AdvanceEntriesIndex(s), this.AdvanceGameModeIndex(s), s;
        }
        HasIteratorReachedEnd(e) {
          return !e.m_timeline;
        }
        AdvanceIterator(e, t) {
          let r = parseInt(e.m_timeline.duration_ms);
          if (e.m_nTimelineOffsetMS + t < r + this.m_ulFirstTimelineOffsetMS)
            return (
              (e.m_nTimelineOffsetMS += t),
              this.AdvanceEntriesIndex(e),
              void this.AdvanceGameModeIndex(e)
            );
          let i = this.m_rgTimelineMetadata.findIndex(
            (t) => t.metadata == e.m_timeline,
          );
          i < 0 || i == this.m_rgTimelineMetadata.length - 1
            ? (e.m_timeline = null)
            : (i++,
              (e.m_timeline = this.m_rgTimelineMetadata[i].metadata),
              (e.m_data = this.GetTimelineDataOrStartLoad(
                e.m_timeline.timeline_id,
              )),
              (e.m_nTimelineOffsetMS = 0),
              (e.m_iGameModeChanges = 0),
              (e.m_iEntries = 0));
        }
        GetIteratorTimelineState(e) {
          return e.m_data.m_strState;
        }
        GetIteratorGameMode(e) {
          return e.m_iGameModeChanges < 0 ||
            e.m_iGameModeChanges >= e.m_data.m_rgGameModeChanges.length
            ? m.il.Playing
            : e.m_data.m_rgGameModeChanges[e.m_iGameModeChanges].mode;
        }
        *GetIteratorEntriesWithin(e, t) {
          let r = e.m_data.m_rgEntries;
          for (let i = e.m_iEntries; i >= 0 && i < r.length; i++) {
            let n = r[i];
            if (parseInt(n.time) >= e.m_nTimelineOffsetMS + t) break;
            yield n;
          }
        }
        *GetIteratorGameModesWithin(e, t) {
          let r = e.m_data.m_rgGameModeChanges;
          for (let i = e.m_iEntries; i >= 0 && i < r.length; i++) {
            let n = r[i];
            if (parseInt(n.time) >= e.m_nTimelineOffsetMS + t) break;
            yield n;
          }
        }
        GetFirstRecording() {
          if (!this.m_bInitialized) return "";
          const e = this.m_rgTimelineMetadata[0];
          if (!e) return "";
          const t = e.metadata.recordings[0];
          return t ? t.recording_id : "";
        }
        GetFirstRecordingOfLastTimelineSession() {
          if (!this.m_bInitialized) return "";
          const e =
            this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1];
          if (!e) return "";
          const t = e.metadata.recordings[0];
          return t ? t.recording_id : "";
        }
        GetNextRecording(e) {
          if (!this.m_bInitialized || !e) return "";
          let t = !1;
          for (let r of this.m_rgTimelineMetadata)
            for (let i of r.metadata.recordings) {
              if (t) return i.recording_id;
              i.recording_id == e && (t = !0);
            }
          return "";
        }
        BRecordingHasZeroOffset(e) {
          if (!this.m_bInitialized) return !1;
          for (let t of this.m_rgTimelineMetadata)
            for (let r of t.metadata.recordings)
              if (r.recording_id == e)
                return !isNaN(parseInt(r.recording_zero_timeline_offset_ms));
          return !1;
        }
        GetTimelineDateMS(e, t) {
          if (!this.m_bInitialized) return 0;
          let r = this.FindTimelineAtOffset(e, t);
          return r
            ? 1e3 * r.timeline.metadata.date_recorded + r.nTimelineOffsetMS
            : 0;
        }
        InsertEntryIntoTimelineSorted(e, t) {
          l.Xr(e.m_rgEntries, t, (e, t) => parseInt(e.time) - parseInt(t.time));
        }
        AddEventToTimeline(e, t, r, i, n, a, s, l) {
          if (!this.m_bInitialized)
            return (0, o.ZI)("timeline loader not initialized, unexpected"), !1;
          const m = this.m_mapTimelineData.get(e);
          if (!m) return (0, o.ZI)(`failed to find timeline ${e}`), !1;
          const c = t + this.GetTimelineStartBeforeGlobalZeroMS(e),
            d = {
              id: i,
              time: c + "",
              type: "event",
              icon: r,
              title: a,
              description: s,
              priority: n,
              duration: `${l}`,
              possible_clip: 2,
            };
          return (
            (0, o.tG)(`adding timeline event marker at ${e} at ${c} MS`),
            this.InsertEntryIntoTimelineSorted(m, d),
            this.FireEvent("OnInvalidate", e),
            !0
          );
        }
        RemoveTimelineEvent(e, t) {
          if (!this.m_bInitialized)
            return (0, o.ZI)("timeline loader not initialized, unexpected"), !1;
          const r = this.m_mapTimelineData.get(e);
          if (!r) return (0, o.ZI)(`failed to find timeline ${e}`), !1;
          const i = r.m_rgEntries.findIndex((e) => e.id === t);
          return i < 0
            ? ((0, o.ZI)(`failed to find entry by id: ${t}`), !1)
            : (r.m_rgEntries.splice(i, 1),
              this.FireEvent("OnInvalidate", e),
              !0);
        }
        AddUserMarker(e, t, r, i) {
          if (!this.m_bInitialized)
            return (0, o.ZI)("timeline loader not initialized, unexpected"), !1;
          const n = this.m_mapTimelineData.get(e);
          if (!n) return (0, o.ZI)(`failed to find timeline ${e}`), !1;
          const a = t + this.GetTimelineStartBeforeGlobalZeroMS(e),
            s = {
              id: i,
              time: a + "",
              type: "usermarker",
              icon: r,
              title: "",
              description: "",
              priority: 0,
            };
          return (
            (0, o.tG)(`adding user marker at ${e} at ${a} MS`),
            this.InsertEntryIntoTimelineSorted(n, s),
            this.FireEvent("OnInvalidate", e),
            !0
          );
        }
        UpdateUserMarker(e, t, r) {
          if (!this.m_bInitialized)
            return (0, o.ZI)("timeline loader not initialized, unexpected"), !1;
          const i = this.m_mapTimelineData.get(e);
          if (!i) return (0, o.ZI)(`failed to find timeline ${e}`), !1;
          const n = i.m_rgEntries.findIndex((e) => e.id === t);
          if (n < 0) return (0, o.ZI)(`failed to find entry by id: ${t}`), !1;
          const a = i.m_rgEntries[n],
            s = a.time;
          return (
            (a.icon = r.strIcon),
            (a.time = "" + r.nTimelineOffsetMS),
            (a.title = r.name),
            (a.description = r.description),
            s != a.time &&
              (i.m_rgEntries.splice(n, 1),
              this.InsertEntryIntoTimelineSorted(i, a)),
            this.FireEvent("OnInvalidate", e),
            !0
          );
        }
        RemoveUserMarker(e, t) {
          if (!this.m_bInitialized)
            return (0, o.ZI)("timeline loader not initialized, unexpected"), !1;
          const r = this.m_mapTimelineData.get(e);
          if (!r) return (0, o.ZI)(`failed to find timeline ${e}`), !1;
          const i = r.m_rgEntries.findIndex((e) => e.id === t);
          return i < 0
            ? ((0, o.ZI)(`failed to find entry by id: ${t}`), !1)
            : (r.m_rgEntries.splice(i, 1),
              this.FireEvent("OnInvalidate", e),
              !0);
        }
        AddRunningTimeline(e, t, r) {
          if (
            this.m_rgTimelineMetadata.find((t) => t.metadata.timeline_id == e)
          )
            return;
          const i = {
              timeline_id: e,
              game_id: t,
              date_recorded: r,
              recordings: [],
            },
            n = this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1],
            a = n
              ? n.nGlobalOffsetMS.valMS + parseInt(n.metadata.duration_ms)
              : 0;
          l.Xr(
            this.m_rgTimelineMetadata,
            { nGlobalOffsetMS: (0, p.Sb)(a), metadata: i },
            (e, t) => e.metadata.date_recorded - t.metadata.date_recorded,
          ),
            this.m_mapTimelineData.set(e, {
              m_strState: "loaded",
              m_rgGameModeChanges: [],
              m_rgStateDescriptions: [],
              m_rgEntries: [],
              m_rgPhases: [],
            });
          let s = {
            m_metadata: i,
            m_globalStartMS: a,
            m_perfCounterStart: performance.now(),
            m_nPerfCounterOffsetMS: 1e3 * Math.max(0, (0, d._2)() - r),
            m_runningRecording: null,
          };
          this.m_mapRunningTimelines.set(e, s),
            this.m_schUpdateRunning.IsScheduled() ||
              this.m_schUpdateRunning.Schedule(M, this.UpdateRunningTimelines),
            this.FireEvent("OnInvalidate", e);
        }
        UpdateRunningTimelines() {
          let e;
          this.m_mapRunningTimelines.forEach((t) => {
            e = t.m_metadata.timeline_id;
            let r =
              performance.now() -
              t.m_perfCounterStart +
              t.m_nPerfCounterOffsetMS;
            r > (parseInt(t.m_metadata.duration_ms) || 0) &&
              (t.m_metadata.duration_ms = r.toString());
          }),
            this.m_mapRunningTimelines.size > 0 &&
              this.m_schUpdateRunning.Schedule(M, this.UpdateRunningTimelines),
            this.FireEvent("OnInvalidate", e);
        }
        RunningTimelineStopped(e, t) {
          let r = this.m_mapRunningTimelines.get(e);
          r &&
            ((r.m_metadata.duration_ms = t),
            this.m_mapRunningTimelines.delete(e),
            this.FireEvent("OnInvalidate", e));
        }
        AddRunningTimelineEntry(e) {
          let t = this.m_mapRunningTimelines.get(e.timeline_id),
            r = this.m_mapTimelineData.get(e.timeline_id);
          if (!t || !r) return;
          let i = (0, m.rU)(e);
          if (!i) return;
          (0, m.hT)(i)
            ? l.Xr(
                r.m_rgGameModeChanges,
                i,
                (e, t) => parseInt(e.time) - parseInt(t.time),
              )
            : (0, m.Te)(i)
              ? l.Xr(
                  r.m_rgStateDescriptions,
                  i,
                  (e, t) => parseInt(e.time) - parseInt(t.time),
                )
              : l.Xr(
                  r.m_rgEntries,
                  i,
                  (e, t) => parseInt(e.time) - parseInt(t.time),
                );
          let n = parseInt(t.m_metadata.duration_ms) || 0,
            a = parseInt(e.time);
          n < a && (t.m_metadata.duration_ms = a.toString()),
            this.FireEvent("OnInvalidate", e.timeline_id);
        }
        TimelineDeleted(e) {
          const t = this.m_rgTimelineMetadata
            .filter((t) => t.metadata.timeline_id !== e)
            .map((e) => e.metadata);
          this.UpdateTimelineMetadata(t),
            this.m_mapTimelineData.delete(e),
            this.FireEvent("OnInvalidate", e);
        }
        RecordingSessionChanged(e) {
          let t = e.session_id,
            r = e.notification_type;
          if (r == s.E6.k_ERecordingSessionChangeNotificationType_Started) {
            const r = this.m_mapRunningTimelines.get(e.timeline_id);
            if (!r)
              return (
                this.FireEvent("OnInvalidateRecording", e.timeline_id, t),
                void (0, S.wT)(
                  !1,
                  "Received recording started message before timeline info",
                )
              );
            const i = {
              recording_id: t,
              start_offset_ms: e.start_offset,
              recording_zero_timeline_offset_ms: e.start_offset,
              duration_ms: e.duration_ms,
              recording_type: e.recording_type,
            };
            r.m_metadata.recordings.push(i), (r.m_runningRecording = i);
          } else if (
            r == s.E6.k_ERecordingSessionChangeNotificationType_Stopped
          ) {
            const r = this.GetRunningTimelineForRecording(e.timeline_id, t);
            if (!r) return;
            (r.m_runningRecording.duration_ms = e.duration_ms),
              (r.m_runningRecording = null),
              this.FireEvent("OnInvalidateRecording", e.timeline_id, t);
          } else if (
            r == s.E6.k_ERecordingSessionChangeNotificationType_Updated
          ) {
            const r = this.GetTimelineMetadata(e.timeline_id);
            if (r) {
              const i = r.metadata.recordings.find((e) => e.recording_id === t);
              if (i) {
                (i.start_offset_ms = e.start_offset),
                  (i.duration_ms = e.duration_ms);
                const t = parseInt(e.start_offset) + parseInt(e.duration_ms);
                t > (parseInt(r.metadata.duration_ms) || 0) &&
                  (r.metadata.duration_ms = t.toString());
              }
            }
            this.GetRunningTimelineForRecording(e.timeline_id, t) ||
              this.FireEvent("OnInvalidateRecording", e.timeline_id, t);
          } else if (
            r == s.E6.k_ERecordingSessionChangeNotificationType_Deleted
          ) {
            const r = this.GetTimelineMetadata(e.timeline_id);
            if (r) {
              const e = r.metadata.recordings.filter(
                (e) => e.recording_id !== t,
              );
              r.metadata.recordings = e;
            }
          }
          this.FireEvent("OnInvalidate", e.timeline_id);
        }
        GetGlobalTimelineEndMS() {
          const e =
            this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1];
          if (e) {
            const t = isNaN(parseInt(e.metadata.duration_ms))
              ? 0
              : parseInt(e.metadata.duration_ms);
            return (0, p.Sb)(e.nGlobalOffsetMS.valMS + t);
          }
          return (0, p.Sb)(0);
        }
        GetEndOfRecordingsMS() {
          const e =
            this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1];
          if (e) {
            const t = e.metadata.recordings[e.metadata.recordings.length - 1];
            if (t) {
              const r = this.m_mapRunningTimelines.has(e.metadata.timeline_id),
                i = isNaN(parseInt(t.start_offset_ms))
                  ? 0
                  : parseInt(t.start_offset_ms),
                n = isNaN(parseInt(e.metadata.duration_ms))
                  ? 0
                  : parseInt(e.metadata.duration_ms);
              let a = 0;
              return (
                r
                  ? (a = Math.max(0, n - i))
                  : isNaN(parseInt(t.duration_ms)) ||
                    (a = parseInt(t.duration_ms)),
                (0, p.Sb)(e.nGlobalOffsetMS.valMS + i + a)
              );
            }
          }
          return null;
        }
        GetTotalRecordingDuration() {
          let e = 0;
          return (
            this.m_rgTimelineMetadata.forEach((t) => {
              t.metadata.recordings.forEach((t) => {
                isNaN(parseInt(t.duration_ms)) ||
                  (e += parseInt(t.duration_ms));
              });
            }),
            e
          );
        }
        GetTimelineStartBeforeGlobalZeroMS(e) {
          return e == this.m_rgTimelineMetadata[0].metadata.timeline_id
            ? this.m_ulFirstTimelineOffsetMS
            : 0;
        }
        async GenerateNamePartsFromTimeline(e, t, r, i) {
          let n,
            a,
            s,
            l,
            o,
            c = !1;
          for (let d of this.m_rgTimelineMetadata) {
            let u = !1;
            if (!c) {
              if (d.metadata.timeline_id != e) continue;
              (u = !0), (c = !0);
            }
            const g = d.metadata.timeline_id == r;
            await this.LoadTimelineData(d.metadata.timeline_id);
            const p = this.m_mapTimelineData.get(d.metadata.timeline_id);
            u && (l = d.metadata.date_recorded + Math.floor(t / 1e3)),
              g && (o = d.metadata.date_recorded + Math.floor(i / 1e3));
            for (let e of p.m_rgEntries) {
              const r = parseInt(e.time);
              if (u && r < t) continue;
              if (g && r > i) continue;
              if (!(0, m.eJ)(e) && !(0, m.N$)(e)) continue;
              const a = T(e);
              (!n || (a && a.rank > n.rank)) && (n = a);
            }
            for (let e of p.m_rgStateDescriptions) {
              const t = parseInt(e.time);
              (g && t > i) || ((!a || s < t) && ((a = e), (s = t)));
            }
            if (g) break;
          }
          const d = n?.strTitle ?? a?.title,
            u = new f.VS(this.GetGameID()),
            g = h.Vw.GetAppInfo(u.GetInternalAppID()),
            p = g?.name;
          return {
            strTimelinePart: d,
            strAppNamePart: p,
            rtStart: l,
            rtEnd: o,
          };
        }
        async GenerateClipNameFromTimeline(e, t, r, i) {
          const { strTimelinePart: n, strAppNamePart: a } =
              await this.GenerateNamePartsFromTimeline(e, t, r, i),
            s = new Date(),
            l = [
              a,
              `${s.getFullYear()}-${(s.getMonth() + 1).toString().padStart(2, "0")}-${s.getDate().toString().padStart(2, "0")} ${s.toLocaleTimeString()}`,
              n,
            ]
              .filter((e) => !!e)
              .join(" - ");
          return (0, o.q_)(`Generated clip name "${l}"`), l;
        }
      }
      function T(e) {
        switch (e.type) {
          case "event":
            const t = e;
            return { rank: 5e4 + e.priority, strTitle: t.title };
          case "usermarker":
            const r = e;
            return r.title || r.description
              ? { rank: 1e5 + e.priority, strTitle: e.title || e.description }
              : null;
          case "state_description":
            return { rank: 4e4, strTitle: e.title };
          case "achievement":
            return { rank: 9e4, strTitle: e.title };
        }
        return null;
      }
      (0, i.Cg)([_.sH], y.prototype, "m_bInitialized", void 0),
        (0, i.Cg)([g.o], y.prototype, "UpdateRunningTimelines", null);
    },
    53184: (e, t, r) => {
      "use strict";
      r.d(t, {
        Hv: () => l,
        E6: () => s,
        $C: () => o,
        QX: () => a,
        Bw: () => i,
        xM: () => c,
      });
      var i,
        n,
        a,
        s,
        l,
        o,
        m,
        c,
        d = r(80613),
        u = r.n(d),
        g = r(89068),
        p = r(56545),
        _ = r(21920);
      d.Message;
      d.Message;
      class f extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            f.prototype.timeline_id || g.Sg(f.M()),
            d.Message.initialize(this, e, 0, -1, [5, 6, 7], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            f.sm_m ||
              (f.sm_m = {
                proto: f,
                fields: {
                  timeline_id: {
                    n: 1,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  game_id: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  date_recorded: {
                    n: 3,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  duration_ms: {
                    n: 4,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  recordings: { n: 5, c: h, r: !0, q: !0 },
                  phases: { n: 6, c: b, r: !0, q: !0 },
                  significant_events: { n: 7, c: S, r: !0, q: !0 },
                },
              }),
            f.sm_m
          );
        }
        static MBF() {
          return f.sm_mbf || (f.sm_mbf = g.w0(f.M())), f.sm_mbf;
        }
        toObject(e = !1) {
          return f.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(f.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(f.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new f();
          return f.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(f.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return f.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(f.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return f.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingTimelineMetadata";
        }
      }
      class h extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            h.prototype.recording_id || g.Sg(h.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            h.sm_m ||
              (h.sm_m = {
                proto: h,
                fields: {
                  recording_id: {
                    n: 1,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  start_offset_ms: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  duration_ms: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  recording_type: {
                    n: 4,
                    br: g.qM.readEnum,
                    bw: g.gp.writeEnum,
                  },
                  delete_on_cleanup: {
                    n: 5,
                    br: g.qM.readBool,
                    bw: g.gp.writeBool,
                  },
                  video_manager_clip_id: {
                    n: 6,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  video_manager_video_id: {
                    n: 7,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  cdn_manifest_url: {
                    n: 8,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  file_size: {
                    n: 9,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  recording_zero_timeline_offset_ms: {
                    n: 10,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            h.sm_m
          );
        }
        static MBF() {
          return h.sm_mbf || (h.sm_mbf = g.w0(h.M())), h.sm_mbf;
        }
        toObject(e = !1) {
          return h.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(h.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(h.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new h();
          return h.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(h.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return h.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(h.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return h.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingTimelineMetadata_Recording";
        }
      }
      d.Message;
      class S extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            S.prototype.game_id || g.Sg(S.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            S.sm_m ||
              (S.sm_m = {
                proto: S,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  rt_created: {
                    n: 2,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  possible_clip: {
                    n: 3,
                    br: g.qM.readInt32,
                    bw: g.gp.writeInt32,
                  },
                  timeline_id: {
                    n: 4,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  entry_id: {
                    n: 5,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  timeline_offset_ms: {
                    n: 6,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  duration_ms: {
                    n: 7,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  marker_icon: {
                    n: 8,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  marker_title: {
                    n: 9,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  user_marker: { n: 10, br: g.qM.readBool, bw: g.gp.writeBool },
                },
              }),
            S.sm_m
          );
        }
        static MBF() {
          return S.sm_mbf || (S.sm_mbf = g.w0(S.M())), S.sm_mbf;
        }
        toObject(e = !1) {
          return S.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(S.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(S.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new S();
          return S.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(S.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return S.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(S.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return S.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingTimelineEvent";
        }
      }
      d.Message;
      d.Message;
      d.Message;
      class b extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            b.prototype.phase_id || g.Sg(b.M()),
            d.Message.initialize(this, e, 0, -1, [6, 7, 9], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            b.sm_m ||
              (b.sm_m = {
                proto: b,
                fields: {
                  phase_id: { n: 4, br: g.qM.readString, bw: g.gp.writeString },
                  duration_ms: {
                    n: 5,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  tags: { n: 6, c: M, r: !0, q: !0 },
                  contained_tags: { n: 7, c: M, r: !0, q: !0 },
                  background_timeline_offset: {
                    n: 8,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  attributes: { n: 9, c: T, r: !0, q: !0 },
                },
              }),
            b.sm_m
          );
        }
        static MBF() {
          return b.sm_mbf || (b.sm_mbf = g.w0(b.M())), b.sm_mbf;
        }
        toObject(e = !1) {
          return b.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(b.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(b.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new b();
          return b.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(b.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return b.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(b.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return b.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingPhase";
        }
      }
      class M extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            M.prototype.name || g.Sg(M.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            M.sm_m ||
              (M.sm_m = {
                proto: M,
                fields: {
                  name: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  group: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            M.sm_m
          );
        }
        static MBF() {
          return M.sm_mbf || (M.sm_mbf = g.w0(M.M())), M.sm_mbf;
        }
        toObject(e = !1) {
          return M.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(M.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(M.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new M();
          return M.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(M.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return M.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(M.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return M.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingPhase_Tag";
        }
      }
      class y extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            y.prototype.name || g.Sg(y.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            y.sm_m ||
              (y.sm_m = {
                proto: y,
                fields: {
                  name: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  group: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                  icon: { n: 3, br: g.qM.readString, bw: g.gp.writeString },
                  priority: { n: 4, br: g.qM.readUint32, bw: g.gp.writeUint32 },
                },
              }),
            y.sm_m
          );
        }
        static MBF() {
          return y.sm_mbf || (y.sm_mbf = g.w0(y.M())), y.sm_mbf;
        }
        toObject(e = !1) {
          return y.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(y.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(y.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new y();
          return y.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(y.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return y.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(y.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return y.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CTimelineTag";
        }
      }
      class T extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            T.prototype.group || g.Sg(T.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            T.sm_m ||
              (T.sm_m = {
                proto: T,
                fields: {
                  group: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  value: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                  priority: { n: 3, br: g.qM.readUint32, bw: g.gp.writeUint32 },
                },
              }),
            T.sm_m
          );
        }
        static MBF() {
          return T.sm_mbf || (T.sm_mbf = g.w0(T.M())), T.sm_mbf;
        }
        toObject(e = !1) {
          return T.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(T.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(T.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new T();
          return T.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(T.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return T.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(T.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return T.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CPhaseAttribute";
        }
      }
      !(function (e) {
        (e[(e.k_ETimelineEntryType_Invalid = 0)] =
          "k_ETimelineEntryType_Invalid"),
          (e[(e.k_ETimelineEntryType_GameMode = 1)] =
            "k_ETimelineEntryType_GameMode"),
          (e[(e.k_ETimelineEntryType_Event = 2)] =
            "k_ETimelineEntryType_Event"),
          (e[(e.k_ETimelineEntryType_StateDescription = 3)] =
            "k_ETimelineEntryType_StateDescription"),
          (e[(e.k_ETimelineEntryType_Achievement = 4)] =
            "k_ETimelineEntryType_Achievement"),
          (e[(e.k_ETimelineEntryType_UserMarker = 5)] =
            "k_ETimelineEntryType_UserMarker"),
          (e[(e.k_ETimelineEntryType_Screenshot = 6)] =
            "k_ETimelineEntryType_Screenshot"),
          (e[(e.k_ETimelineEntryType_Error = 7)] =
            "k_ETimelineEntryType_Error"),
          (e[(e.k_ETimelineEntryType_Tag = 8)] = "k_ETimelineEntryType_Tag"),
          (e[(e.k_ETimelineEntryType_GamePhase = 9)] =
            "k_ETimelineEntryType_GamePhase");
      })(i || (i = {})),
        (function (e) {
          (e[(e.k_EPhaseResultType_Automatic = 1)] =
            "k_EPhaseResultType_Automatic"),
            (e[(e.k_EPhaseResultType_Blank = 2)] = "k_EPhaseResultType_Blank"),
            (e[(e.k_EPhaseResultType_API = 3)] = "k_EPhaseResultType_API");
        })(n || (n = {})),
        (function (e) {
          (e[(e.k_ETimelineChangeNotificationType_Started = 1)] =
            "k_ETimelineChangeNotificationType_Started"),
            (e[(e.k_ETimelineChangeNotificationType_Stopped = 2)] =
              "k_ETimelineChangeNotificationType_Stopped"),
            (e[(e.k_ETimelineChangeNotificationType_Deleted = 3)] =
              "k_ETimelineChangeNotificationType_Deleted"),
            (e[(e.k_ETimelineChangeNotificationType_RecordingStarted = 4)] =
              "k_ETimelineChangeNotificationType_RecordingStarted"),
            (e[(e.k_ETimelineChangeNotificationType_RecordingStopped = 5)] =
              "k_ETimelineChangeNotificationType_RecordingStopped"),
            (e[(e.k_ETimelineChangeNotificationType_RecordingUpdated = 6)] =
              "k_ETimelineChangeNotificationType_RecordingUpdated");
        })(a || (a = {})),
        (function (e) {
          (e[(e.k_ERecordingSessionChangeNotificationType_Started = 1)] =
            "k_ERecordingSessionChangeNotificationType_Started"),
            (e[(e.k_ERecordingSessionChangeNotificationType_Stopped = 2)] =
              "k_ERecordingSessionChangeNotificationType_Stopped"),
            (e[(e.k_ERecordingSessionChangeNotificationType_Deleted = 3)] =
              "k_ERecordingSessionChangeNotificationType_Deleted"),
            (e[(e.k_ERecordingSessionChangeNotificationType_Updated = 4)] =
              "k_ERecordingSessionChangeNotificationType_Updated");
        })(s || (s = {})),
        (function (e) {
          (e[(e.k_eDiskSpaceType_Recording = 0)] =
            "k_eDiskSpaceType_Recording"),
            (e[(e.k_eDiskSpaceType_Clip = 1)] = "k_eDiskSpaceType_Clip");
        })(l || (l = {})),
        (function (e) {
          (e[(e.k_ePrecise = 0)] = "k_ePrecise"),
            (e[(e.k_eLoose = 1)] = "k_eLoose");
        })(o || (o = {})),
        (function (e) {
          (e[(e.k_eJPEG = 1)] = "k_eJPEG"), (e[(e.k_eRGB = 2)] = "k_eRGB");
        })(m || (m = {}));
      class B extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return B.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new B();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new B();
          return B.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return B.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return B.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAppsWithBackgroundVideo_Request";
        }
      }
      class v extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            v.prototype.apps || g.Sg(v.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            v.sm_m ||
              (v.sm_m = {
                proto: v,
                fields: { apps: { n: 1, c: R, r: !0, q: !0 } },
              }),
            v.sm_m
          );
        }
        static MBF() {
          return v.sm_mbf || (v.sm_mbf = g.w0(v.M())), v.sm_mbf;
        }
        toObject(e = !1) {
          return v.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(v.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(v.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new v();
          return v.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(v.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return v.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(v.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return v.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAppsWithBackgroundVideo_Response";
        }
      }
      class R extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            R.prototype.game_id || g.Sg(R.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            R.sm_m ||
              (R.sm_m = {
                proto: R,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  most_recent_start_time: {
                    n: 2,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  recording_type: {
                    n: 3,
                    br: g.qM.readEnum,
                    bw: g.gp.writeEnum,
                  },
                  video_duration_seconds: {
                    n: 4,
                    br: g.qM.readDouble,
                    bw: g.gp.writeDouble,
                  },
                  timeline_duration_seconds: {
                    n: 5,
                    br: g.qM.readDouble,
                    bw: g.gp.writeDouble,
                  },
                  is_active: { n: 6, br: g.qM.readBool, bw: g.gp.writeBool },
                  file_size: {
                    n: 7,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            R.sm_m
          );
        }
        static MBF() {
          return R.sm_mbf || (R.sm_mbf = g.w0(R.M())), R.sm_mbf;
        }
        toObject(e = !1) {
          return R.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(R.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(R.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new R();
          return R.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(R.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return R.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(R.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return R.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAppsWithBackgroundVideo_Response_App";
        }
      }
      class G extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            G.prototype.game_id || g.Sg(G.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            G.sm_m ||
              (G.sm_m = {
                proto: G,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            G.sm_m
          );
        }
        static MBF() {
          return G.sm_mbf || (G.sm_mbf = g.w0(G.M())), G.sm_mbf;
        }
        toObject(e = !1) {
          return G.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(G.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(G.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new G();
          return G.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(G.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return G.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(G.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return G.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForApp_Request";
        }
      }
      class w extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            w.prototype.timelines || g.Sg(w.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            w.sm_m ||
              (w.sm_m = {
                proto: w,
                fields: { timelines: { n: 1, c: f, r: !0, q: !0 } },
              }),
            w.sm_m
          );
        }
        static MBF() {
          return w.sm_mbf || (w.sm_mbf = g.w0(w.M())), w.sm_mbf;
        }
        toObject(e = !1) {
          return w.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(w.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(w.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new w();
          return w.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(w.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return w.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(w.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return w.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForApp_Response";
        }
      }
      class C extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            C.prototype.clip_id || g.Sg(C.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            C.sm_m ||
              (C.sm_m = {
                proto: C,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            C.sm_m
          );
        }
        static MBF() {
          return C.sm_mbf || (C.sm_mbf = g.w0(C.M())), C.sm_mbf;
        }
        toObject(e = !1) {
          return C.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(C.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(C.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new C();
          return C.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(C.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return C.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(C.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return C.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForClip_Request";
        }
      }
      class E extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            E.prototype.game_id || g.Sg(E.M()),
            d.Message.initialize(this, e, 0, -1, [2], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            E.sm_m ||
              (E.sm_m = {
                proto: E,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  timelines: { n: 2, c: f, r: !0, q: !0 },
                  first_timeline_start_offset_ms: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            E.sm_m
          );
        }
        static MBF() {
          return E.sm_mbf || (E.sm_mbf = g.w0(E.M())), E.sm_mbf;
        }
        toObject(e = !1) {
          return E.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(E.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(E.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new E();
          return E.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(E.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return E.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(E.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return E.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForClip_Response";
        }
      }
      class I extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            I.prototype.page || g.Sg(I.M()),
            d.Message.initialize(this, e, 0, -1, [12], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            I.sm_m ||
              (I.sm_m = {
                proto: I,
                fields: {
                  page: { n: 1, br: g.qM.readUint32, bw: g.gp.writeUint32 },
                  count: { n: 2, br: g.qM.readUint32, bw: g.gp.writeUint32 },
                  filter_gameid: {
                    n: 10,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  filter_search_string: {
                    n: 11,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  filter_tags: { n: 12, c: k, r: !0, q: !0 },
                  filter_phase_id: {
                    n: 13,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                },
              }),
            I.sm_m
          );
        }
        static MBF() {
          return I.sm_mbf || (I.sm_mbf = g.w0(I.M())), I.sm_mbf;
        }
        toObject(e = !1) {
          return I.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(I.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(I.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new I();
          return I.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(I.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return I.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(I.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return I.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_QueryPhases_Request";
        }
      }
      class k extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            k.prototype.group || g.Sg(k.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            k.sm_m ||
              (k.sm_m = {
                proto: k,
                fields: {
                  group: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  name: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            k.sm_m
          );
        }
        static MBF() {
          return k.sm_mbf || (k.sm_mbf = g.w0(k.M())), k.sm_mbf;
        }
        toObject(e = !1) {
          return k.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(k.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(k.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new k();
          return k.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(k.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return k.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(k.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return k.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_QueryPhases_Request_Tag";
        }
      }
      class P extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            P.prototype.phases || g.Sg(P.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            P.sm_m ||
              (P.sm_m = {
                proto: P,
                fields: {
                  phases: { n: 1, c: O, r: !0, q: !0 },
                  total_count: {
                    n: 2,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                },
              }),
            P.sm_m
          );
        }
        static MBF() {
          return P.sm_mbf || (P.sm_mbf = g.w0(P.M())), P.sm_mbf;
        }
        toObject(e = !1) {
          return P.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(P.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(P.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new P();
          return P.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(P.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return P.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(P.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return P.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_QueryPhases_Response";
        }
      }
      class O extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            O.prototype.game_id || g.Sg(O.M()),
            d.Message.initialize(this, e, 0, -1, [7, 8, 10, 13, 16, 17], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            O.sm_m ||
              (O.sm_m = {
                proto: O,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  date_recorded: {
                    n: 5,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  duration_ms: {
                    n: 6,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  tags: { n: 7, c: y, r: !0, q: !0 },
                  contained_tags: { n: 8, c: y, r: !0, q: !0 },
                  background_recording: { n: 9, c: z },
                  clip_ids: {
                    n: 10,
                    r: !0,
                    q: !0,
                    br: g.qM.readString,
                    bw: g.gp.writeRepeatedString,
                  },
                  type: { n: 11, br: g.qM.readEnum, bw: g.gp.writeEnum },
                  start_ms: {
                    n: 12,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  screenshots: {
                    n: 13,
                    r: !0,
                    q: !0,
                    br: g.qM.readUint32,
                    pbr: g.qM.readPackedUint32,
                    bw: g.gp.writeRepeatedUint32,
                  },
                  active: { n: 14, br: g.qM.readBool, bw: g.gp.writeBool },
                  phase_id: {
                    n: 15,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  significant_events: { n: 16, c: j, r: !0, q: !0 },
                  attributes: { n: 17, c: T, r: !0, q: !0 },
                },
              }),
            O.sm_m
          );
        }
        static MBF() {
          return O.sm_mbf || (O.sm_mbf = g.w0(O.M())), O.sm_mbf;
        }
        toObject(e = !1) {
          return O.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(O.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(O.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new O();
          return O.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(O.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return O.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(O.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return O.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_QueryPhases_Response_Phase";
        }
      }
      class z extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            z.prototype.timeline_id || g.Sg(z.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            z.sm_m ||
              (z.sm_m = {
                proto: z,
                fields: {
                  timeline_id: {
                    n: 1,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  offset: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  duration_ms: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            z.sm_m
          );
        }
        static MBF() {
          return z.sm_mbf || (z.sm_mbf = g.w0(z.M())), z.sm_mbf;
        }
        toObject(e = !1) {
          return z.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(z.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(z.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new z();
          return z.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(z.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return z.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(z.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return z.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_QueryPhases_Response_Phase_BackgroundRecording";
        }
      }
      class D extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            D.prototype.game_id || g.Sg(D.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            D.sm_m ||
              (D.sm_m = {
                proto: D,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            D.sm_m
          );
        }
        static MBF() {
          return D.sm_mbf || (D.sm_mbf = g.w0(D.M())), D.sm_mbf;
        }
        toObject(e = !1) {
          return D.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(D.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(D.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new D();
          return D.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(D.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return D.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(D.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return D.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTags_Request";
        }
      }
      class A extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            A.prototype.tags || g.Sg(A.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            A.sm_m ||
              (A.sm_m = {
                proto: A,
                fields: { tags: { n: 1, c: y, r: !0, q: !0 } },
              }),
            A.sm_m
          );
        }
        static MBF() {
          return A.sm_mbf || (A.sm_mbf = g.w0(A.M())), A.sm_mbf;
        }
        toObject(e = !1) {
          return A.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(A.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(A.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new A();
          return A.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(A.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return A.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(A.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return A.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTags_Response";
        }
      }
      class W extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return W.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new W();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new W();
          return W.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return W.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return W.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetEnoughDiskSpace_Request";
        }
      }
      class F extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            F.prototype.enough_space || g.Sg(F.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            F.sm_m ||
              (F.sm_m = {
                proto: F,
                fields: {
                  enough_space: { n: 1, br: g.qM.readBool, bw: g.gp.writeBool },
                },
              }),
            F.sm_m
          );
        }
        static MBF() {
          return F.sm_mbf || (F.sm_mbf = g.w0(F.M())), F.sm_mbf;
        }
        toObject(e = !1) {
          return F.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(F.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(F.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new F();
          return F.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(F.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return F.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(F.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return F.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetEnoughDiskSpace_Response";
        }
      }
      class q extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return q.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new q();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new q();
          return q.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return q.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return q.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAvailableDiskSpace_Request";
        }
      }
      class N extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            N.prototype.size || g.Sg(N.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            N.sm_m ||
              (N.sm_m = {
                proto: N,
                fields: {
                  size: { n: 1, br: g.qM.readDouble, bw: g.gp.writeDouble },
                },
              }),
            N.sm_m
          );
        }
        static MBF() {
          return N.sm_mbf || (N.sm_mbf = g.w0(N.M())), N.sm_mbf;
        }
        toObject(e = !1) {
          return N.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(N.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(N.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new N();
          return N.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(N.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return N.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(N.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return N.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAvailableDiskSpace_Response";
        }
      }
      class x extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            x.prototype.notification_type || g.Sg(x.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            x.sm_m ||
              (x.sm_m = {
                proto: x,
                fields: {
                  notification_type: {
                    n: 1,
                    br: g.qM.readEnum,
                    bw: g.gp.writeEnum,
                  },
                  timeline_id: {
                    n: 2,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  game_id: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  start_time: {
                    n: 4,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  duration_ms: {
                    n: 5,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            x.sm_m
          );
        }
        static MBF() {
          return x.sm_mbf || (x.sm_mbf = g.w0(x.M())), x.sm_mbf;
        }
        toObject(e = !1) {
          return x.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(x.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(x.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new x();
          return x.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(x.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return x.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(x.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return x.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_TimelineChanged_Notification";
        }
      }
      class U extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            U.prototype.notification_type || g.Sg(U.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            U.sm_m ||
              (U.sm_m = {
                proto: U,
                fields: {
                  notification_type: {
                    n: 1,
                    br: g.qM.readEnum,
                    bw: g.gp.writeEnum,
                  },
                  timeline_id: {
                    n: 2,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  game_id: {
                    n: 4,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  session_id: {
                    n: 5,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  start_offset: {
                    n: 6,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  duration_ms: {
                    n: 7,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  recording_type: {
                    n: 8,
                    br: g.qM.readEnum,
                    bw: g.gp.writeEnum,
                  },
                },
              }),
            U.sm_m
          );
        }
        static MBF() {
          return U.sm_mbf || (U.sm_mbf = g.w0(U.M())), U.sm_mbf;
        }
        toObject(e = !1) {
          return U.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(U.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(U.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new U();
          return U.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(U.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return U.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(U.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return U.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_RecordingSessionChanged_Notification";
        }
      }
      class j extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            j.prototype.timeline_id || g.Sg(j.M()),
            d.Message.initialize(this, e, 0, -1, [17, 19], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            j.sm_m ||
              (j.sm_m = {
                proto: j,
                fields: {
                  timeline_id: {
                    n: 1,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  entry_id: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  time: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  type: { n: 4, br: g.qM.readEnum, bw: g.gp.writeEnum },
                  game_mode: { n: 5, br: g.qM.readInt32, bw: g.gp.writeInt32 },
                  range_title: {
                    n: 7,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  range_duration: {
                    n: 8,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  range_possible_clip: {
                    n: 9,
                    br: g.qM.readInt32,
                    bw: g.gp.writeInt32,
                  },
                  timestamp_title: {
                    n: 10,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  marker_icon: {
                    n: 11,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  marker_description: {
                    n: 13,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  marker_priority: {
                    n: 14,
                    br: g.qM.readInt32,
                    bw: g.gp.writeInt32,
                  },
                  screenshot_handle: {
                    n: 15,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  achievement_name: {
                    n: 16,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  tag: { n: 17, c: y, r: !0, q: !0 },
                  phase_id: {
                    n: 18,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  attributes: { n: 19, c: T, r: !0, q: !0 },
                },
              }),
            j.sm_m
          );
        }
        static MBF() {
          return j.sm_mbf || (j.sm_mbf = g.w0(j.M())), j.sm_mbf;
        }
        toObject(e = !1) {
          return j.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(j.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(j.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new j();
          return j.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(j.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return j.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(j.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return j.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CTimelineEntry";
        }
      }
      class L extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            L.prototype.entry || g.Sg(L.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            L.sm_m ||
              (L.sm_m = {
                proto: L,
                fields: {
                  entry: { n: 1, c: j },
                  game_id: {
                    n: 2,
                    br: g.qM.readFixed64String,
                    bw: g.gp.writeFixed64String,
                  },
                },
              }),
            L.sm_m
          );
        }
        static MBF() {
          return L.sm_mbf || (L.sm_mbf = g.w0(L.M())), L.sm_mbf;
        }
        toObject(e = !1) {
          return L.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(L.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(L.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new L();
          return L.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(L.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return L.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(L.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return L.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_TimelineEntryChanged_Notification";
        }
      }
      class H extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            H.prototype.game_id || g.Sg(H.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            H.sm_m ||
              (H.sm_m = {
                proto: H,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  timeline_id: {
                    n: 2,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  entry_id: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            H.sm_m
          );
        }
        static MBF() {
          return H.sm_mbf || (H.sm_mbf = g.w0(H.M())), H.sm_mbf;
        }
        toObject(e = !1) {
          return H.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(H.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(H.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new H();
          return H.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(H.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return H.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(H.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return H.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_TimelineEntryRemoved_Notification";
        }
      }
      class X extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return X.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new X();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new X();
          return X.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return X.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return X.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_LowDiskSpace_Notification";
        }
      }
      class V extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            V.prototype.game_id || g.Sg(V.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            V.sm_m ||
              (V.sm_m = {
                proto: V,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            V.sm_m
          );
        }
        static MBF() {
          return V.sm_mbf || (V.sm_mbf = g.w0(V.M())), V.sm_mbf;
        }
        toObject(e = !1) {
          return V.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(V.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(V.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new V();
          return V.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(V.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return V.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(V.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return V.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_PostGameHighlightsChanged_Notification";
        }
      }
      class Z extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Z.prototype.game_id || g.Sg(Z.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Z.sm_m ||
              (Z.sm_m = {
                proto: Z,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  phase_id: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            Z.sm_m
          );
        }
        static MBF() {
          return Z.sm_mbf || (Z.sm_mbf = g.w0(Z.M())), Z.sm_mbf;
        }
        toObject(e = !1) {
          return Z.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Z.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Z.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Z();
          return Z.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Z.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Z.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Z.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Z.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_OpenOverlayToGamePhase_Notification";
        }
      }
      class K extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            K.prototype.game_id || g.Sg(K.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            K.sm_m ||
              (K.sm_m = {
                proto: K,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  entry_id: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            K.sm_m
          );
        }
        static MBF() {
          return K.sm_mbf || (K.sm_mbf = g.w0(K.M())), K.sm_mbf;
        }
        toObject(e = !1) {
          return K.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(K.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(K.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new K();
          return K.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(K.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return K.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(K.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return K.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_OpenOverlayToTimelineEvent_Notification";
        }
      }
      class Q extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Q.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Q();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Q();
          return Q.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Q.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Q.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_PhaseListChanged_Notification";
        }
      }
      class J extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            J.prototype.clip_id || g.Sg(J.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            J.sm_m ||
              (J.sm_m = {
                proto: J,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  game_id: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  duration_ms: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  date_recorded: {
                    n: 4,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  start_timeline_id: {
                    n: 5,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  start_offset_ms: {
                    n: 6,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  published_file_id: {
                    n: 7,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  file_size: {
                    n: 8,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  name: { n: 9, br: g.qM.readString, bw: g.gp.writeString },
                  date_clipped: {
                    n: 10,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  temporary: { n: 11, br: g.qM.readBool, bw: g.gp.writeBool },
                  original_device: {
                    n: 12,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  original_gaming_device_type: {
                    n: 13,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  date_downloaded: {
                    n: 14,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  thumbnail_url: {
                    n: 15,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  thumbnail_width: {
                    n: 16,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  thumbnail_height: {
                    n: 17,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                },
              }),
            J.sm_m
          );
        }
        static MBF() {
          return J.sm_mbf || (J.sm_mbf = g.w0(J.M())), J.sm_mbf;
        }
        toObject(e = !1) {
          return J.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(J.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(J.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new J();
          return J.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(J.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return J.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(J.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return J.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ClipSummary";
        }
      }
      class $ extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            $.prototype.game_id || g.Sg($.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            $.sm_m ||
              ($.sm_m = {
                proto: $,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  start: { n: 2, c: Y },
                  end: { n: 3, c: Y },
                  name: { n: 4, br: g.qM.readString, bw: g.gp.writeString },
                  src_clip_id: {
                    n: 5,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  temporary: { n: 6, br: g.qM.readBool, bw: g.gp.writeBool },
                  force_thumbnail: {
                    n: 7,
                    br: g.qM.readBool,
                    bw: g.gp.writeBool,
                  },
                },
              }),
            $.sm_m
          );
        }
        static MBF() {
          return $.sm_mbf || ($.sm_mbf = g.w0($.M())), $.sm_mbf;
        }
        toObject(e = !1) {
          return $.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT($.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq($.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new $();
          return $.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj($.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return $.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0($.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return $.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SaveClip_Request";
        }
      }
      class Y extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Y.prototype.timeline_id || g.Sg(Y.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Y.sm_m ||
              (Y.sm_m = {
                proto: Y,
                fields: {
                  timeline_id: {
                    n: 1,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  offset_ms: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            Y.sm_m
          );
        }
        static MBF() {
          return Y.sm_mbf || (Y.sm_mbf = g.w0(Y.M())), Y.sm_mbf;
        }
        toObject(e = !1) {
          return Y.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Y.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Y.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Y();
          return Y.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Y.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Y.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Y.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Y.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SaveClip_Request_Position";
        }
      }
      class ee extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ee.prototype.summary || g.Sg(ee.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ee.sm_m ||
              (ee.sm_m = { proto: ee, fields: { summary: { n: 1, c: J } } }),
            ee.sm_m
          );
        }
        static MBF() {
          return ee.sm_mbf || (ee.sm_mbf = g.w0(ee.M())), ee.sm_mbf;
        }
        toObject(e = !1) {
          return ee.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ee.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ee.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ee();
          return ee.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ee.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ee.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ee.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ee.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SaveClip_Response";
        }
      }
      class te extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            te.prototype.clip_id || g.Sg(te.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            te.sm_m ||
              (te.sm_m = {
                proto: te,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            te.sm_m
          );
        }
        static MBF() {
          return te.sm_mbf || (te.sm_mbf = g.w0(te.M())), te.sm_mbf;
        }
        toObject(e = !1) {
          return te.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(te.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(te.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new te();
          return te.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(te.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return te.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(te.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return te.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeleteClip_Request";
        }
      }
      class re extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return re.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new re();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new re();
          return re.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return re.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return re.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeleteClip_Response";
        }
      }
      class ie extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ie.prototype.bitrate_kbps || g.Sg(ie.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ie.sm_m ||
              (ie.sm_m = {
                proto: ie,
                fields: {
                  bitrate_kbps: {
                    n: 1,
                    br: g.qM.readInt32,
                    bw: g.gp.writeInt32,
                  },
                  width: { n: 2, br: g.qM.readInt32, bw: g.gp.writeInt32 },
                  height: { n: 3, br: g.qM.readInt32, bw: g.gp.writeInt32 },
                  frames_per_second: {
                    n: 4,
                    br: g.qM.readInt32,
                    bw: g.gp.writeInt32,
                  },
                  codec: { n: 5, br: g.qM.readEnum, bw: g.gp.writeEnum },
                },
              }),
            ie.sm_m
          );
        }
        static MBF() {
          return ie.sm_mbf || (ie.sm_mbf = g.w0(ie.M())), ie.sm_mbf;
        }
        toObject(e = !1) {
          return ie.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ie.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ie.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ie();
          return ie.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ie.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ie.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ie.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ie.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClip_Settings";
        }
      }
      class ne extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ne.prototype.clip_id || g.Sg(ne.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ne.sm_m ||
              (ne.sm_m = {
                proto: ne,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  export_mp4_path: {
                    n: 2,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  settings: { n: 3, c: ie },
                  use_unique_filename: {
                    n: 4,
                    br: g.qM.readBool,
                    bw: g.gp.writeBool,
                  },
                },
              }),
            ne.sm_m
          );
        }
        static MBF() {
          return ne.sm_mbf || (ne.sm_mbf = g.w0(ne.M())), ne.sm_mbf;
        }
        toObject(e = !1) {
          return ne.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ne.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ne.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ne();
          return ne.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ne.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ne.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ne.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ne.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClip_Request";
        }
      }
      class ae extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return ae.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new ae();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ae();
          return ae.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ae.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ae.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClip_Response";
        }
      }
      class se extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            se.prototype.clip_id || g.Sg(se.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            se.sm_m ||
              (se.sm_m = {
                proto: se,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  settings: { n: 2, c: ie },
                  run_policy_checks: {
                    n: 3,
                    br: g.qM.readBool,
                    bw: g.gp.writeBool,
                  },
                },
              }),
            se.sm_m
          );
        }
        static MBF() {
          return se.sm_mbf || (se.sm_mbf = g.w0(se.M())), se.sm_mbf;
        }
        toObject(e = !1) {
          return se.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(se.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(se.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new se();
          return se.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(se.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return se.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(se.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return se.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClipPreview_Request";
        }
      }
      class le extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            le.prototype.estimated_size || g.Sg(le.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            le.sm_m ||
              (le.sm_m = {
                proto: le,
                fields: {
                  estimated_size: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  settings: { n: 2, c: ie },
                },
              }),
            le.sm_m
          );
        }
        static MBF() {
          return le.sm_mbf || (le.sm_mbf = g.w0(le.M())), le.sm_mbf;
        }
        toObject(e = !1) {
          return le.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(le.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(le.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new le();
          return le.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(le.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return le.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(le.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return le.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClipPreview_Response";
        }
      }
      class oe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            oe.prototype.game_id || g.Sg(oe.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            oe.sm_m ||
              (oe.sm_m = {
                proto: oe,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readFixed64String,
                    bw: g.gp.writeFixed64String,
                  },
                  timeline_id: {
                    n: 2,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  timeline_offset_ms: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            oe.sm_m
          );
        }
        static MBF() {
          return oe.sm_mbf || (oe.sm_mbf = g.w0(oe.M())), oe.sm_mbf;
        }
        toObject(e = !1) {
          return oe.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(oe.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(oe.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new oe();
          return oe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(oe.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return oe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(oe.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return oe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_TakeScreenshot_Request";
        }
      }
      class me extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            me.prototype.screenshot_id || g.Sg(me.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            me.sm_m ||
              (me.sm_m = {
                proto: me,
                fields: {
                  screenshot_id: {
                    n: 1,
                    br: g.qM.readFixed64String,
                    bw: g.gp.writeFixed64String,
                  },
                },
              }),
            me.sm_m
          );
        }
        static MBF() {
          return me.sm_mbf || (me.sm_mbf = g.w0(me.M())), me.sm_mbf;
        }
        toObject(e = !1) {
          return me.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(me.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(me.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new me();
          return me.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(me.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return me.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(me.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return me.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_TakeScreenshot_Response";
        }
      }
      class ce extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ce.prototype.clip_id || g.Sg(ce.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ce.sm_m ||
              (ce.sm_m = {
                proto: ce,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  title: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                  desc: { n: 3, br: g.qM.readString, bw: g.gp.writeString },
                  visibility: { n: 4, br: g.qM.readInt32, bw: g.gp.writeInt32 },
                },
              }),
            ce.sm_m
          );
        }
        static MBF() {
          return ce.sm_mbf || (ce.sm_mbf = g.w0(ce.M())), ce.sm_mbf;
        }
        toObject(e = !1) {
          return ce.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ce.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ce.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ce();
          return ce.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ce.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ce.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ce.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ce.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UploadClipToSteam_Request";
        }
      }
      class de extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            de.prototype.summary || g.Sg(de.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            de.sm_m ||
              (de.sm_m = { proto: de, fields: { summary: { n: 1, c: J } } }),
            de.sm_m
          );
        }
        static MBF() {
          return de.sm_mbf || (de.sm_mbf = g.w0(de.M())), de.sm_mbf;
        }
        toObject(e = !1) {
          return de.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(de.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(de.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new de();
          return de.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(de.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return de.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(de.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return de.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UploadClipToSteam_Response";
        }
      }
      class ue extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ue.prototype.clip_id || g.Sg(ue.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ue.sm_m ||
              (ue.sm_m = {
                proto: ue,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            ue.sm_m
          );
        }
        static MBF() {
          return ue.sm_mbf || (ue.sm_mbf = g.w0(ue.M())), ue.sm_mbf;
        }
        toObject(e = !1) {
          return ue.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ue.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ue.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ue();
          return ue.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ue.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ue.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ue.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ue.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ZipClip_Request";
        }
      }
      class ge extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ge.prototype.zip_path || g.Sg(ge.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ge.sm_m ||
              (ge.sm_m = {
                proto: ge,
                fields: {
                  zip_path: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            ge.sm_m
          );
        }
        static MBF() {
          return ge.sm_mbf || (ge.sm_mbf = g.w0(ge.M())), ge.sm_mbf;
        }
        toObject(e = !1) {
          return ge.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ge.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ge.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ge();
          return ge.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ge.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ge.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ge.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ge.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ZipClip_Response";
        }
      }
      class pe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            pe.prototype.game_id || g.Sg(pe.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            pe.sm_m ||
              (pe.sm_m = {
                proto: pe,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  created_after: {
                    n: 2,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  include_temporary: {
                    n: 3,
                    br: g.qM.readBool,
                    bw: g.gp.writeBool,
                  },
                },
              }),
            pe.sm_m
          );
        }
        static MBF() {
          return pe.sm_mbf || (pe.sm_mbf = g.w0(pe.M())), pe.sm_mbf;
        }
        toObject(e = !1) {
          return pe.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(pe.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(pe.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new pe();
          return pe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(pe.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return pe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(pe.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return pe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetClips_Request";
        }
      }
      class _e extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            _e.prototype.clip || g.Sg(_e.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            _e.sm_m ||
              (_e.sm_m = {
                proto: _e,
                fields: { clip: { n: 1, c: J, r: !0, q: !0 } },
              }),
            _e.sm_m
          );
        }
        static MBF() {
          return _e.sm_mbf || (_e.sm_mbf = g.w0(_e.M())), _e.sm_mbf;
        }
        toObject(e = !1) {
          return _e.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(_e.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(_e.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new _e();
          return _e.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(_e.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return _e.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(_e.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return _e.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetClips_Response";
        }
      }
      class fe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            fe.prototype.game_id || g.Sg(fe.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            fe.sm_m ||
              (fe.sm_m = {
                proto: fe,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  created_after: {
                    n: 2,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                },
              }),
            fe.sm_m
          );
        }
        static MBF() {
          return fe.sm_mbf || (fe.sm_mbf = g.w0(fe.M())), fe.sm_mbf;
        }
        toObject(e = !1) {
          return fe.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(fe.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(fe.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new fe();
          return fe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(fe.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return fe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(fe.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return fe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAndTrimPostGameHighlights_Request";
        }
      }
      class he extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            he.prototype.events || g.Sg(he.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            he.sm_m ||
              (he.sm_m = {
                proto: he,
                fields: { events: { n: 1, c: S, r: !0, q: !0 } },
              }),
            he.sm_m
          );
        }
        static MBF() {
          return he.sm_mbf || (he.sm_mbf = g.w0(he.M())), he.sm_mbf;
        }
        toObject(e = !1) {
          return he.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(he.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(he.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new he();
          return he.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(he.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return he.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(he.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return he.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAndTrimPostGameHighlights_Response";
        }
      }
      class Se extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Se.prototype.game_id || g.Sg(Se.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Se.sm_m ||
              (Se.sm_m = {
                proto: Se,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  entry: { n: 2, c: j },
                  clip_id: { n: 3, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            Se.sm_m
          );
        }
        static MBF() {
          return Se.sm_mbf || (Se.sm_mbf = g.w0(Se.M())), Se.sm_mbf;
        }
        toObject(e = !1) {
          return Se.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Se.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Se.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Se();
          return Se.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Se.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Se.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Se.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Se.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserAddTimelineEntry_Request";
        }
      }
      class be extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            be.prototype.entry_id || g.Sg(be.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            be.sm_m ||
              (be.sm_m = {
                proto: be,
                fields: {
                  entry_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            be.sm_m
          );
        }
        static MBF() {
          return be.sm_mbf || (be.sm_mbf = g.w0(be.M())), be.sm_mbf;
        }
        toObject(e = !1) {
          return be.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(be.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(be.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new be();
          return be.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(be.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return be.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(be.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return be.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserAddTimelineEntry_Response";
        }
      }
      class Me extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Me.prototype.game_id || g.Sg(Me.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Me.sm_m ||
              (Me.sm_m = {
                proto: Me,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  entry: { n: 2, c: j },
                  clip_id: { n: 3, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            Me.sm_m
          );
        }
        static MBF() {
          return Me.sm_mbf || (Me.sm_mbf = g.w0(Me.M())), Me.sm_mbf;
        }
        toObject(e = !1) {
          return Me.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Me.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Me.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Me();
          return Me.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Me.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Me.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Me.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Me.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserUpdateTimelineEntry_Request";
        }
      }
      class ye extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return ye.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new ye();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ye();
          return ye.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ye.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ye.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserUpdateTimelineEntry_Response";
        }
      }
      class Te extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Te.prototype.game_id || g.Sg(Te.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Te.sm_m ||
              (Te.sm_m = {
                proto: Te,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  timeline_id: {
                    n: 2,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  entry_id: {
                    n: 3,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                  clip_id: { n: 4, br: g.qM.readString, bw: g.gp.writeString },
                },
              }),
            Te.sm_m
          );
        }
        static MBF() {
          return Te.sm_mbf || (Te.sm_mbf = g.w0(Te.M())), Te.sm_mbf;
        }
        toObject(e = !1) {
          return Te.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Te.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Te.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Te();
          return Te.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Te.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Te.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Te.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Te.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserRemoveTimelineEntry_Request";
        }
      }
      class Be extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Be.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Be();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Be();
          return Be.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Be.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Be.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserRemoveTimelineEntry_Response";
        }
      }
      class ve extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ve.prototype.game_ids || g.Sg(ve.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ve.sm_m ||
              (ve.sm_m = {
                proto: ve,
                fields: {
                  game_ids: {
                    n: 1,
                    r: !0,
                    q: !0,
                    br: g.qM.readUint64String,
                    pbr: g.qM.readPackedUint64String,
                    bw: g.gp.writeRepeatedUint64String,
                  },
                },
              }),
            ve.sm_m
          );
        }
        static MBF() {
          return ve.sm_mbf || (ve.sm_mbf = g.w0(ve.M())), ve.sm_mbf;
        }
        toObject(e = !1) {
          return ve.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ve.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ve.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ve();
          return ve.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ve.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ve.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ve.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ve.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ManuallyDeleteRecordingsForApps_Request";
        }
      }
      class Re extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Re.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Re();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Re();
          return Re.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Re.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Re.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ManuallyDeleteRecordingsForApps_Response";
        }
      }
      class Ge extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ge.prototype.folder_path || g.Sg(Ge.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ge.sm_m ||
              (Ge.sm_m = {
                proto: Ge,
                fields: {
                  folder_path: {
                    n: 1,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  type: { n: 2, br: g.qM.readEnum, bw: g.gp.writeEnum },
                },
              }),
            Ge.sm_m
          );
        }
        static MBF() {
          return Ge.sm_mbf || (Ge.sm_mbf = g.w0(Ge.M())), Ge.sm_mbf;
        }
        toObject(e = !1) {
          return Ge.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ge.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ge.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ge();
          return Ge.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ge.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ge.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ge.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ge.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTotalDiskSpaceUsage_Request";
        }
      }
      class we extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            we.prototype.size || g.Sg(we.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            we.sm_m ||
              (we.sm_m = {
                proto: we,
                fields: {
                  size: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            we.sm_m
          );
        }
        static MBF() {
          return we.sm_mbf || (we.sm_mbf = g.w0(we.M())), we.sm_mbf;
        }
        toObject(e = !1) {
          return we.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(we.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(we.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new we();
          return we.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(we.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return we.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(we.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return we.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTotalDiskSpaceUsage_Response";
        }
      }
      class Ce extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ce.prototype.recording_id || g.Sg(Ce.M()),
            d.Message.initialize(this, e, 0, -1, [4], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ce.sm_m ||
              (Ce.sm_m = {
                proto: Ce,
                fields: {
                  recording_id: {
                    n: 1,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  clip_id: { n: 3, br: g.qM.readString, bw: g.gp.writeString },
                  timeline_id: {
                    n: 7,
                    br: g.qM.readString,
                    bw: g.gp.writeString,
                  },
                  start_offset_us: {
                    n: 4,
                    r: !0,
                    q: !0,
                    br: g.qM.readInt64String,
                    pbr: g.qM.readPackedInt64String,
                    bw: g.gp.writeRepeatedInt64String,
                  },
                  major_axis: {
                    n: 5,
                    d: 512,
                    br: g.qM.readUint32,
                    bw: g.gp.writeUint32,
                  },
                  time_precision: {
                    n: 6,
                    d: o.k_ePrecise,
                    br: g.qM.readEnum,
                    bw: g.gp.writeEnum,
                  },
                  format: {
                    n: 8,
                    d: m.k_eJPEG,
                    br: g.qM.readEnum,
                    bw: g.gp.writeEnum,
                  },
                },
              }),
            Ce.sm_m
          );
        }
        static MBF() {
          return Ce.sm_mbf || (Ce.sm_mbf = g.w0(Ce.M())), Ce.sm_mbf;
        }
        toObject(e = !1) {
          return Ce.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ce.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ce.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ce();
          return Ce.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ce.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ce.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ce.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ce.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetThumbnails_Request";
        }
      }
      class Ee extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ee.prototype.thumbnails || g.Sg(Ee.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ee.sm_m ||
              (Ee.sm_m = {
                proto: Ee,
                fields: { thumbnails: { n: 1, c: Ie, r: !0, q: !0 } },
              }),
            Ee.sm_m
          );
        }
        static MBF() {
          return Ee.sm_mbf || (Ee.sm_mbf = g.w0(Ee.M())), Ee.sm_mbf;
        }
        toObject(e = !1) {
          return Ee.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ee.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ee.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ee();
          return Ee.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ee.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ee.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ee.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ee.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetThumbnails_Response";
        }
      }
      class Ie extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ie.prototype.image_data || g.Sg(Ie.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ie.sm_m ||
              (Ie.sm_m = {
                proto: Ie,
                fields: {
                  image_data: { n: 1, br: g.qM.readBytes, bw: g.gp.writeBytes },
                  width: { n: 2, br: g.qM.readUint32, bw: g.gp.writeUint32 },
                  height: { n: 3, br: g.qM.readUint32, bw: g.gp.writeUint32 },
                },
              }),
            Ie.sm_m
          );
        }
        static MBF() {
          return Ie.sm_mbf || (Ie.sm_mbf = g.w0(Ie.M())), Ie.sm_mbf;
        }
        toObject(e = !1) {
          return Ie.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ie.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ie.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ie();
          return Ie.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ie.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ie.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ie.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ie.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetThumbnails_Response_Thumbnail";
        }
      }
      class ke extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ke.prototype.game_id || g.Sg(ke.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ke.sm_m ||
              (ke.sm_m = {
                proto: ke,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            ke.sm_m
          );
        }
        static MBF() {
          return ke.sm_mbf || (ke.sm_mbf = g.w0(ke.M())), ke.sm_mbf;
        }
        toObject(e = !1) {
          return ke.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ke.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ke.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ke();
          return ke.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ke.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ke.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ke.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ke.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StartRecording_Request";
        }
      }
      class Pe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Pe.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Pe();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Pe();
          return Pe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Pe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Pe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StartRecording_Response";
        }
      }
      class Oe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Oe.prototype.game_id || g.Sg(Oe.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Oe.sm_m ||
              (Oe.sm_m = {
                proto: Oe,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            Oe.sm_m
          );
        }
        static MBF() {
          return Oe.sm_mbf || (Oe.sm_mbf = g.w0(Oe.M())), Oe.sm_mbf;
        }
        toObject(e = !1) {
          return Oe.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Oe.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Oe.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Oe();
          return Oe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Oe.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Oe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Oe.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Oe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StopRecording_Request";
        }
      }
      class ze extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ze.prototype.summary || g.Sg(ze.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ze.sm_m ||
              (ze.sm_m = { proto: ze, fields: { summary: { n: 1, c: J } } }),
            ze.sm_m
          );
        }
        static MBF() {
          return ze.sm_mbf || (ze.sm_mbf = g.w0(ze.M())), ze.sm_mbf;
        }
        toObject(e = !1) {
          return ze.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(ze.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(ze.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new ze();
          return ze.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(ze.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return ze.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(ze.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return ze.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StopRecording_Response";
        }
      }
      class De extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            De.prototype.game_id || g.Sg(De.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            De.sm_m ||
              (De.sm_m = {
                proto: De,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            De.sm_m
          );
        }
        static MBF() {
          return De.sm_mbf || (De.sm_mbf = g.w0(De.M())), De.sm_mbf;
        }
        toObject(e = !1) {
          return De.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(De.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(De.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new De();
          return De.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(De.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return De.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(De.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return De.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetRecordingSize_Request";
        }
      }
      class Ae extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ae.prototype.file_size || g.Sg(Ae.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ae.sm_m ||
              (Ae.sm_m = {
                proto: Ae,
                fields: {
                  file_size: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            Ae.sm_m
          );
        }
        static MBF() {
          return Ae.sm_mbf || (Ae.sm_mbf = g.w0(Ae.M())), Ae.sm_mbf;
        }
        toObject(e = !1) {
          return Ae.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ae.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ae.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ae();
          return Ae.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ae.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ae.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ae.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ae.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetRecordingSize_Response";
        }
      }
      class We extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return We.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new We();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new We();
          return We.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return We.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return We.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_CleanupBackgroundRecordings_Request";
        }
      }
      class Fe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Fe.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Fe();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Fe();
          return Fe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Fe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Fe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_CleanupBackgroundRecordings_Response";
        }
      }
      class qe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return qe.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new qe();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new qe();
          return qe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return qe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return qe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetPlatformCapabilities_Request";
        }
      }
      class Ne extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ne.prototype.per_process_audio_capture || g.Sg(Ne.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ne.sm_m ||
              (Ne.sm_m = {
                proto: Ne,
                fields: {
                  per_process_audio_capture: {
                    n: 1,
                    br: g.qM.readBool,
                    bw: g.gp.writeBool,
                  },
                },
              }),
            Ne.sm_m
          );
        }
        static MBF() {
          return Ne.sm_mbf || (Ne.sm_mbf = g.w0(Ne.M())), Ne.sm_mbf;
        }
        toObject(e = !1) {
          return Ne.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ne.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ne.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ne();
          return Ne.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ne.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ne.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ne.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ne.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetPlatformCapabilities_Response";
        }
      }
      class xe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            xe.prototype.summary || g.Sg(xe.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            xe.sm_m ||
              (xe.sm_m = { proto: xe, fields: { summary: { n: 1, c: J } } }),
            xe.sm_m
          );
        }
        static MBF() {
          return xe.sm_mbf || (xe.sm_mbf = g.w0(xe.M())), xe.sm_mbf;
        }
        toObject(e = !1) {
          return xe.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(xe.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(xe.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new xe();
          return xe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(xe.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return xe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(xe.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return xe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ClipCreated_Notification";
        }
      }
      class Ue extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ue.prototype.clip_id || g.Sg(Ue.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ue.sm_m ||
              (Ue.sm_m = {
                proto: Ue,
                fields: {
                  clip_id: { n: 1, br: g.qM.readString, bw: g.gp.writeString },
                  game_id: {
                    n: 2,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            Ue.sm_m
          );
        }
        static MBF() {
          return Ue.sm_mbf || (Ue.sm_mbf = g.w0(Ue.M())), Ue.sm_mbf;
        }
        toObject(e = !1) {
          return Ue.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ue.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ue.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ue();
          return Ue.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ue.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ue.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ue.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ue.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ClipDeleted_Notification";
        }
      }
      class je extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            je.prototype.progress || g.Sg(je.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            je.sm_m ||
              (je.sm_m = {
                proto: je,
                fields: {
                  progress: { n: 1, br: g.qM.readFloat, bw: g.gp.writeFloat },
                  clip_id: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                  eresult: { n: 3, br: g.qM.readInt32, bw: g.gp.writeInt32 },
                },
              }),
            je.sm_m
          );
        }
        static MBF() {
          return je.sm_mbf || (je.sm_mbf = g.w0(je.M())), je.sm_mbf;
        }
        toObject(e = !1) {
          return je.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(je.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(je.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new je();
          return je.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(je.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return je.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(je.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return je.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportProgress_Notification";
        }
      }
      class Le extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Le.prototype.gameid || g.Sg(Le.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Le.sm_m ||
              (Le.sm_m = {
                proto: Le,
                fields: {
                  gameid: {
                    n: 1,
                    br: g.qM.readFixed64String,
                    bw: g.gp.writeFixed64String,
                  },
                  enabled: { n: 2, br: g.qM.readBool, bw: g.gp.writeBool },
                  minutes: { n: 3, br: g.qM.readUint32, bw: g.gp.writeUint32 },
                  bitrate: { n: 4, br: g.qM.readString, bw: g.gp.writeString },
                  infinite: { n: 5, br: g.qM.readBool, bw: g.gp.writeBool },
                },
              }),
            Le.sm_m
          );
        }
        static MBF() {
          return Le.sm_mbf || (Le.sm_mbf = g.w0(Le.M())), Le.sm_mbf;
        }
        toObject(e = !1) {
          return Le.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Le.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Le.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Le();
          return Le.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Le.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Le.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Le.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Le.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_PerGameSettings";
        }
      }
      class He extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return He.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new He();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new He();
          return He.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return He.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return He.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetPerGameSettings_Request";
        }
      }
      class Xe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Xe.prototype.settings || g.Sg(Xe.M()),
            d.Message.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Xe.sm_m ||
              (Xe.sm_m = {
                proto: Xe,
                fields: { settings: { n: 1, c: Le, r: !0, q: !0 } },
              }),
            Xe.sm_m
          );
        }
        static MBF() {
          return Xe.sm_mbf || (Xe.sm_mbf = g.w0(Xe.M())), Xe.sm_mbf;
        }
        toObject(e = !1) {
          return Xe.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Xe.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Xe.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Xe();
          return Xe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Xe.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Xe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Xe.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Xe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetPerGameSettings_Response";
        }
      }
      class Ve extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ve.prototype.game_settings || g.Sg(Ve.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ve.sm_m ||
              (Ve.sm_m = {
                proto: Ve,
                fields: { game_settings: { n: 1, c: Le } },
              }),
            Ve.sm_m
          );
        }
        static MBF() {
          return Ve.sm_mbf || (Ve.sm_mbf = g.w0(Ve.M())), Ve.sm_mbf;
        }
        toObject(e = !1) {
          return Ve.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ve.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ve.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ve();
          return Ve.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ve.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ve.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ve.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ve.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SetPerGameSettings_Request";
        }
      }
      class Ze extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Ze.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Ze();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ze();
          return Ze.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ze.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ze.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SetPerGameSettings_Response";
        }
      }
      class Ke extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ke.prototype.gameid || g.Sg(Ke.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ke.sm_m ||
              (Ke.sm_m = {
                proto: Ke,
                fields: {
                  gameid: {
                    n: 1,
                    br: g.qM.readFixed64String,
                    bw: g.gp.writeFixed64String,
                  },
                },
              }),
            Ke.sm_m
          );
        }
        static MBF() {
          return Ke.sm_mbf || (Ke.sm_mbf = g.w0(Ke.M())), Ke.sm_mbf;
        }
        toObject(e = !1) {
          return Ke.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Ke.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Ke.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ke();
          return Ke.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Ke.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ke.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Ke.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ke.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeletePerGameSettings_Request";
        }
      }
      class Qe extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Qe.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Qe();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Qe();
          return Qe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Qe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Qe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeletePerGameSettings_Response";
        }
      }
      class Je extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Je.prototype.progress || g.Sg(Je.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Je.sm_m ||
              (Je.sm_m = {
                proto: Je,
                fields: {
                  progress: { n: 1, br: g.qM.readFloat, bw: g.gp.writeFloat },
                  clip_id: { n: 2, br: g.qM.readString, bw: g.gp.writeString },
                  eresult: { n: 3, br: g.qM.readInt32, bw: g.gp.writeInt32 },
                },
              }),
            Je.sm_m
          );
        }
        static MBF() {
          return Je.sm_mbf || (Je.sm_mbf = g.w0(Je.M())), Je.sm_mbf;
        }
        toObject(e = !1) {
          return Je.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT(Je.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq(Je.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Je();
          return Je.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj(Je.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Je.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0(Je.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Je.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UploadProgress_Notification";
        }
      }
      class $e extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            $e.prototype.game_id || g.Sg($e.M()),
            d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            $e.sm_m ||
              ($e.sm_m = {
                proto: $e,
                fields: {
                  game_id: {
                    n: 1,
                    br: g.qM.readUint64String,
                    bw: g.gp.writeUint64String,
                  },
                },
              }),
            $e.sm_m
          );
        }
        static MBF() {
          return $e.sm_mbf || ($e.sm_mbf = g.w0($e.M())), $e.sm_mbf;
        }
        toObject(e = !1) {
          return $e.toObject(e, this);
        }
        static toObject(e, t) {
          return g.BT($e.M(), e, t);
        }
        static fromObject(e) {
          return g.Uq($e.M(), e);
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new $e();
          return $e.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return g.zj($e.MBF(), e, t);
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return $e.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          g.i0($e.M(), e, t);
        }
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return $e.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SwitchBackgroundRecordingGame_Request";
        }
      }
      class Ye extends d.Message {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.Message.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Ye.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Ye();
        }
        static deserializeBinary(e) {
          let t = new (u().BinaryReader)(e),
            r = new Ye();
          return Ye.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new (u().BinaryWriter)();
          return Ye.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new (u().BinaryWriter)();
          return Ye.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SwitchBackgroundRecordingGame_Response";
        }
      }
      !(function (e) {
        (e.GetAppsWithBackgroundVideoHandler = {
          name: "GameRecording.GetAppsWithBackgroundVideo#1",
          request: B,
          response: v,
        }),
          (e.GetAppsWithBackgroundVideo = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAppsWithBackgroundVideo#1",
                  (0, p.I8)(B, e),
                  v,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetAppsWithBackgroundVideo = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAppsWithBackgroundVideo#1",
                  (0, p.I8)(B, e),
                  v,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetTimelinesForAppHandler = {
            name: "GameRecording.GetTimelinesForApp#1",
            request: G,
            response: w,
          }),
          (e.GetTimelinesForApp = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForApp#1",
                  (0, p.I8)(G, e),
                  w,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetTimelinesForApp = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForApp#1",
                  (0, p.I8)(G, e),
                  w,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetTimelinesForClipHandler = {
            name: "GameRecording.GetTimelinesForClip#1",
            request: C,
            response: E,
          }),
          (e.GetTimelinesForClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForClip#1",
                  (0, p.I8)(C, e),
                  E,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetTimelinesForClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForClip#1",
                  (0, p.I8)(C, e),
                  E,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.QueryPhasesHandler = {
            name: "GameRecording.QueryPhases#1",
            request: I,
            response: P,
          }),
          (e.QueryPhases = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.QueryPhases#1", (0, p.I8)(I, e), P, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgQueryPhases = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.QueryPhases#1", (0, p.I8)(I, e), P, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.GetTagsHandler = {
            name: "GameRecording.GetTags#1",
            request: D,
            response: A,
          }),
          (e.GetTags = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.GetTags#1", (0, p.I8)(D, e), A, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgGetTags = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.GetTags#1", (0, p.I8)(D, e), A, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.GetEnoughDiskSpaceHandler = {
            name: "GameRecording.GetEnoughDiskSpace#1",
            request: W,
            response: F,
          }),
          (e.GetEnoughDiskSpace = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetEnoughDiskSpace#1",
                  (0, p.I8)(W, e),
                  F,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetEnoughDiskSpace = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetEnoughDiskSpace#1",
                  (0, p.I8)(W, e),
                  F,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetAvailableDiskSpaceHandler = {
            name: "GameRecording.GetAvailableDiskSpace#1",
            request: q,
            response: N,
          }),
          (e.GetAvailableDiskSpace = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAvailableDiskSpace#1",
                  (0, p.I8)(q, e),
                  N,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetAvailableDiskSpace = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAvailableDiskSpace#1",
                  (0, p.I8)(q, e),
                  N,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SaveClipHandler = {
            name: "GameRecording.SaveClip#1",
            request: $,
            response: ee,
          }),
          (e.SaveClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.SaveClip#1", (0, p.I8)($, e), ee, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgSaveClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.SaveClip#1", (0, p.I8)($, e), ee, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.DeleteClipHandler = {
            name: "GameRecording.DeleteClip#1",
            request: te,
            response: re,
          }),
          (e.DeleteClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.DeleteClip#1", (0, p.I8)(te, e), re, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgDeleteClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.DeleteClip#1", (0, p.I8)(te, e), re, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.GetClipsHandler = {
            name: "GameRecording.GetClips#1",
            request: pe,
            response: _e,
          }),
          (e.GetClips = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.GetClips#1", (0, p.I8)(pe, e), _e, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgGetClips = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.GetClips#1", (0, p.I8)(pe, e), _e, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.UploadClipToSteamHandler = {
            name: "GameRecording.UploadClipToSteam#1",
            request: ce,
            response: de,
          }),
          (e.UploadClipToSteam = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UploadClipToSteam#1",
                  (0, p.I8)(ce, e),
                  de,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUploadClipToSteam = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UploadClipToSteam#1",
                  (0, p.I8)(ce, e),
                  de,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.ExportClipHandler = {
            name: "GameRecording.ExportClip#1",
            request: ne,
            response: ae,
          }),
          (e.ExportClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ExportClip#1", (0, p.I8)(ne, e), ae, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgExportClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ExportClip#1", (0, p.I8)(ne, e), ae, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.ExportClipPreviewHandler = {
            name: "GameRecording.ExportClipPreview#1",
            request: se,
            response: le,
          }),
          (e.ExportClipPreview = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.ExportClipPreview#1",
                  (0, p.I8)(se, e),
                  le,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgExportClipPreview = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.ExportClipPreview#1",
                  (0, p.I8)(se, e),
                  le,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.TakeScreenshotHandler = {
            name: "GameRecording.TakeScreenshot#1",
            request: oe,
            response: me,
          }),
          (e.TakeScreenshot = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.TakeScreenshot#1",
                  (0, p.I8)(oe, e),
                  me,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgTakeScreenshot = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.TakeScreenshot#1",
                  (0, p.I8)(oe, e),
                  me,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.ZipClipHandler = {
            name: "GameRecording.ZipClip#1",
            request: ue,
            response: ge,
          }),
          (e.ZipClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ZipClip#1", (0, p.I8)(ue, e), ge, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgZipClip = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ZipClip#1", (0, p.I8)(ue, e), ge, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.StartRecordingHandler = {
            name: "GameRecording.StartRecording#1",
            request: ke,
            response: Pe,
          }),
          (e.StartRecording = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StartRecording#1",
                  (0, p.I8)(ke, e),
                  Pe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgStartRecording = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StartRecording#1",
                  (0, p.I8)(ke, e),
                  Pe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.StopRecordingHandler = {
            name: "GameRecording.StopRecording#1",
            request: Oe,
            response: ze,
          }),
          (e.StopRecording = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StopRecording#1",
                  (0, p.I8)(Oe, e),
                  ze,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgStopRecording = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StopRecording#1",
                  (0, p.I8)(Oe, e),
                  ze,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetBackgroundRecordingFileSizeHandler = {
            name: "GameRecording.GetBackgroundRecordingFileSize#1",
            request: De,
            response: Ae,
          }),
          (e.GetBackgroundRecordingFileSize = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetBackgroundRecordingFileSize#1",
                  (0, p.I8)(De, e),
                  Ae,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetBackgroundRecordingFileSize = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetBackgroundRecordingFileSize#1",
                  (0, p.I8)(De, e),
                  Ae,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.CleanupBackgroundRecordingsHandler = {
            name: "GameRecording.CleanupBackgroundRecordings#1",
            request: We,
            response: Fe,
          }),
          (e.CleanupBackgroundRecordings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.CleanupBackgroundRecordings#1",
                  (0, p.I8)(We, e),
                  Fe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgCleanupBackgroundRecordings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.CleanupBackgroundRecordings#1",
                  (0, p.I8)(We, e),
                  Fe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetAndTrimPostGameHighlightsHandler = {
            name: "GameRecording.GetAndTrimPostGameHighlights#1",
            request: fe,
            response: he,
          }),
          (e.GetAndTrimPostGameHighlights = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAndTrimPostGameHighlights#1",
                  (0, p.I8)(fe, e),
                  he,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetAndTrimPostGameHighlights = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAndTrimPostGameHighlights#1",
                  (0, p.I8)(fe, e),
                  he,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetThumbnailsHandler = {
            name: "GameRecording.GetThumbnails#1",
            request: Ce,
            response: Ee,
          }),
          (e.GetThumbnails = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetThumbnails#1",
                  (0, p.I8)(Ce, e),
                  Ee,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetThumbnails = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetThumbnails#1",
                  (0, p.I8)(Ce, e),
                  Ee,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetPlatformCapabilitiesHandler = {
            name: "GameRecording.GetPlatformCapabilities#1",
            request: qe,
            response: Ne,
          }),
          (e.GetPlatformCapabilities = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetPlatformCapabilities#1",
                  (0, p.I8)(qe, e),
                  Ne,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetPlatformCapabilities = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetPlatformCapabilities#1",
                  (0, p.I8)(qe, e),
                  Ne,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyTimelineChangedHandler = {
            name: "GameRecording.NotifyTimelineChanged#1",
            request: x,
          }),
          (e.RegisterForNotifyTimelineChanged = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyTimelineChangedHandler,
                  t,
                );
          }),
          (e.NotifyTimelineChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineChanged#1",
                  (0, p.I8)(x, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyTimelineChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineChanged#1",
                  (0, p.I8)(x, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyRecordingSessionChangedHandler = {
            name: "GameRecording.NotifyRecordingSessionChanged#1",
            request: U,
          }),
          (e.RegisterForNotifyRecordingSessionChanged = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyRecordingSessionChangedHandler,
                  t,
                );
          }),
          (e.NotifyRecordingSessionChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyRecordingSessionChanged#1",
                  (0, p.I8)(U, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyRecordingSessionChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyRecordingSessionChanged#1",
                  (0, p.I8)(U, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyTimelineEntryChangedHandler = {
            name: "GameRecording.NotifyTimelineEntryChanged#1",
            request: L,
          }),
          (e.RegisterForNotifyTimelineEntryChanged = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyTimelineEntryChangedHandler,
                  t,
                );
          }),
          (e.NotifyTimelineEntryChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineEntryChanged#1",
                  (0, p.I8)(L, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyTimelineEntryChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineEntryChanged#1",
                  (0, p.I8)(L, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyTimelineEntryRemovedHandler = {
            name: "GameRecording.NotifyTimelineEntryRemoved#1",
            request: H,
          }),
          (e.RegisterForNotifyTimelineEntryRemoved = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyTimelineEntryRemovedHandler,
                  t,
                );
          }),
          (e.NotifyTimelineEntryRemoved = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineEntryRemoved#1",
                  (0, p.I8)(H, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyTimelineEntryRemoved = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineEntryRemoved#1",
                  (0, p.I8)(H, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyClipCreatedHandler = {
            name: "GameRecording.NotifyClipCreated#1",
            request: xe,
          }),
          (e.RegisterForNotifyClipCreated = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyClipCreatedHandler,
                  t,
                );
          }),
          (e.NotifyClipCreated = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipCreated#1",
                  (0, p.I8)(xe, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyClipCreated = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipCreated#1",
                  (0, p.I8)(xe, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyClipDeletedHandler = {
            name: "GameRecording.NotifyClipDeleted#1",
            request: Ue,
          }),
          (e.RegisterForNotifyClipDeleted = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyClipDeletedHandler,
                  t,
                );
          }),
          (e.NotifyClipDeleted = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipDeleted#1",
                  (0, p.I8)(Ue, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyClipDeleted = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipDeleted#1",
                  (0, p.I8)(Ue, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyExportProgressHandler = {
            name: "GameRecording.NotifyExportProgress#1",
            request: je,
          }),
          (e.RegisterForNotifyExportProgress = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyExportProgressHandler,
                  t,
                );
          }),
          (e.NotifyExportProgress = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyExportProgress#1",
                  (0, p.I8)(je, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyExportProgress = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyExportProgress#1",
                  (0, p.I8)(je, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyUploadProgressHandler = {
            name: "GameRecording.NotifyUploadProgress#1",
            request: Je,
          }),
          (e.RegisterForNotifyUploadProgress = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyUploadProgressHandler,
                  t,
                );
          }),
          (e.NotifyUploadProgress = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyUploadProgress#1",
                  (0, p.I8)(Je, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyUploadProgress = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyUploadProgress#1",
                  (0, p.I8)(Je, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyLowDiskSpaceHandler = {
            name: "GameRecording.NotifyLowDiskSpace#1",
            request: X,
          }),
          (e.RegisterForNotifyLowDiskSpace = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyLowDiskSpaceHandler,
                  t,
                );
          }),
          (e.NotifyLowDiskSpace = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyLowDiskSpace#1",
                  (0, p.I8)(X, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyLowDiskSpace = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyLowDiskSpace#1",
                  (0, p.I8)(X, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyPostGameHighlightsChangedHandler = {
            name: "GameRecording.NotifyPostGameHighlightsChanged#1",
            request: V,
          }),
          (e.RegisterForNotifyPostGameHighlightsChanged = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyPostGameHighlightsChangedHandler,
                  t,
                );
          }),
          (e.NotifyPostGameHighlightsChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyPostGameHighlightsChanged#1",
                  (0, p.I8)(V, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyPostGameHighlightsChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyPostGameHighlightsChanged#1",
                  (0, p.I8)(V, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyOpenOverlayToGamePhaseHandler = {
            name: "GameRecording.NotifyOpenOverlayToGamePhase#1",
            request: Z,
          }),
          (e.RegisterForNotifyOpenOverlayToGamePhase = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyOpenOverlayToGamePhaseHandler,
                  t,
                );
          }),
          (e.NotifyOpenOverlayToGamePhase = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyOpenOverlayToGamePhase#1",
                  (0, p.I8)(Z, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyOpenOverlayToGamePhase = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyOpenOverlayToGamePhase#1",
                  (0, p.I8)(Z, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyOpenOverlayToTimelineEventHandler = {
            name: "GameRecording.NotifyOpenOverlayToTimelineEvent#1",
            request: K,
          }),
          (e.RegisterForNotifyOpenOverlayToTimelineEvent = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyOpenOverlayToTimelineEventHandler,
                  t,
                );
          }),
          (e.NotifyOpenOverlayToTimelineEvent = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyOpenOverlayToTimelineEvent#1",
                  (0, p.I8)(K, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyOpenOverlayToTimelineEvent = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyOpenOverlayToTimelineEvent#1",
                  (0, p.I8)(K, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyPhaseListChangedHandler = {
            name: "GameRecording.NotifyPhaseListChanged#1",
            request: Q,
          }),
          (e.RegisterForNotifyPhaseListChanged = function (t, r) {
            return null == (r = r || (0, _.OI)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyPhaseListChangedHandler,
                  t,
                );
          }),
          (e.NotifyPhaseListChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyPhaseListChanged#1",
                  (0, p.I8)(Q, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyPhaseListChanged = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyPhaseListChanged#1",
                  (0, p.I8)(Q, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetPerGameSettingsHandler = {
            name: "GameRecording.GetPerGameSettings#1",
            request: He,
            response: Xe,
          }),
          (e.GetPerGameSettings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetPerGameSettings#1",
                  (0, p.I8)(He, e),
                  Xe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetPerGameSettings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetPerGameSettings#1",
                  (0, p.I8)(He, e),
                  Xe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SetPerGameSettingsHandler = {
            name: "GameRecording.SetPerGameSettings#1",
            request: Ve,
            response: Ze,
          }),
          (e.SetPerGameSettings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.SetPerGameSettings#1",
                  (0, p.I8)(Ve, e),
                  Ze,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgSetPerGameSettings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.SetPerGameSettings#1",
                  (0, p.I8)(Ve, e),
                  Ze,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.DeletePerGameSettingsHandler = {
            name: "GameRecording.DeletePerGameSettings#1",
            request: Ke,
            response: Qe,
          }),
          (e.DeletePerGameSettings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.DeletePerGameSettings#1",
                  (0, p.I8)(Ke, e),
                  Qe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgDeletePerGameSettings = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.DeletePerGameSettings#1",
                  (0, p.I8)(Ke, e),
                  Qe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.UserAddTimelineEntryHandler = {
            name: "GameRecording.UserAddTimelineEntry#1",
            request: Se,
            response: be,
          }),
          (e.UserAddTimelineEntry = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserAddTimelineEntry#1",
                  (0, p.I8)(Se, e),
                  be,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUserAddTimelineEntry = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserAddTimelineEntry#1",
                  (0, p.I8)(Se, e),
                  be,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.UserUpdateTimelineEntryHandler = {
            name: "GameRecording.UserUpdateTimelineEntry#1",
            request: Me,
            response: ye,
          }),
          (e.UserUpdateTimelineEntry = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserUpdateTimelineEntry#1",
                  (0, p.I8)(Me, e),
                  ye,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUserUpdateTimelineEntry = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserUpdateTimelineEntry#1",
                  (0, p.I8)(Me, e),
                  ye,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.UserRemoveTimelineEntryHandler = {
            name: "GameRecording.UserRemoveTimelineEntry#1",
            request: Te,
            response: Be,
          }),
          (e.UserRemoveTimelineEntry = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserRemoveTimelineEntry#1",
                  (0, p.I8)(Te, e),
                  Be,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUserRemoveTimelineEntry = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserRemoveTimelineEntry#1",
                  (0, p.I8)(Te, e),
                  Be,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.ManuallyDeleteRecordingsForAppsHandler = {
            name: "GameRecording.ManuallyDeleteRecordingsForApps#1",
            request: ve,
            response: Re,
          }),
          (e.ManuallyDeleteRecordingsForApps = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.ManuallyDeleteRecordingsForApps#1",
                  (0, p.I8)(ve, e),
                  Re,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgManuallyDeleteRecordingsForApps = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.ManuallyDeleteRecordingsForApps#1",
                  (0, p.I8)(ve, e),
                  Re,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetTotalDiskSpaceUsageHandler = {
            name: "GameRecording.GetTotalDiskSpaceUsage#1",
            request: Ge,
            response: we,
          }),
          (e.GetTotalDiskSpaceUsage = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTotalDiskSpaceUsage#1",
                  (0, p.I8)(Ge, e),
                  we,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetTotalDiskSpaceUsage = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTotalDiskSpaceUsage#1",
                  (0, p.I8)(Ge, e),
                  we,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SwitchBackgroundRecordingGameHandler = {
            name: "GameRecording.SwitchBackgroundRecordingGame#1",
            request: $e,
            response: Ye,
          }),
          (e.SwitchBackgroundRecordingGame = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.SwitchBackgroundRecordingGame#1",
                  (0, p.I8)($e, e),
                  Ye,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgSwitchBackgroundRecordingGame = function (e, t) {
            return null == (t = t || (0, _.OI)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.SwitchBackgroundRecordingGame#1",
                  (0, p.I8)($e, e),
                  Ye,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          });
      })(c || (c = {}));
    },
    29210: (e, t, r) => {
      "use strict";
      r.d(t, { VS: () => l });
      var i = r(38506),
        n = r(22837),
        a = r(17690),
        s = r(81393);
      class l {
        m_ulGameID;
        constructor(e, t, r) {
          if ("string" == typeof e) this.m_ulGameID = i.A.fromString(e, !0);
          else {
            const n = r,
              a = ((255 & e) << 24) + (16777215 & t);
            this.m_ulGameID = i.A.fromBits(a, n, !0);
          }
        }
        GetAppID() {
          return 16777215 & this.m_ulGameID.getLowBitsUnsigned();
        }
        GetType() {
          return (this.m_ulGameID.getLowBitsUnsigned() >> 24) & 255;
        }
        GetModID() {
          return this.m_ulGameID.getHighBitsUnsigned();
        }
        ConvertTo64BitString() {
          return this.m_ulGameID.toString();
        }
        BIsSteamApp() {
          return this.GetType() === n.Rh.k_EGameIDTypeApp;
        }
        BIsShortcut() {
          return this.GetType() === n.Rh.k_EGameIDTypeShortcut;
        }
        BIsMod() {
          return this.GetType() === n.Rh.k_EGameIDTypeGameMod;
        }
        BIsP2PFile() {
          return this.GetType() === n.Rh.k_EGameIDTypeP2P;
        }
        GetInternalAppID() {
          return this.BIsSteamApp() ? this.GetAppID() : this.GetModID();
        }
        BIsValid() {
          switch (this.GetType()) {
            case n.Rh.k_EGameIDTypeApp:
              return this.GetAppID() !== a.sc;
            case n.Rh.k_EGameIDTypeGameMod:
              return this.GetAppID() !== a.sc && 2147483648 & this.GetModID();
            case n.Rh.k_EGameIDTypeShortcut:
              return 0 != (2147483648 & this.GetModID());
            case n.Rh.k_EGameIDTypeP2P:
              return this.GetAppID() === a.sc && 2147483648 & this.GetModID();
            default:
              return (
                (0, s.wT)(!1, `Unknown GameID type: ${this.GetType()}`), !1
              );
          }
        }
        static InitFromAppID(e) {
          return new l(n.Rh.k_EGameIDTypeApp, e, 0);
        }
        static InitFromShortcutID(e) {
          return new l(n.Rh.k_EGameIDTypeShortcut, 0, e);
        }
      }
    },
    68797: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => l });
      var i = r(37085),
        n = r(41735),
        a = r.n(n),
        s = r(56545);
      function l(e) {
        if (a().isCancel(e))
          return {
            strErrorMsg: "Action Cancelled:" + e,
            errorCode: i.d.k_EResultCancelled,
          };
        if (
          void 0 !== e.response &&
          e.response.data &&
          "object" == typeof e.response.data
        ) {
          if ("msg" in e.response.data)
            return {
              strErrorMsg: e.response.data.msg,
              errorCode: e.response.data.success,
            };
          if ("err_msg" in e.response.data)
            return {
              strErrorMsg: e.response.data.err_msg,
              errorCode: e.response.data.success,
            };
          if ("message" in e.response.data)
            return {
              strErrorMsg: e.response.data.message,
              errorCode: e.response.data.success,
            };
          if ("success" in e.response.data)
            return {
              strErrorMsg: "error code: " + e.response.data.success,
              errorCode: e.response.data.success,
            };
        } else if ("object" == typeof e.data) {
          if ("msg" in e.data)
            return { strErrorMsg: e.data.msg, errorCode: e.data.success };
          if ("err_msg" in e.data)
            return { strErrorMsg: e.data.err_msg, errorCode: e.data.success };
          if ("message" in e.data)
            return { strErrorMsg: e.data.message, errorCode: e.data.success };
          if ("success" in e.data)
            return {
              strErrorMsg: "error code: " + e.data.success,
              errorCode: e.data.success,
            };
        } else {
          if (void 0 !== e.success && void 0 !== e.msg)
            return { strErrorMsg: e.msg, errorCode: e.success };
          if (void 0 !== e.success && void 0 !== e.message)
            return { strErrorMsg: e.message, errorCode: e.success };
          if (void 0 !== e.success && void 0 !== e.err_msg)
            return { strErrorMsg: e.err_msg, errorCode: e.success };
          if ("string" == typeof e && e.length > 1024)
            console.groupCollapsed(
              "GetMsgAndErrorCodeFromResponse cannot parse: ",
            ),
              console.warn(e),
              console.groupEnd();
          else {
            if ("object" == typeof e && e instanceof s.w)
              return {
                strErrorMsg: "" + e.GetErrorMessage(),
                errorCode: e.GetEResult(),
              };
            console.warn("GetMsgAndErrorCodeFromResponse cannot parse: ", e);
          }
        }
        return "object" == typeof e && "status" in e
          ? {
              strErrorMsg: "Unknown Error: " + e + "\nStatus Code:" + e.status,
              errorCode: i.d.k_EResultFail,
            }
          : {
              strErrorMsg: "Unknown Error: " + e,
              errorCode: i.d.k_EResultFail,
            };
      }
    },
  },
]);
