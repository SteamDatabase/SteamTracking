(self.webpackChunkcommunity = self.webpackChunkcommunity || []).push([
  [3772],
  {
    chunkid: (module) => {
      module.exports = {
        CarouselEditContainer: "_3kKETJYqcMOvI7DoPg8NRp",
        CarouselList: "_29awDHhUWS3DKirluu8OGx",
        ListItem: "uUOCgnwAbXeUmKvdAccoH",
        DraggableItem: "XruR-YbySxPawieGNohW6",
        ImagePreview: "_3RALyudkR9YsufJ__hQRLZ",
        Spacer: "EAttw6yxMpx398nbBEbMz",
        Controls: "Ge-JWjIp9WDyaaxi6CvtR",
        Control: "vwJtDHPeg0gv0CI7yGChD",
        AddButton: "_36RM9HiLN49wfehWU79FHe",
        PlusIcon: "_3nwxvp5yLdVg3iJ1eAi63z",
      };
    },
    chunkid: (module) => {
      module.exports = {
        ClanImageContainer: "_1TEbObXeFqUF-IRZKx0Qg5",
        Selected: "_3VVyv-d-F-7paQgn90RTr0",
        "extra-asset-blink": "_3AFR3dAEjYGOiz7dgTms8Y",
        ClanImageModalContent: "SsgHukHcE1jf7p3W6Ta8g",
        ClanImageModalMode: "_1RAzAQViGO8A_wCFzSUStH",
        Active: "_1qsUls0lc9uJ_RarLA3dcG",
        ClanImageGridForm: "_3uCm4z1gjW0tmhRd228Xqh",
        ClanImageGridContainer: "_3Q5TF6lMOT30JuoipVGd5C",
      };
    },
    chunkid: (module) => {
      module.exports = {
        Column: "_3l7NrcIIw_fedlHdVwJMVE",
        controls: "_3PGiW8qQcZDfnK9rOz7sjY",
        EditorCtn: "_2tY4qnv8tygCT7s94cB4vX",
        AddNew: "JBYdBhACB7UzXP4l_tpF2",
        DialogCtn: "Hd3q3Z7if0Z5H7rKMfqGN",
        ParticipantRow: "_3wHfIq4f1KlUL4-fKL0jLv",
        EventDescriptionField: "_3WxO3z6DufUbRu-axJjjqp",
      };
    },
    chunkid: (module) => {
      module.exports = {
        EditorCtn: "_2h37cwEb2SfJphgpbu-dPv",
        controls: "kI20RMKnHD3qdQhl-Hr4K",
      };
    },
    chunkid: (module) => {
      module.exports = {
        DialogCtn: "_9JDWJYvoHTETKmebCO7iE",
        PollArea: "_1h-JdwvtVK38j8M4EXeUah",
        OptionInset: "_5o_Ifm1O6jf-4Iq4Kv07F",
        AdminOptions: "_1Kt8VfgLBvg0tD86og8ps7",
      };
    },
    chunkid: (module) => {
      module.exports = {
        EditableComponentToolbarContainer: "o3hf9xdErkO0g06PW47cS",
        EditableComponentToolbar: "_2Lz0NGsqaU7fnOxrrftZMG",
        EditableComponentInlineContainer: "_32qkMjC0nQ9LGh6fNXlNkM",
        InlineHoverContainer: "_1TX0Q6DERjhYWEDcU-0QLC",
        Hidden: "_3rZ3G-s7kNdbfzeAOTIYOr",
        WidthConstrained: "_1eKpwF-reh8vmJh6uM9dho",
        FloatingToolbarButton: "KsGqILWyUj2YuFJK_Zy7D",
        StrongShadows: "_3_c8HvckcvJ0FHwgeS1GtO",
      };
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      __webpack_require__._(module_exports),
        __webpack_require__._(module_exports, {
          default: () => _,
        });
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const { className: _, ...__webpack_require__ } = _;
        return _.createElement("div", {
          className: _()(_, _.EditableComponentToolbarContainer),
          ...__webpack_require__,
        });
      }
      function _(_) {
        const {
            toolbar: _,
            top: __webpack_require__,
            left: _,
            width: _,
            height: _,
            visible: _,
          } = _,
          _ = {
            left: `${_}px`,
            top: `${__webpack_require__}px`,
            width: `${_}px`,
            position: "absolute",
          },
          _ = _ < 120;
        return (
          (_ < 80 || _) &&
            ((_.top = __webpack_require__ - 32 - 16 + "px"),
            (_.height = "48px")),
          _.createElement(
            "div",
            {
              style: _,
              className: _()(
                _.InlineHoverContainer,
                _ && _.WidthConstrained,
                !_ && _.Hidden,
              ),
            },
            _,
          )
        );
      }
      function _(_) {
        const { className: _, toolbar: __webpack_require__, children: _ } = _,
          [_, _] = (0, _._)(),
          [_, _] = _.useState({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
          }),
          _ = (0, _.useRef)(void 0);
        return (
          (0, _.useLayoutEffect)(() => {
            if (_) {
              const _ = _.current;
              _({
                top: _.offsetTop,
                left: _.offsetLeft,
                width: _.offsetWidth,
                height: _.offsetHeight,
              });
            }
          }, [_]),
          _.createElement(
            _.Fragment,
            null,
            _.createElement(
              "span",
              {
                ref: _,
                className: _()(_, _.EditableComponentInlineContainer),
                ..._,
              },
              _.createElement(_, {
                ..._,
                toolbar: __webpack_require__,
                visible: _ && _.width > 0,
              }),
              _,
            ),
          )
        );
      }
      function _(_) {
        const {
          onEditClick: _,
          strEditDescription: __webpack_require__ = (0, _._)("#Button_Edit"),
          onDeleteClick: _,
          strDeleteDescription: _ = (0, _._)("#Button_Remove"),
          bStrongShadows: _ = !1,
          children: _,
        } = _;
        return _.createElement(
          _,
          {
            bStrongShadows: _,
          },
          _,
          _ &&
            _.createElement(
              _,
              {
                onClick: _,
                description: __webpack_require__,
              },
              _.createElement(_.ffu, null),
            ),
          _ &&
            _.createElement(
              _,
              {
                onClick: _,
                description: _,
              },
              _.createElement(_.sED, null),
            ),
        );
      }
      function _(_) {
        const { bStrongShadows: _, children: __webpack_require__ } = _;
        return _.createElement(
          "span",
          {
            className: _()(_.EditableComponentToolbar, _ && _.StrongShadows),
          },
          __webpack_require__,
        );
      }
      function _(_) {
        const { onClick: _, description: __webpack_require__, children: _ } = _;
        return _.createElement(
          _._,
          {
            onClick: _,
            tooltip: __webpack_require__,
            className: _.FloatingToolbarButton,
          },
          _,
        );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_, _) {
        const _ = _(_);
        if (_)
          return {
            node: _,
            nodeAttrs: _,
            clanImage: _(_, _),
          };
      }
      function _(_) {
        const {
            node: _,
            imageNodeType: __webpack_require__,
            videoNodeType: _,
            editModel: _,
            schemaConfig: _,
            removeNode: _,
            update: _,
            focusView: _,
          } = _,
          [_, _, _] = (0, _._)(),
          _ =
            (_.useCallback(() => {
              _(), _();
            }, [_, _]),
            _.GetClanSteamID()),
          _ = _.useMemo(() => {
            let _ = [];
            return (
              _.descendants((_) => {
                (_.type != __webpack_require__ && _.type != _) || _.push(_);
              }),
              _
            );
          }, [__webpack_require__, _, _]),
          _ = _.useCallback((_) => _((0, _._)(_)), [_]),
          _ = "true" === _.attrs.autoadvance,
          [_, _] = _(_, {
            autoAdvance: _,
            clanSteamID: _,
            imageNodeType: __webpack_require__,
            videoNodeType: _,
            carouselNodeType: _.type,
          }),
          _ = _.useCallback(() => {
            _(_);
          }, [_, _]);
        return _.createElement(
          _.Fragment,
          null,
          _,
          _.createElement(
            _,
            null,
            _.createElement(_, {
              onDeleteClick: _,
              strDeleteDescription: (0, _._)(
                "#EventEditor_CarouselEditor_RemoveCarousel",
              ),
              onEditClick: _,
              strEditDescription: (0, _._)(
                "#EventEditor_CarouselEditor_EditCarousel",
              ),
            }),
            _.createElement(
              _._,
              null,
              _.createElement(
                _._,
                {
                  strTag: "carousel",
                  args: {},
                  rawargs: "",
                  event: _.GetEventModel(),
                },
                _.map((_, _) =>
                  _.createElement(_, {
                    key: _,
                    node: _,
                    nodeAttrs: _(_),
                    schemaConfig: _,
                    event: _.GetEventModel(),
                  }),
                ),
              ),
            ),
          ),
        );
      }
      function _(_, _) {
        const _ = _.carouselNodeType,
          [_, _] = _.useState(void 0),
          _ = _.clanSteamID,
          _ = _.useCallback(
            (_) => {
              _(_.map((_) => _(_, _)).filter(Boolean));
            },
            [_],
          ),
          _ = _.useCallback(() => _(void 0), []),
          _ = _.useCallback(
            (_, _) => {
              const _ = __webpack_require__.create(
                {
                  autoadvance: _ ? "true" : null,
                },
                _.map(({ node: _ }) => _),
              );
              _(_);
            },
            [_, _],
          );
        return [
          _,
          _.createElement(
            _._,
            {
              active: void 0 !== _,
            },
            _.createElement(_, {
              ..._,
              images: _,
              onCarouselImagesSelected: _,
              hideModal: _,
            }),
          ),
        ];
      }
      function _(_) {
        const { nodeAttrs: _ } = _;
        return "image" == _.type ? _.attrs.src : _.attrs.mp4 || _.attrs.webm;
      }
      function _(_) {
        var _;
        const {
            hideModal: __webpack_require__,
            images: _,
            onCarouselImagesSelected: _,
            clanSteamID: _,
            imageNodeType: _,
            videoNodeType: _,
          } = _,
          [_, _] = _.useState(_),
          [_, _] = _.useState(
            null !== (_ = _.autoAdvance) && void 0 !== _ && _,
          ),
          _ = _.useCallback(
            (_, _) => {
              const _ = _(_, _.create(_));
              if (!_)
                throw `Couldn't parse image ${_.name} - ${JSON.stringify(_)}`;
              _((_) => {
                const _ = _(_);
                return _.find((_) => _(_) == _) ? _ : [..._, _];
              });
            },
            [_],
          ),
          _ = _.useCallback(() => {
            _(_, _), __webpack_require__();
          }, [_, __webpack_require__, _, _]),
          _ = _.useCallback((_) => {
            _.destination &&
              _((_) => _._(_.slice(), _.source.index, _.destination.index));
          }, []),
          { showInsertImageModal: _, imageModal: _ } = _({
            clanSteamID: _,
            imageNodeType: _,
            videoNodeType: _,
            onItemSelected: _,
          });
        return _.createElement(
          _.Fragment,
          null,
          _,
          _.createElement(
            _._,
            {
              active: !0,
              onDismiss: __webpack_require__,
            },
            _.createElement(
              _._,
              null,
              (0, _._)("#EventEditor_CarouselEditor_EditCarousel"),
            ),
            _.createElement(
              _._,
              null,
              _.createElement(_._, {
                label: (0, _._)("#EventEditor_CarouselEditor_AutoAdvance"),
                checked: _,
                onChange: _,
              }),
              _.createElement(
                _._,
                {
                  onDragEnd: _,
                },
                _.createElement(
                  _._,
                  {
                    droppableId: "droppable",
                    direction: "horizontal",
                  },
                  (_) =>
                    _.createElement(
                      "div",
                      {
                        className: _.CarouselList,
                        ..._.droppableProps,
                        ref: _.innerRef,
                      },
                      _.map((_, _) =>
                        _.createElement(
                          _._,
                          {
                            key: _(_),
                          },
                          _.createElement(
                            _._,
                            {
                              draggableId: _(_),
                              index: _,
                            },
                            (_, _, _) =>
                              _.createElement(_, {
                                draggableProvided: _,
                                image: _,
                                setSelectedImages: _,
                                iImage: _,
                                cImages: _.length,
                              }),
                          ),
                        ),
                      ),
                      _.placeholder,
                    ),
                ),
              ),
              _.createElement(
                _._,
                {
                  bottomSeparator: "none",
                  label: (0, _._)("#EventEditor_CarouselEditor_AddAnotherItem"),
                  className: _.AddButton,
                  onClick: _,
                },
                _.createElement(_.OMN, {
                  className: _.PlusIcon,
                }),
              ),
            ),
            _.createElement(
              _._,
              null,
              _.createElement(_._, {
                onCancel: __webpack_require__,
                onOK: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const {
            draggableProvided: _,
            image: __webpack_require__,
            setSelectedImages: _,
            iImage: _,
            cImages: _,
          } = _,
          _ = _.useCallback(() => {
            _((_) => _.filter((_) => _ != __webpack_require__));
          }, [__webpack_require__, _]);
        return _.createElement(
          "div",
          {
            className: _()(_.ListItem, _.DraggableItem),
            ref: _.innerRef,
            ..._.draggableProps,
            ..._.dragHandleProps,
          },
          _.createElement(
            "div",
            {
              className: _.ImagePreview,
            },
            _.createElement("img", {
              src: _._.ReplacementTokenToClanImageURL(
                __webpack_require__.node.attrs.src,
              ),
            }),
            _.createElement(
              "div",
              {
                className: _.Controls,
              },
              _.createElement(
                "div",
                {
                  className: _.Control,
                },
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    className: _.Button,
                  },
                  _.createElement(_.sED, null),
                ),
              ),
            ),
          ),
        );
      }
      function _(_) {
        const {
            schemaConfig: _,
            node: __webpack_require__,
            editModel: _,
            imageNodeType: _,
            videoNodeType: _,
            carouselNodeType: _,
            clanSteamID: _,
            setAttrs: _,
            focusView: _,
            removeNode: _,
            update: _,
            selected: _,
          } = _,
          [_, _, _] = (0, _._)(),
          _ = _(__webpack_require__);
        let _ = _.createElement(_, {
          schemaConfig: _,
          event: _.GetEventModel(),
          node: __webpack_require__,
          nodeAttrs: _,
        });
        const _ = _.useCallback(() => {
            _(), _();
          }, [_, _]),
          _ = _.useCallback((_) => _((0, _._)(_)), [_]),
          [_, _] = _(_, {
            clanSteamID: _,
            imageNodeType: _,
            videoNodeType: _,
            carouselNodeType: _,
          }),
          _ = _.useCallback(() => {
            _([__webpack_require__]);
          }, [__webpack_require__, _]),
          _ = {
            createCarousel: _ ? _ : void 0,
            src: _(_),
          };
        let _ = _()(_.ClanImageContainer, _ && _.Selected);
        return _.createElement(
          _.Fragment,
          null,
          _ &&
            _.createElement(_, {
              bIsEdit: !0,
              nodeAttrs: _,
              hideModal: _,
              imageNodeType: _,
              videoNodeType: _,
              clanSteamID: _,
              onItemSelected: _,
            }),
          _,
          _.createElement(
            _,
            {
              className: _,
              toolbar: _.createElement(_, {
                showModal: _,
                removeNode: _,
                contextMenuProps: _,
              }),
            },
            _,
          ),
        );
      }
      function _(_) {
        const {
            showModal: _,
            removeNode: __webpack_require__,
            contextMenuProps: _,
          } = _,
          _ = _.useCallback(
            (_) => {
              (0, _._)(
                _.createElement(_, {
                  ..._,
                }),
                _,
                {
                  bPreferPopTop: !1,
                  bPreferPopLeft: !0,
                },
              );
            },
            [_],
          );
        return _.createElement(
          _,
          {
            onEditClick: _,
            onDeleteClick: __webpack_require__,
          },
          _.createElement(
            _,
            {
              onClick: _,
              description: (0, _._)("#ActionButtonLabelContextMenu"),
            },
            _.createElement(_.h28, null),
          ),
        );
      }
      function _(_) {
        const { createCarousel: _, src: __webpack_require__ } = _,
          _ = _.useCallback(() => {
            window.open(__webpack_require__);
          }, [__webpack_require__]);
        return _.createElement(
          _._,
          null,
          _ &&
            _.createElement(
              _._,
              {
                onSelected: _,
              },
              (0, _._)("#EventEditor_CarouselEditor_CreateACarousel"),
            ),
          _.createElement(
            _._,
            {
              onSelected: _,
            },
            (0, _._)("#EventEditor_ImageEdit_PreviewImage"),
          ),
        );
      }
      function _(_) {
        const { type: _, attrs: __webpack_require__ } = _;
        return "image" == _.name
          ? {
              type: "image",
              attrs: __webpack_require__,
            }
          : "video" == _.name
            ? {
                type: "video",
                attrs: __webpack_require__,
              }
            : void 0;
      }
      function _(_) {
        return "image" == _.type
          ? _.attrs.src
          : "video" == _.type
            ? _.attrs.mp4 || _.attrs.webm
            : void 0;
      }
      function _(_) {
        const {
            schemaConfig: _,
            event: __webpack_require__,
            node: _,
            nodeAttrs: _,
          } = _,
          { type: _, attrs: _ } = _,
          _ = _.ConvertAttrToBBCodeArgs(_, _);
        return "image" == _
          ? _.createElement(_._, {
              strTag: "img",
              args: _,
              rawargs: "",
              event: __webpack_require__,
              showErrorInfo: !0,
            })
          : "video" == _
            ? _.createElement(_._, {
                key: `${_.mp4}_${_.webm}`,
                strTag: "video",
                args: _,
                rawargs: "",
                event: __webpack_require__,
                showErrorInfo: !0,
              })
            : ((0, _._)(_, "unhandled type: " + _), null);
      }
      function _(_, _) {
        const { type: __webpack_require__, attrs: _ } = _;
        let _;
        if (
          ("image" == __webpack_require__
            ? (_ = _.src)
            : "video" == __webpack_require__ && (_ = _.mp4 || _.webm),
          _)
        ) {
          const [_] = _._.ExtractHashFromBBCodeURL(_);
          return _ && _._.GetClanImageByImageHash(_, _);
        }
      }
      function _(_) {
        const {
            clanSteamID: _,
            imageNodeType: __webpack_require__,
            videoNodeType: _,
            onItemSelected: _,
            onHideModal: _,
          } = _,
          [_, _] = _.useState(),
          _ = _.useCallback(() => {
            _(void 0), _ && _();
          }, [_]);
        return {
          showInsertImageModal: _.useCallback(() => {
            _({
              type: "image",
              attrs: {
                src: "",
              },
            });
          }, []),
          showInsertVideoModal: _.useCallback(() => {
            _({
              type: "video",
              attrs: {
                mp4: "",
                webm: "",
                poster: "",
                autoplay: !0,
                controls: !1,
              },
            });
          }, []),
          closeImageModal: _,
          imageModal:
            _ &&
            _.createElement(_, {
              nodeAttrs: _,
              hideModal: _,
              onItemSelected: _,
              imageNodeType: __webpack_require__,
              videoNodeType: _,
              clanSteamID: _,
            }),
          activeModal: null == _ ? void 0 : _.type,
        };
      }
      function _(_) {
        const {
            bIsEdit: _ = !1,
            nodeAttrs: __webpack_require__,
            hideModal: _,
            clanSteamID: _,
            onItemSelected: _,
            imageNodeType: _,
            videoNodeType: _,
          } = _,
          { type: _, attrs: _ } = __webpack_require__,
          _ = (function (_, _) {
            return _.useMemo(() => _(_, _), [_, _.type, _.attrs]);
          })(_, __webpack_require__),
          [_, _] = _.useState(() =>
            _ ||
            ("image" == __webpack_require__.type &&
              !__webpack_require__.attrs.src) ||
            ("video" == __webpack_require__.type &&
              !__webpack_require__.attrs.mp4 &&
              !__webpack_require__.attrs.webm)
              ? "uploaded"
              : "hotlink",
          ),
          _ = _.useCallback(
            (_) => {
              _(
                {
                  src: _,
                },
                _,
              ),
                _();
            },
            [_, _, _],
          ),
          _ = _.useCallback(
            (_) => {
              _(
                {
                  ..._,
                  ..._,
                },
                _,
              ),
                _();
            },
            [_, _, _, _],
          ),
          _ = _.useId();
        let _,
          _ = null;
        if ("image" == _)
          (_ = _.createElement(_, {
            active: "hotlink" == _,
            bIsEdit: _,
            hideModal: _,
            onImageSelected: _,
            src: _.src,
          })),
            (_ = _
              ? (0, _._)("#EventEditor_ReplaceImage_Title")
              : (0, _._)("#EventEditor_InsertImage_Title"));
        else {
          if ("video" != _) return (0, _._)(_, "Unhandled type"), null;
          (_ = _.createElement(_, {
            active: "hotlink" == _,
            bIsEdit: _,
            hideModal: _,
            attrs: _,
            setAttrs: _,
          })),
            (_ = (0, _._)("#EventEditor_EditVideo_Title"));
        }
        return _.createElement(
          _._,
          {
            active: !0,
            onDismiss: _,
            className: _.ClanImageModalContent,
          },
          _.createElement(
            _._,
            {
              _: _,
            },
            _,
          ),
          _.createElement(
            _._,
            {
              labelId: _,
              value: _,
              onChange: (_) => _(_),
            },
            _.createElement(
              _._,
              {
                value: "uploaded",
              },
              "Uploaded",
            ),
            _.createElement(
              _._,
              {
                value: "hotlink",
              },
              "Enter URL",
            ),
          ),
          _.createElement(
            "div",
            {
              className: _()(_.ClanImageModalMode, "uploaded" == _ && _.Active),
            },
            _.createElement(_, {
              bIsEdit: _,
              hideModal: _,
              onImageSelected: _,
              onVideoSelected: _ && _,
              clanSteamID: _,
              selectedImage: _,
            }),
          ),
          _.createElement(
            "div",
            {
              className: _()(_.ClanImageModalMode, "hotlink" == _ && _.Active),
            },
            _,
          ),
        );
      }
      function _(_) {
        const {
            active: _,
            bIsEdit: __webpack_require__,
            hideModal: _,
            onImageSelected: _,
            src: _,
          } = _,
          [_, _] = _.useState(_),
          _ = _.useCallback((_) => _(_.currentTarget.value), []),
          _ = __webpack_require__
            ? (0, _._)("#EventEditor_ReplaceImage_Title")
            : (0, _._)("#EventEditor_InsertImage_Title"),
          _ = _.useRef(void 0);
        return (
          _.useEffect(() => {
            _ && _.current.Focus();
          }, [_]),
          _.createElement(
            _._,
            {
              onSubmit: () => _(_),
            },
            _.createElement(
              _._,
              null,
              _.createElement(_._, {
                ref: _,
                value: _,
                onChange: _,
                label: (0, _._)("#EventEditor_InsertImage_URL"),
              }),
            ),
            _.createElement(_._, {
              onCancel: _,
              strOKText: _,
              bOKDisabled: !_ || _ == _,
            }),
          )
        );
      }
      function _(_) {
        const {
            active: _,
            bIsEdit: __webpack_require__,
            hideModal: _,
            attrs: _,
            setAttrs: _,
          } = _,
          [_, _] = _.useState(_.mp4),
          [_, _] = _.useState(_.webm),
          [_, _] = _.useState(_.poster),
          [_, _] = _.useState(!!_.autoplay),
          [_, _] = _.useState(!!_.controls),
          _ = _.useRef(void 0);
        _.useEffect(() => {
          _ && _.current.Focus();
        }, [_]);
        return _.createElement(
          _._,
          {
            onSubmit: (_) => {
              _({
                ..._,
                mp4: _ || void 0,
                webm: _ || void 0,
                poster: _ || void 0,
                autoplay: _,
                controls: _,
              }),
                _();
            },
          },
          _.createElement(
            _._,
            null,
            _.createElement(_._, {
              ref: _,
              value: _,
              onChange: (_) => _(_.currentTarget.value),
              label: (0, _._)("#EventEditor_InsertVideo_InputMP4"),
            }),
            _.createElement(_._, {
              value: _,
              onChange: (_) => _(_.currentTarget.value),
              label: (0, _._)("#EventEditor_InsertVideo_InputWebM"),
            }),
            _.createElement(_._, {
              value: _,
              onChange: (_) => _(_.currentTarget.value),
              label: (0, _._)("#EventEditor_InsertVideo_InputPoster"),
            }),
            _.createElement(_._, {
              checked: _,
              onChange: _,
              label: (0, _._)("#EventEditor_InsertVideo_InputAutoplay"),
            }),
            _.createElement(_._, {
              checked: _,
              onChange: _,
              label: (0, _._)("#EventEditor_InsertVideo_InputShowControls"),
            }),
          ),
          _.createElement(_._, {
            onCancel: _,
            strOKText: (0, _._)("#EventEditor_EditVideo_Title"),
            bOKDisabled: !_ && !_,
          }),
        );
      }
      function _(_) {
        const {
            bIsEdit: _,
            hideModal: __webpack_require__,
            onImageSelected: _,
            onVideoSelected: _,
            clanSteamID: _,
          } = _,
          [_, _] = _.useState(""),
          [_, _] = _.useState(_.selectedImage),
          _ = _
            ? (0, _._)("#EventEditor_ReplaceImage_Title")
            : (0, _._)("#EventEditor_InsertImage_Title"),
          _ = _.useCallback(
            (_) => {
              switch (_.file_type) {
                case 4:
                  _ &&
                    _({
                      mp4: (0, _._)(_),
                    });
                  break;
                case 5:
                  _ &&
                    _({
                      webm: (0, _._)(_),
                    });
                  break;
                default:
                  _((0, _._)(_));
              }
            },
            [_, _],
          ),
          _ = _.useCallback(
            (_, _) => {
              _(_), _ && _(_);
            },
            [_],
          );
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(
            _._,
            {
              onSubmit: () => _ && _(_),
              className: _.ClanImageGridForm,
            },
            _.createElement(_._, {
              fnSetImageSearch: _,
            }),
            _.createElement(
              "div",
              {
                className: _.ClanImageGridContainer,
              },
              _.createElement(_._, {
                clanAccountID: _.GetAccountID(),
                fileNameSearch: _,
                onImageSelected: _,
                selectedItem: _,
              }),
            ),
            _.createElement(
              _._,
              null,
              _.createElement(_._, {
                onCancel: __webpack_require__,
                strOKText: _,
                bOKDisabled: !_ || _ == _.selectedImage,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const {
            editModel: _,
            imageNode: __webpack_require__,
            videoNode: _,
            children: _,
          } = _,
          _ = _.useCallback(
            async (_) => {
              const _ = _.GetClanSteamID(),
                _ = new _._(_, null);
              if (!(await _.AddImage(_, _.GetCurEditLanguage())))
                throw "Error processing image upload";
              const _ = await _.UploadAllImages();
              if (!_ || 1 != Object.values(_).length)
                throw "Error uploading image";
              const _ = Object.values(_)[0];
              if (!_.bSuccess || 1 != _.uploadResult.success)
                throw _.uploadResult.message;
              const _ = _(
                _._.GetClanImageByImageHash(_, _.uploadResult.image_hash),
                __webpack_require__,
                _,
              );
              return (
                _.type == __webpack_require__ &&
                  (await (0, _._)(
                    _._.ReplacementTokenToClanImageURL(_.attrs.src),
                  )),
                _
              );
            },
            [_, __webpack_require__, _],
          );
        return __webpack_require__
          ? _.createElement(
              _._,
              {
                ProcessFileUpload: _,
                bAllowImageHotLinking: !0,
              },
              _,
            )
          : _;
      }
      function _(_, _, _) {
        const _ = (0, _._)(_);
        switch (_.file_type) {
          case 4:
            if (!_) throw "Video unsupported";
            return __webpack_require__.create({
              mp4: _,
            });
          case 5:
            if (!_) throw "Video unsupported";
            return __webpack_require__.create({
              webm: _,
            });
          default:
            return _.create({
              src: _,
            });
        }
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const {
            videoID: _,
            align: __webpack_require__,
            editModel: _,
            selected: _,
            setAttrs: _,
            focusView: _,
          } = _,
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _();
          }, [_, _]),
          _ = _.useCallback(
            (_, _) => {
              _({
                videoID: _,
                align: _,
              }),
                _();
            },
            [_, _],
          );
        return _.createElement(
          _.Fragment,
          null,
          _ &&
            _.createElement(_, {
              videoID: _,
              align: __webpack_require__,
              bEditing: !0,
              hideModal: _,
              onSave: _,
            }),
          _.createElement(
            _,
            {
              className: (0, _._)(_.PreviewYoutubeEditor, _ && _.Selected),
            },
            _.createElement(_, {
              onEditClick: _,
              onDeleteClick: _.removeNode,
              bStrongShadows: !0,
            }),
            _ &&
              _.createElement("div", {
                className: _.SelectionOverlay,
              }),
            _.createElement(_._, {
              event: _.GetEventModel(),
              strTag: "previewyoutube",
              args: {
                "": `${_};${__webpack_require__}`,
              },
              rawargs: `${_};${__webpack_require__}`,
              showErrorInfo: !0,
            }),
          ),
        );
      }
      function _(_) {
        const {
            videoID: _ = "",
            align: __webpack_require__ = "",
            bEditing: _ = !1,
            hideModal: _,
            onSave: _,
          } = _,
          [_, _] = _.useState(__webpack_require__ || _._.full),
          [_, _] = _.useState(_ ? `https://www.youtube.com/watch?v=${_}` : ""),
          [_, _] = _.useState(void 0),
          _ = _.useCallback(() => {
            const { strVideoID: _ } = (0, _._)(_);
            return (
              _ ? _(_, _) : _((0, _._)("#EventEditor_InsertYouTube_NoURL")), !1
            );
          }, [_, _, _]),
          _ = _.useCallback((_) => {
            _ && (_.element.focus(), _.element.select());
          }, []);
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)("#EventEditor_InsertYouTube"),
              closeModal: _,
              strOKText: _
                ? (0, _._)("#Button_Save")
                : (0, _._)("#EventEditor_InsertYouTube"),
              onOK: _,
            },
            _ &&
              _.createElement(
                "div",
                {
                  className: _.Error,
                },
                _,
              ),
            _.createElement(_._, {
              label: (0, _._)("#EventEditor_InsertYouTube_URL"),
              placeholder: (0, _._)("#EventEditor_InsertYouTube_Placholder"),
              value: _,
              ref: _,
              onChange: (_) => _(_.currentTarget.value),
            }),
            _.createElement(
              _._,
              {
                label: (0, _._)("#EventEditor_InsertYouTube_Position"),
              },
              _.createElement(_._, {
                checked: _ == _._.left,
                onChange: (_) => _ && _(_._.left),
                label: (0, _._)("#EventEditor_InsertYouTube_Left"),
              }),
              _.createElement(_._, {
                checked: _ == _._.right,
                onChange: (_) => _ && _(_._.right),
                label: (0, _._)("#EventEditor_InsertYouTube_Right"),
              }),
              _.createElement(_._, {
                checked: _ == _._.full,
                onChange: (_) => _ && _(_._.full),
                label: (0, _._)("#EventEditor_InsertYouTube_Full"),
              }),
            ),
          ),
        );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const { hideModal: _, fnUpdateSession: __webpack_require__ } = _,
          [_, _] = (0, _.useState)(() => _(!0, null)),
          [_, _] = (0, _.useState)(() => _(!0, null)),
          [_] = (0, _._)(() => [_.location_type]);
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)("#MeetSteam_create_title"),
              onOK: () => __webpack_require__(_, _),
              closeModal: () => {
                _(_(!0, null)), _(_(!0, null)), _();
              },
              bOKDisabled: null == !_,
            },
            _.createElement(
              "div",
              {
                className: _().DialogCtn,
              },
              _.createElement(_, {
                group: _,
                fnSetGroup: _,
              }),
              _.createElement(_, {
                session: _,
                fnSetSession: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const {
            hideModal: _,
            groupInput: __webpack_require__,
            fnUpdateGroupSession: _,
          } = _,
          [_, _] = (0, _.useState)(() => _(!1, __webpack_require__));
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)("#MeetSteam_edit_title"),
              onOK: () => {
                _(_), _();
              },
              onCancel: () => {
                _(_(!1, __webpack_require__)), _();
              },
            },
            _.createElement(
              "div",
              {
                className: _().DialogCtn,
              },
              _.createElement(_, {
                group: _,
                fnSetGroup: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const {
            bCreate: _,
            hideModal: __webpack_require__,
            sessionInput: _,
            fnUpdateSession: _,
          } = _,
          [_, _] = (0, _.useState)(() => _(_, _)),
          [_] = (0, _._)(() => [_.location_type]);
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)(
                _ ? "#MeetSteam_create_title" : "#MeetSteam_edit_title",
              ),
              onOK: () => {
                _(_), __webpack_require__();
              },
              onCancel: () => {
                _(_(_, _)), __webpack_require__();
              },
              bOKDisabled: !_,
            },
            _.createElement(
              "div",
              {
                className: _().DialogCtn,
              },
              _.createElement(_, {
                session: _,
                fnSetSession: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const { group: _, fnSetGroup: __webpack_require__ } = _,
          _ = (0, _._)();
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(_._, {
            type: "text",
            label: (0, _._)("#MeetSteam_edit_session_name"),
            value: _._.Get(_.localized_session_title, _),
            onChange: (_) => {
              const _ = {
                ..._,
              };
              (_.localized_session_title = _._.Set(
                _.localized_session_title,
                _,
                _.currentTarget.value,
              )),
                __webpack_require__(_);
            },
          }),
          _.createElement(_._, null, (0, _._)("#MeetSteam_edit_session_desc")),
          _.createElement("textarea", {
            className: (0, _._)(
              "DialogTextInputBase",
              _().EventDescriptionField,
            ),
            value: _._.Get(_.localized_session_description, _),
            rows: 5,
            onChange: (_) => {
              const _ = {
                ..._,
              };
              (_.localized_session_description = _._.Set(
                _.localized_session_description,
                _,
                _.currentTarget.value,
              )),
                __webpack_require__(_);
            },
          }),
          _.createElement(_._, {
            type: "text",
            label: "Intended Audience",
            tooltip:
              "A short descriptions for whom then event is designed for to help partners self select",
            value: _._.Get(_.localized_intended_audience, _),
            onChange: (_) => {
              const _ = {
                ..._,
              };
              (_.localized_intended_audience = _._.Set(
                _.localized_intended_audience,
                _,
                _.currentTarget.value,
              )),
                __webpack_require__(_);
            },
          }),
          _.createElement(
            _._,
            null,
            "FAQ ",
            _.createElement(_._, {
              tooltip:
                "Optional FAQ section which appears in the pop-up display and hidden by default",
            }),
          ),
          _.createElement("textarea", {
            className: (0, _._)(
              "DialogTextInputBase",
              _().EventDescriptionField,
            ),
            value: _._.Get(_.localized_sesssion_faq, _),
            rows: 5,
            onChange: (_) => {
              const _ = {
                ..._,
              };
              (_.localized_sesssion_faq = _._.Set(
                _.localized_sesssion_faq,
                _,
                _.currentTarget.value,
              )),
                __webpack_require__(_);
            },
          }),
          _.createElement(_._, {
            checked: _.ask_registration_question,
            onChange: (_) => {
              const _ = {
                ..._,
              };
              (_.ask_registration_question = _), __webpack_require__(_);
            },
            label:
              "Ask partner to tell us what they want to learn from the sessions",
          }),
          _.createElement(_, {
            ..._,
          }),
        );
      }
      function _(_) {
        var _;
        const { group: __webpack_require__, fnSetGroup: _ } = _,
          [_, _] = (0, _.useState)(
            (null === (_ = __webpack_require__.group_visibility_tokens) ||
            void 0 === _
              ? void 0
              : _.length) > 0,
          );
        return _
          ? _.createElement(
              _.Fragment,
              null,
              _.createElement(
                "div",
                null,
                "By default, all sessions are visibility to any partner wiht a list. We can limit visibility to users by adding tokens below. Multiple Meet Steam sections can be visible together if they share the same token. To make the tokens appears most friendly, we are limiting them to exactly 5 digits. Only one token can be set on the URL.",
              ),
              __webpack_require__.group_visibility_tokens.map((_, _) =>
                _.createElement(_._, {
                  key: "token" + _ + "_" + _,
                  type: "number",
                  min: "10000",
                  max: "99999",
                  value: _ || 1e4,
                  onChange: (_) => {
                    const _ = {
                      ...__webpack_require__,
                    };
                    (_.group_visibility_tokens[_] = Number.parseInt(
                      _.currentTarget.value,
                    )),
                      _(_);
                  },
                  label: "Visibility Token",
                }),
              ),
              _.createElement(
                _._,
                {
                  onClick: () => {
                    const _ = {
                      ...__webpack_require__,
                    };
                    (_.group_visibility_tokens = [
                      ..._.group_visibility_tokens,
                      1e4,
                    ]),
                      _(_);
                  },
                },
                "Add Token",
              ),
              Boolean(__webpack_require__.group_visibility_tokens.length > 0) &&
                _.createElement(
                  _._,
                  {
                    onClick: () => {
                      const _ = {
                        ...__webpack_require__,
                      };
                      (_.group_visibility_tokens =
                        _.group_visibility_tokens.slice(0, -1)),
                        _(_);
                    },
                  },
                  "Remove Last Token",
                ),
            )
          : _.createElement(_._, {
              checked: !1,
              onChange: _,
              label: "Change Visibility Options",
            });
      }
      function _(_) {
        const { session: _, fnSetSession: __webpack_require__ } = _,
          [_, _, _, _, _, _] = (0, _._)(() => [
            _.rtime_start,
            _.rtime_end,
            _.max_capacity,
            _.max_per_team,
            _.location_type,
            _.in_person_time_zone,
          ]),
          _ = [];
        for (let _ = 0; _ < 4; ++_)
          _.push({
            data: _,
            label: _,
          });
        const _ = Math.max(0, Math.floor((_ - _) / 60)),
          _ = Intl.DateTimeFormat().resolvedOptions().timeZone,
          _ = "in_person" === _ ? (null != _ ? _ : _._) : _;
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(_, {
            startTime: _.rtime_start,
            location_type: _,
            fnUpdateLocationAndTZ: (_, _) =>
              __webpack_require__({
                ..._,
                location_type: _,
                in_person_time_zone: _,
              }),
            in_person_time_zone: _,
          }),
          _.createElement("br", null),
          _.createElement(_._, {
            strDescription: (0, _._)("#MeetSteam_edit_start"),
            nEarliestTime: 0,
            fnGetTimeToUpdate: () => _,
            fnSetTimeToUpdate: (_) =>
              __webpack_require__({
                ..._,
                rtime_start: _,
                rtime_end: _ + _._.PerMinute * _,
              }),
            fnIsValidDateTime: () => !0,
            bShowTimeZone: !0,
          }),
          _.createElement("br", null),
          _.createElement(_._, {
            type: "number",
            min: 0,
            label: (0, _._)("#MeetSteam_edit_duration"),
            onChange: (_) => {
              const _ = Number.parseInt(_.currentTarget.value);
              __webpack_require__({
                ..._,
                rtime_end: _.rtime_start + _._.PerMinute * _,
              });
            },
            value: _,
          }),
          _.createElement(_, {
            rtime_start: _,
            rtime_end: _,
            sDisplayTimeZone: _,
          }),
          _.createElement("br", null),
          _.createElement("br", null),
          _.createElement(
            "div",
            {
              className: _().ParticipantRow,
            },
            _.createElement(_._, {
              type: "number",
              value: _,
              label: (0, _._)("#MeetSteam_edit_max_capacity"),
              min: 1,
              onChange: (_) =>
                __webpack_require__({
                  ..._,
                  max_capacity: Number.parseInt(_.currentTarget.value),
                }),
            }),
            _.createElement(_._, {
              controlled: !0,
              label: (0, _._)("#MeetSteam_edit_guest_count"),
              tooltip: (0, _._)("#MeetSteam_edit_guest_count_ttip"),
              rgOptions: _,
              selectedOption: _,
              onChange: (_) =>
                __webpack_require__({
                  ..._,
                  max_per_team: _.data,
                }),
            }),
          ),
        );
      }
      function _(_) {
        const {
            rtime_start: _,
            rtime_end: __webpack_require__,
            sDisplayTimeZone: _,
          } = _,
          _ = _.unix(_)._(_._),
          _ = _.unix(_)._(_),
          _ = _.utcOffset() - _.utcOffset(),
          _ = _.unix(__webpack_require__)._(_._),
          _ = _.unix(__webpack_require__)._(_),
          _ = _.utcOffset() - _.utcOffset();
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(
            "div",
            null,
            (0, _._)("#MeetSteam_edit_displayed_start"),
            ": ",
            (0, _._)(_.unix() + 60 * _, !1, _.format("z")),
            " ",
          ),
          _.createElement(
            "div",
            null,
            (0, _._)("#MeetSteam_edit_displayed_end"),
            ": ",
            (0, _._)(_.unix() + 60 * _, !1, _.format("z")),
            " ",
          ),
        );
      }
      function _(_) {
        const {
            startTime: _,
            location_type: __webpack_require__,
            fnUpdateLocationAndTZ: _,
            in_person_time_zone: _,
          } = _,
          _ = (function (_) {
            const _ = (0, _._)({
              queryKey: ["timezone", _],
              queryFn: async () => {
                const _ = `${_._.COMMUNITY_BASE_URL}/eventadmin/ajaxgettimezones`,
                  _ = {
                    reference_time: _,
                  },
                  _ = await _().get(_, {
                    params: _,
                  });
                return null == _ ? void 0 : _.data.timezones;
              },
            });
            return _.isSuccess ? _.data : [];
          })(_),
          _ = _.useMemo(
            () => _.reduce((_, _) => _.set(_.name, _.friendly_name), new Map()),
            [_],
          ),
          _ = (_) => {
            var _;
            return null !== (_ = _.get(_)) && void 0 !== _ ? _ : _;
          },
          _ = _.useId(),
          _ = _.useId();
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(
            "div",
            {
              _: _,
              className: _.EventEditorTextTitle,
            },
            (0, _._)("#MeetSteam_edit_date_display_title"),
          ),
          _.createElement(
            "div",
            {
              _: _,
              className: _.EventEditorTextSubTitle,
            },
            (0, _._)("#MeetSteam_edit_date_display_desc"),
          ),
          _.createElement(
            _._,
            {
              labelId: _,
              descriptionId: _,
              value: __webpack_require__,
              onChange: (_) => _(_, _),
            },
            _.createElement(
              _._,
              {
                value: "in_person",
              },
              (0, _._)("#MeetSteam_edit_date_display_in_person"),
            ),
            _.createElement(
              _._,
              {
                value: "virtual",
              },
              (0, _._)("#MeetSteam_edit_date_display_virtual"),
            ),
          ),
          "in_person" === __webpack_require__ &&
            _.createElement(_._, {
              styles: {
                option: (_) => ({
                  ..._,
                  color: "#444444",
                }),
              },
              isSearchable: !0,
              isMulti: !1,
              options: _.map((_) => ({
                label: _.friendly_name,
                value: _.name,
              })),
              defaultMenuIsOpen: !1,
              value: _
                ? {
                    label: _(_),
                    value: _,
                  }
                : {
                    label: _(_._),
                    value: _._,
                  },
              onChange: (_) => _(__webpack_require__, _.value),
            }),
        );
      }
      function _(_, _) {
        if (_) {
          const _ =
            _._.GetEditModel().GetEventModel().jsondata.meet_steam_groups;
          let _ = 0;
          do {
            _ = Math.floor(1e4 + 9e4 * Math.random());
          } while (_ && _.findIndex((_) => _.group_id == _) >= 0);
          return {
            group_id: _,
            localized_session_title: (0, _._)([], 31, null),
            localized_session_description: (0, _._)([], 31, null),
            localized_sesssion_faq: (0, _._)([], 31, null),
            localized_intended_audience: (0, _._)([], 31, null),
            group_visibility_tokens: [],
            ask_registration_question: !1,
            sessions: [],
          };
        }
        return _
          ? {
              ..._,
              localized_session_description: [
                ..._.localized_session_description,
              ],
              localized_session_title: [..._.localized_session_title],
              localized_sesssion_faq: [...(_.localized_sesssion_faq || [])],
              localized_intended_audience: [
                ...(_.localized_intended_audience || []),
              ],
              group_visibility_tokens: [...(_.group_visibility_tokens || [])],
              ask_registration_question: _.ask_registration_question,
            }
          : ((0, _._)(
              !1,
              "HelperCreateOrCloneGroupSessionModel Expect Create or previous model",
            ),
            null);
      }
      function _(_, _) {
        if (_) {
          const _ = _._.GetTimeNowWithOverride(),
            _ = _._.GetEditModel().GetEventModel().jsondata.meet_steam_groups,
            _ =
              null == _ ? void 0 : _.reduce((_, _) => _.concat(_.sessions), []);
          let _ = 0;
          do {
            _ = Math.floor(1e4 + 9e4 * Math.random());
          } while (_ && __webpack_require__.findIndex((_) => _._ == _) >= 0);
          const _ = 3600 * Math.ceil(_ / 3600);
          return {
            _: _,
            rtime_start: _ + _._.PerDay,
            rtime_end: _ + _._.PerDay + _._.PerHour,
            max_capacity: 100,
            max_per_team: 3,
          };
        }
        return _
          ? {
              ..._,
            }
          : ((0, _._)(
              !1,
              "HelperCreateOrCloneSessionInstanceModel Expect Create or previous model",
            ),
            null);
      }
      function _(_) {
        const _ = _._.GetEditModel();
        for (
          let _ = 0;
          _ < _.GetEventModel().jsondata.meet_steam_groups.length;
          ++_
        ) {
          const _ = _.GetEventModel().jsondata.meet_steam_groups[_];
          for (let _ = 0; _ < _.sessions.length; ++_)
            if (_.sessions[_]._ == _)
              return {
                groupIndex: _,
                sessionIndex: _,
              };
        }
        return null;
      }
      function _(_) {
        const _ = _._.GetEditModel();
        for (
          let _ = 0;
          _ < _.GetEventModel().jsondata.meet_steam_groups.length;
          ++_
        ) {
          const _ = _.GetEventModel().jsondata.meet_steam_groups[_];
          if (_.group_id == _)
            return {
              group: _,
              groupIndex: _,
            };
        }
        return null;
      }
      function _(_) {
        const _ = _._.GetEditModel();
        for (
          let _ = 0;
          _ < _.GetEventModel().jsondata.meet_steam_schedules.length;
          ++_
        ) {
          const _ = _.GetEventModel().jsondata.meet_steam_schedules[_];
          if (_.schedule_id == _)
            return {
              schedule: _,
              scheduleIndex: _,
            };
        }
        return (
          "dev" == _._.WEB_UNIVERSE &&
            console.log(`Error: HelperFindMeetSteamSchedule ${_} is missing`),
          null
        );
      }
      var _ = __webpack_require__("chunkid");
      function _(_) {
        var _;
        const {
            focusView: __webpack_require__,
            removeNode: _,
            group_id: _,
          } = _,
          _ = (0, _._)(),
          _ = (0, _._)(() => {
            var _;
            return null ===
              (_ = _.GetEventModel().jsondata.meet_steam_groups) || void 0 === _
              ? void 0
              : _.find((_) => _.group_id == _);
          }),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            __webpack_require__(), _();
          }, [__webpack_require__, _]),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            __webpack_require__(), _();
          }, [__webpack_require__, _]);
        return _ && _.GetClanAccountID() == (0, _._)()
          ? _.createElement(
              "div",
              {
                className: _().EditorCtn,
              },
              _.createElement(_, {
                groupData: _,
                focusView: __webpack_require__,
              }),
              _.createElement(
                "div",
                {
                  className: _().controls,
                },
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Edit"),
                  },
                  _.createElement(_.ffu, null),
                ),
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Delete"),
                  },
                  _.createElement(_.sED, null),
                ),
                Boolean(
                  (null === (_ = _.group_visibility_tokens) || void 0 === _
                    ? void 0
                    : _.length) > 0,
                ) &&
                  _.createElement(
                    _._,
                    {
                      onClick: () => {},
                      tooltip:
                        "Limited visibility to those with the appropriate URLs",
                    },
                    _.createElement(_.WLA, null),
                  ),
                Boolean(_.ask_registration_question) &&
                  _.createElement(
                    _._,
                    {
                      onClick: () => {},
                      tooltip:
                        "Will ask partner to provides questions for us for this session.",
                    },
                    _.createElement(_.vfN, null),
                  ),
              ),
              Boolean(_) &&
                _.createElement(_, {
                  hideModal: _,
                  groupInput: _,
                  fnUpdateGroupSession: (_) => {
                    const { groupIndex: _ } = _(_.group_id),
                      _ = _._.GetEditModel();
                    (__webpack_require__.GetEventModel().jsondata.meet_steam_groups[
                      _
                    ] = _),
                      __webpack_require__.SetDirty(_._.description);
                  },
                }),
              Boolean(_) &&
                _.createElement(
                  _._,
                  {
                    active: !0,
                  },
                  _.createElement(_._, {
                    strTitle: (0, _._)("#Button_Delete"),
                    strDescription: (0, _._)("#Dialog_AreYouSure"),
                    onOK: () => {
                      const { groupIndex: _ } = _(_.group_id),
                        _ = _._.GetEditModel(),
                        _ = [..._.GetEventModel().jsondata.meet_steam_groups];
                      __webpack_require__.splice(_, 1),
                        (_.GetEventModel().jsondata.meet_steam_groups = _),
                        _.SetDirty(_._.description),
                        _();
                    },
                    closeModal: _,
                  }),
                ),
            )
          : _.createElement(
              "div",
              null,
              "Error: Cannot edit meet steam session group",
            );
      }
      function _(_) {
        const { groupData: _, focusView: __webpack_require__ } = _,
          _ = (0, _._)(() => _.sessions || []),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            __webpack_require__(), _();
          }, [__webpack_require__, _]);
        return _
          ? _.createElement(
              _._,
              {
                groupData: _,
              },
              _.map((_, _) =>
                _.createElement(_, {
                  key: "timecol_" + _.group_id + "_" + _._,
                  focusView: __webpack_require__,
                  sessionID: _._,
                  bShowOR: _ + 1 < _.length,
                }),
              ),
              _.createElement(
                _._,
                {
                  className: _().AddNew,
                  onClick: _,
                  tooltip: (0, _._)("#MeetSteam_add"),
                },
                _.createElement(_.OMN, null),
              ),
              _ &&
                _.createElement(_, {
                  bCreate: !0,
                  hideModal: _,
                  fnUpdateSession: (_) => {
                    const _ = _._.GetEditModel(),
                      _ = [..._.sessions, _];
                    _.sort((_, _) => _.rtime_start - _.rtime_start),
                      (_.sessions = _),
                      __webpack_require__.SetDirty(_._.description);
                  },
                }),
            )
          : null;
      }
      function _(_) {
        const { sessionID: _, bShowOR: __webpack_require__, focusView: _ } = _,
          [_, _] = (0, _._)(),
          _ = (0, _._)(() => {
            const { groupIndex: _, sessionIndex: __webpack_require__ } = _(_);
            return _._.GetEditModel().GetEventModel().jsondata
              .meet_steam_groups[_].sessions[__webpack_require__];
          }),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _();
          }, [_, _]),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _();
          }, [_, _]);
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(
            "div",
            {
              className: _().Column,
              ..._,
            },
            _.createElement(_._, {
              sessionData: _,
            }),
            Boolean(_) &&
              _.createElement(
                "div",
                {
                  className: _().controls,
                },
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Edit"),
                  },
                  _.createElement(_.ffu, null),
                ),
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Delete"),
                  },
                  _.createElement(_.sED, null),
                ),
              ),
            Boolean(_) &&
              _.createElement(_, {
                bCreate: !1,
                hideModal: _,
                sessionInput: _,
                fnUpdateSession: (_) => {
                  const _ = _._.GetEditModel(),
                    { groupIndex: _, sessionIndex: _ } = _(_),
                    _ = [
                      ...__webpack_require__.GetEventModel().jsondata
                        .meet_steam_groups[_].sessions,
                    ];
                  (_[_] = _),
                    _.sort((_, _) => _.rtime_start - _.rtime_start),
                    (__webpack_require__.GetEventModel().jsondata.meet_steam_groups[
                      _
                    ].sessions = _),
                    __webpack_require__.SetDirty(_._.description);
                },
              }),
            Boolean(_) &&
              _.createElement(
                _._,
                {
                  active: !0,
                },
                _.createElement(_._, {
                  strTitle: (0, _._)("#Button_Delete"),
                  strDescription: (0, _._)("#Dialog_AreYouSure"),
                  onOK: () => {
                    const _ = _._.GetEditModel(),
                      { groupIndex: __webpack_require__, sessionIndex: _ } =
                        _(_),
                      _ = [
                        ..._.GetEventModel().jsondata.meet_steam_groups[
                          __webpack_require__
                        ].sessions,
                      ];
                    _.splice(_, 1),
                      _.sort((_, _) => _.rtime_start - _.rtime_start),
                      (_.GetEventModel().jsondata.meet_steam_groups[
                        __webpack_require__
                      ].sessions = _),
                      _.SetDirty(_._.description);
                  },
                  closeModal: _,
                }),
              ),
          ),
          __webpack_require__ && _.createElement(_._, null),
        );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = (__webpack_require__("chunkid"), __webpack_require__("chunkid"));
      function _(_) {
        const { schema: _ } = _,
          {
            table: __webpack_require__,
            table_row: _,
            table_header: _,
            table_cell: _,
            paragraph: _,
          } = _.nodes,
          _ = _.useCallback(
            (_, _, _) =>
              !_._(_) &&
              (_ &&
                _(
                  _._.insert(
                    _.selection._,
                    (function (_, _, _, _, _) {
                      const _ = () =>
                          __webpack_require__.createChecked(
                            null,
                            _.createChecked(),
                          ),
                        _ = () => _.createChecked(null, _.createChecked());
                      return _.createChecked(null, [
                        _.createChecked(null, [_(), _()]),
                        _.createChecked(null, [_(), _()]),
                      ]);
                    })(__webpack_require__, _, _, _, _),
                  ),
                ),
              !0),
            [__webpack_require__, _, _, _, _],
          );
        return __webpack_require__
          ? _.createElement(
              _._,
              {
                tooltip: (0, _._)("#FormattingToolbar_Tables_InsertTable"),
                command: _,
              },
              _.createElement(_._Q2, null),
            )
          : null;
      }
      function _(_) {
        const { schema: _, className: __webpack_require__ } = _,
          { callbacks: _, view: _ } = (0, _._)(),
          [_, _] = _.useState(() => !!_.nodes.table && _._(_.state));
        return (
          (0, _._)(
            _,
            _.useCallback(
              (_) => _(!!_.nodes.table && _._(_.state)),
              [_.nodes.table],
            ),
          ),
          _.createElement(
            _._,
            {
              visible: _,
              msAnimationDuration: 100,
            },
            _.createElement(
              _._,
              {
                className: __webpack_require__,
              },
              _.createElement(_, {
                schema: _,
              }),
            ),
          )
        );
      }
      function _(_) {
        const { schema: _ } = _;
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_AddRowBefore"),
              command: _._,
            },
            _.createElement(_.BPi, null),
          ),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_AddRowAfter"),
              command: _._,
            },
            _.createElement(_.fG_, null),
          ),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_DeleteRow"),
              command: _._,
            },
            _.createElement(_.XW_, null),
          ),
          _.createElement(_._, null),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_AddColumnBefore"),
              command: _._,
            },
            _.createElement(_.l26, null),
          ),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_AddColumnAfter"),
              command: _._,
            },
            _.createElement(_.ur3, null),
          ),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_DeleteColumn"),
              command: _._,
            },
            _.createElement(_.dyV, null),
          ),
          _.createElement(_._, null),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_HeaderRow"),
              command: _._,
            },
            _.createElement(_.mLi, null),
          ),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_HeaderColumn"),
              command: _._,
            },
            _.createElement(_.sXN, null),
          ),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_HeaderCell"),
              command: _._,
            },
            _.createElement(_.Maz, null),
          ),
          _.createElement(_._, null),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_MergeCells"),
              command: _._,
            },
            _.createElement(_.rnq, null),
          ),
          _.createElement(
            _._,
            {
              tooltip: (0, _._)("#FormattingToolbar_Tables_SplitCells"),
              command: _._,
            },
            _.createElement(_.vB9, null),
          ),
          !1,
        );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_);
      function _(_, _) {
        if (_) {
          const _ =
            _._.GetEditModel().GetEventModel().jsondata.meet_steam_schedules;
          let _ = 0;
          do {
            _ = Math.floor(1e4 + 9e4 * Math.random());
          } while (_ && _.findIndex((_) => _.schedule_id == _) >= 0);
          return {
            schedule_id: _,
            session_breaks: [],
          };
        }
        return _
          ? {
              ..._,
            }
          : ((0, _._)(
              !1,
              "HelperCreateOrCloneMeetSteamSchedule Expect Create or previous model",
            ),
            null);
      }
      function _(_) {
        const {
            hideModal: _,
            fnUpdateSession: __webpack_require__,
            inputScheduleModel: _,
          } = _,
          _ = (0, _._)(),
          _ = (0, _._)(),
          [_, _] = (0, _.useState)(() => _(!Boolean(_), _)),
          [_, _, _] = (0, _._)(() => [
            _.location_type,
            _.in_person_time_zone,
            _.GetEventModel().jsondata.meet_steam_groups || [],
          ]),
          _ = (0, _.useMemo)(() => {
            const _ = _.reduce((_, _) => _.concat(_.sessions), []);
            return 0 == _.length ? _ : Math.min(..._.map((_) => _.rtime_start));
          }, [_, _]);
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: Boolean(_)
                ? "Update Meet Steam Schedule"
                : "Create Meet Steam Schedule View",
              onOK: () => __webpack_require__(_),
              closeModal: () => {
                _(_(!Boolean(_), _)), _();
              },
            },
            _.createElement(
              "div",
              {
                className: _().DialogCtn,
              },
              _.createElement(_, {
                startTime: _.GetEventStartTime(),
                location_type: _,
                in_person_time_zone: _,
                fnUpdateLocationAndTZ: (_, _) =>
                  _({
                    ..._,
                    location_type: _,
                    in_person_time_zone: _,
                  }),
              }),
              _.createElement(_, {
                inputScheduleModel: _,
                fnUpdateSession: (_) => _(_),
                rtBreakStartingTime: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const {
            fnUpdateSession: _,
            inputScheduleModel: __webpack_require__,
            rtBreakStartingTime: _,
          } = _,
          [_, _] = (0, _._)(() => [
            __webpack_require__.session_breaks || [],
            __webpack_require__.in_person_time_zone || _._,
          ]),
          _ = (0, _.useCallback)(
            (_, _) => {
              const _ = {
                ...__webpack_require__,
              };
              (_.session_breaks = _.session_breaks
                ? [..._.session_breaks]
                : []),
                _ < _.session_breaks.length
                  ? (_.session_breaks[_] = _)
                  : _.session_breaks.push(_),
                _(_);
            },
            [_, __webpack_require__],
          );
        return _.createElement(
          "div",
          null,
          _.createElement("div", null, "Scheduled Breaks"),
          _.sort((_, _) => _.rtime_start - _.rtime_start).map((_, _) =>
            _.createElement(_, {
              key: "breakedit" + _.break_id,
              sDisplayTimeZone: _,
              index: _,
              breakSession: _,
              fnOnUpdate: (_) => _(_, _),
            }),
          ),
          _.createElement(
            _._,
            {
              onClick: () => {
                var _;
                const _ = __webpack_require__.session_breaks
                  ? [...__webpack_require__.session_breaks]
                  : [];
                let _ = Math.floor(1 + 1e5 * Math.random());
                for (; _.findIndex((_) => _.break_id == _) >= 0; )
                  _ = Math.floor(1 + 1e5 * Math.random());
                _(
                  {
                    break_id: _,
                    localized_break_description: (0, _._)([], 31, null),
                    rtime_start: _,
                    rtime_end: _ + _._.PerHour,
                  },
                  (null === (_ = __webpack_require__.session_breaks) ||
                  void 0 === _
                    ? void 0
                    : _.length) || 0,
                );
              },
            },
            "+ Add Break",
          ),
        );
      }
      function _(_) {
        const {
            breakSession: _,
            fnOnUpdate: __webpack_require__,
            index: _,
            sDisplayTimeZone: _,
          } = _,
          _ = (0, _._)(),
          [_, _, _, _] = (0, _._)(() => [
            _.rtime_start,
            _.rtime_end,
            _.localized_break_description[_] || "",
            Math.max(0, Math.floor((_.rtime_end - _.rtime_start) / 60)),
          ]);
        return _.createElement(
          "div",
          null,
          _.createElement("div", null, "Break # ", _ + 1),
          _.createElement("br", null),
          _.createElement(_._, {
            strDescription: "Break Start Time",
            nEarliestTime: 0,
            fnGetTimeToUpdate: () => _,
            fnSetTimeToUpdate: (_) =>
              __webpack_require__({
                ..._,
                rtime_start: _,
                rtime_end: _ + _._.PerMinute * _,
              }),
            fnIsValidDateTime: () => !0,
            bShowTimeZone: !0,
          }),
          _.createElement("br", null),
          _.createElement(_._, {
            type: "number",
            min: 0,
            label: "Break duration in minutes",
            onChange: (_) => {
              const _ = Number.parseInt(_.currentTarget.value);
              __webpack_require__({
                ..._,
                rtime_end: _.rtime_start + _._.PerMinute * _,
              });
            },
            value: _,
          }),
          _.createElement(_._, {
            type: "text",
            label: "Break Description",
            value: _,
            onChange: (_) => {
              const _ = {
                ..._,
              };
              (_.localized_break_description[_] = _.currentTarget.value),
                __webpack_require__(_);
            },
          }),
          _.createElement(_, {
            rtime_start: _,
            rtime_end: _,
            sDisplayTimeZone: _,
          }),
        );
      }
      function _(_) {
        const {
            focusView: _,
            removeNode: __webpack_require__,
            schedule_id: _,
          } = _,
          _ = (0, _._)(),
          _ = (0, _._)(() => {
            var _;
            return null ===
              (_ = _.GetEventModel().jsondata.meet_steam_schedules) ||
              void 0 === _
              ? void 0
              : _.find((_) => _.schedule_id == _);
          }),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _();
          }, [_, _]),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _();
          }, [_, _]);
        return _ && _.GetClanAccountID() == (0, _._)()
          ? _.createElement(
              "div",
              {
                className: _().EditorCtn,
              },
              _.createElement(_._, {
                eventModel: _.GetEventModel(),
                scheduleData: _,
              }),
              _.createElement(
                "div",
                {
                  className: _().controls,
                },
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Edit"),
                  },
                  _.createElement(_.ffu, null),
                ),
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Delete"),
                  },
                  _.createElement(_.sED, null),
                ),
              ),
              Boolean(_) &&
                _.createElement(_, {
                  hideModal: _,
                  inputScheduleModel: _,
                  fnUpdateSession: (_) => {
                    const { scheduleIndex: _ } = _(_.schedule_id);
                    (_.GetEventModel().jsondata.meet_steam_schedules[_] = _),
                      _.SetDirty(_._.description);
                  },
                }),
              Boolean(_) &&
                _.createElement(
                  _._,
                  {
                    active: !0,
                  },
                  _.createElement(_._, {
                    strTitle: (0, _._)("#Button_Delete"),
                    strDescription: (0, _._)("#Dialog_AreYouSure"),
                    onOK: () => {
                      const { scheduleIndex: _ } = _(_.schedule_id),
                        _ = _._.GetEditModel(),
                        _ = [
                          ..._.GetEventModel().jsondata.meet_steam_schedules,
                        ];
                      _.splice(_, 1),
                        (_.GetEventModel().jsondata.meet_steam_schedules = _),
                        _.SetDirty(_._.description),
                        __webpack_require__();
                    },
                    closeModal: _,
                  }),
                ),
            )
          : _.createElement(
              "div",
              null,
              "Error: Cannot edit meet steam schedule view",
            );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const { schema: _ } = _,
          { callbacks: __webpack_require__, view: _ } = (0, _._)(),
          [_, _] = _.useState(!1),
          _ = _.useCallback(
            (_, _) => {
              _.dispatch(
                _.state._.insert(
                  _.state.selection._,
                  _.nodes.emoticon.create(null, _.text(_)),
                ),
              ),
                _ || _.focus();
            },
            [_, _],
          ),
          _ = _.useCallback(
            (_) => {
              _(!0);
              const _ = (0, _._)(
                _.createElement(_, {
                  OnSelected: _,
                }),
                _,
                {
                  bOverlapHorizontal: !0,
                },
              );
              (0, _._)(
                () => !_.visible,
                () => _(!1),
              );
            },
            [_],
          );
        return _.createElement(
          _._,
          {
            tooltip: "#Editor_Emoticon",
            onClick: _,
            toggled: _,
          },
          _.createElement(_.jZW, null),
        );
      }
      function _(_) {
        return (
          (0, _._)(_._),
          _.createElement(_._, {
            emoticonStore: _._,
            OnSelected: _.OnSelected,
          })
        );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const {
            hideModal: _,
            fnUpdateSession: __webpack_require__,
            clanAccountID: _,
          } = _,
          [_, _] = (0, _.useState)(() => _(!0, null));
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)("#UserPolls_Create_title"),
              onOK: () => __webpack_require__(_),
              closeModal: () => {
                _(_(!0, null)), _();
              },
            },
            _.createElement(
              "div",
              {
                className: _().DialogCtn,
              },
              _.createElement(_, {
                clanAccountID: _,
                userPollDef: _,
                fnSetDef: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const {
            hideModal: _,
            userPollDef: __webpack_require__,
            clanAccountID: _,
            fnUpdateUserPollDef: _,
          } = _,
          [_, _] = (0, _.useState)(() => _(!1, __webpack_require__));
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)("#UserPolls_Edit_title"),
              onOK: () => {
                _(_);
              },
              onCancel: () => {
                _(_(!1, __webpack_require__));
              },
              closeModal: _,
            },
            _.createElement(
              "div",
              {
                className: _().DialogCtn,
              },
              _.createElement(_, {
                userPollDef: _,
                clanAccountID: _,
                fnSetDef: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        switch (_) {
          default:
          case _._.k_EPollResult_NotVisible:
            return (0, _._)("#UserPolls_Visibility_None");
          case _._.k_EPollResult_Visible_After_End:
            return (0, _._)("#UserPolls_Visibility_End");
          case _._.k_EPollResult_Visible_After_Vote:
            return (0, _._)("#UserPolls_Visibility_Voter");
          case _._.k_EPollResult_Visible_After_Vote_Or_End:
            return (0, _._)("#UserPolls_Visibility_Voter_or_End");
          case _._.k_EPollResult_Visible_On_Demand:
            return (0, _._)("#UserPolls_Visibility_OnDemand");
        }
      }
      function _(_) {
        const { userPollDef: _, fnSetDef: __webpack_require__ } = _,
          _ = (0, _._)(),
          [_] = (0, _._)(() => [_.results_visibility_settings]),
          _ = Object.values(_._).map((_) => ({
            data: _,
            label: _(_),
          }));
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(_._, {
            type: "text",
            label: (0, _._)("#UserPolls_Description"),
            value: _._.Get(_.localized_poll_description, _),
            onChange: (_) => {
              const _ = {
                ..._,
              };
              (_.localized_poll_description = _._.Set(
                _.localized_poll_description,
                _,
                _.currentTarget.value,
              )),
                __webpack_require__(_);
            },
          }),
          _.createElement(_, {
            ..._,
          }),
          _.createElement(_, {
            ..._,
          }),
          _.createElement(_._, null, (0, _._)("#UserPolls_Visibility")),
          _.createElement(
            "div",
            {
              className: _().PollArea,
            },
            _.createElement(_._, {
              strDropDownClassName: _.DropDownScroll,
              rgOptions: _,
              selectedOption: _,
              onChange: (_) => {
                _.data != _.results_visibility_settings &&
                  __webpack_require__({
                    ..._,
                    results_visibility_settings: _.data,
                  });
              },
              bDisableMouseOverlay: !0,
              contextMenuPositionOptions: {
                bDisableMouseOverlay: !0,
              },
            }),
          ),
          _.createElement(_, {
            ..._,
          }),
        );
      }
      function _(_) {
        const {
            clanAccountID: _,
            userPollDef: __webpack_require__,
            fnSetDef: _,
          } = _,
          _ = (0, _._)(),
          _ = (0, _._)(_.GetClanSteamID()),
          [_] = (0, _._)(() => [__webpack_require__.user_poll_background]),
          _ = (0, _.useCallback)(
            (_, _, _, _, _) => {
              (0, _._)(
                null != _ && _ >= 0 && _ < 31,
                "Unexpected value for elang: " + _,
              ),
                (0, _._)(
                  "user_poll_background" === _,
                  "Unexpected artwork type " + _,
                );
              const _ = (0, _._)(_, _);
              _.image &&
                _({
                  ...__webpack_require__,
                  user_poll_background: _.image,
                });
            },
            [_, __webpack_require__],
          );
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(_._, null, (0, _._)("#UserPolls_BackgroundImage")),
          _.createElement(
            "div",
            {
              className: _().PollArea,
            },
            _.createElement(
              "p",
              null,
              (0, _._)("#UserPolls_BackgroundImage_desc"),
            ),
            _.createElement(_._, {
              rgRealmList: _.GetIncludedRealmList(),
              rgSupportArtwork: _._,
              strUploadAjaxURL: _,
              fnOnUploadSuccess: _,
              elOverrideDragAndDropText: (0, _._)(
                "#Template_Section_MediaUpdate_Static_Dnd",
              ),
              bTwoPhaseUpload: !0,
              bDirectTempStorageUpload: !0,
            }),
            Boolean(_) &&
              _.createElement("img", {
                src: (0, _._)(_, _),
              }),
          ),
        );
      }
      function _(_) {
        switch (_) {
          case _._.k_EPollVoter_AnyUser:
            return (0, _._)("#UserPolls_Voters_Anyone");
          case _._.k_EPollVoter_UserGameInLibrary:
            return (0, _._)("#UserPolls_Voters_Owners");
          case _._.k_EPollVoter_MinPlayTime:
            return (0, _._)("#UserPolls_Voters_Players");
          case _._.k_EPollVoter_MemberOfGroup:
            return (0, _._)("#UserPolls_Voters_Members");
        }
      }
      function _(_) {
        const {
            clanAccountID: _,
            userPollDef: __webpack_require__,
            fnSetDef: _,
          } = _,
          [_, _] = (0, _._)(_),
          [_, _] = (0, _._)(() => [
            __webpack_require__.voter_min_playtime_seconds,
            __webpack_require__.voter_eligibility,
          ]),
          _ = (0, _.useMemo)(() => {
            const _ = [
              {
                label: _(_._.k_EPollVoter_AnyUser),
                data: _._.k_EPollVoter_AnyUser,
              },
            ];
            return (
              _ && _.is_ogg && _ != _._
                ? (_.push({
                    label: _(_._.k_EPollVoter_UserGameInLibrary),
                    data: _._.k_EPollVoter_UserGameInLibrary,
                  }),
                  _.push({
                    label: _(_._.k_EPollVoter_MinPlayTime),
                    data: _._.k_EPollVoter_MinPlayTime,
                  }))
                : !_ ||
                  (_.is_ogg && _ != _._) ||
                  _.push({
                    label: _(_._.k_EPollVoter_MemberOfGroup),
                    data: _._.k_EPollVoter_MemberOfGroup,
                  }),
              _
            );
          }, [_, _]);
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(_._, null, (0, _._)("#UserPolls_Voters")),
          _.createElement(
            "div",
            {
              className: _().PollArea,
            },
            _.createElement(_._, {
              strDropDownClassName: _.DropDownScroll,
              rgOptions: _,
              selectedOption: _,
              onChange: (_) => {
                if (_.data != __webpack_require__.voter_eligibility) {
                  let _ = {
                    ...__webpack_require__,
                    voter_eligibility: _.data,
                  };
                  _.data == _._.k_EPollVoter_MinPlayTime &&
                    (_.voter_min_playtime_seconds = 5 * _),
                    _(_);
                }
              },
              bDisableMouseOverlay: !0,
              contextMenuPositionOptions: {
                bDisableMouseOverlay: !0,
              },
            }),
            Boolean(_ == _._.k_EPollVoter_MinPlayTime) &&
              _.createElement(
                "div",
                {
                  className: _().OptionInset,
                },
                _.createElement(_._, {
                  type: "number",
                  label: (0, _._)("#UserPolls_MinPlayTime"),
                  value: _ / _,
                  min: 5,
                  onChange: (_) => {
                    var _, _;
                    const _ =
                      (null !==
                        (_ = Number.parseInt(
                          null === (_ = null == _ ? void 0 : _.currentTarget) ||
                            void 0 === _
                            ? void 0
                            : _.value,
                        )) && void 0 !== _
                        ? _
                        : 5) * _;
                    __webpack_require__.voter_min_playtime_seconds != _ &&
                      _({
                        ...__webpack_require__,
                        voter_min_playtime_seconds: _,
                      });
                  },
                }),
              ),
          ),
        );
      }
      function _(_) {
        const { userPollDef: _, fnSetDef: __webpack_require__ } = _,
          [_, _] = (0, _._)(() => [
            _.poll_end_time,
            _.poll_end_days_since_start,
          ]);
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(_._, null, (0, _._)("#UserPolls_Starts")),
          _.createElement(
            "div",
            {
              className: _().PollArea,
            },
            _.createElement(
              "div",
              {
                className: (0, _._)(_.FlexRowContainer, _.RadioOption),
              },
              _.createElement("input", {
                type: "radio",
                name: "StartDateRadio",
                _: "UserPollDialog_Days",
                checked: Boolean(_),
                onChange: () => {
                  _.poll_end_days_since_start ||
                    __webpack_require__({
                      ..._,
                      poll_end_time: void 0,
                      poll_end_days_since_start: _ * _,
                    });
                },
              }),
              _.createElement(
                "label",
                {
                  htmlFor: "UserPollDialog_Days",
                },
                _.createElement(
                  "span",
                  null,
                  (0, _._)("#UserPolls_EndTime_In_Days"),
                ),
              ),
            ),
            Boolean(_) &&
              _.createElement(
                "div",
                {
                  className: _().OptionInset,
                },
                _.createElement(_._, {
                  type: "number",
                  value: _ / _,
                  min: 1,
                  onChange: (_) => {
                    var _, _;
                    const _ =
                      (null !==
                        (_ = Number.parseInt(
                          null === (_ = null == _ ? void 0 : _.currentTarget) ||
                            void 0 === _
                            ? void 0
                            : _.value,
                        )) && void 0 !== _
                        ? _
                        : 1) * _;
                    _.poll_end_days_since_start != _ &&
                      __webpack_require__({
                        ..._,
                        poll_end_time: void 0,
                        poll_end_days_since_start: _,
                      });
                  },
                }),
              ),
            _.createElement(
              "div",
              {
                className: (0, _._)(_.FlexRowContainer, _.RadioOption),
              },
              _.createElement("input", {
                type: "radio",
                name: "StartDateRadio",
                _: "UserPollDialog_SpecificTime",
                checked: Boolean(_),
                onChange: () => {
                  _.poll_end_time ||
                    __webpack_require__({
                      ..._,
                      poll_end_days_since_start: void 0,
                      poll_end_time: Math.floor(Date.now() / 1e3) + _ * _,
                    });
                },
              }),
              _.createElement(
                "label",
                {
                  htmlFor: "UserPollDialog_SpecificTime",
                },
                _.createElement(
                  "span",
                  null,
                  (0, _._)("#UserPolls_EndTime_Specific"),
                ),
              ),
            ),
            Boolean(_) &&
              _.createElement(
                "div",
                {
                  className: (0, _._)(_().OptionInset, _.FlexRowContainer),
                },
                _.createElement(_._, {
                  strDescription: "",
                  nEarliestTime: Math.floor(Date.now() / 1e3) + 3600,
                  fnGetTimeToUpdate: () => _,
                  fnSetTimeToUpdate: (_) => {
                    _.poll_end_time != _ &&
                      __webpack_require__({
                        ..._,
                        poll_end_days_since_start: void 0,
                        poll_end_time: _,
                      });
                  },
                  fnIsValidDateTime: () =>
                    _ > Math.floor(Date.now() / 1e3) + 3600,
                }),
                _.createElement(
                  "span",
                  null,
                  (0, _._)("#UserPolls_EndTime_Zone"),
                ),
              ),
          ),
        );
      }
      const _ = 7,
        _ = 86400,
        _ = 60;
      function _(_, _) {
        if (_) {
          const _ =
            _._.GetEditModel().GetEventModel().jsondata.user_polls || [];
          let _ = 0;
          do {
            _ = Math.floor(1e4 + 9e4 * Math.random());
          } while (_ && _.findIndex((_) => _.poll_id == _) >= 0);
          return {
            poll_id: _,
            options: [],
            localized_poll_description: (0, _._)([], 31, null),
            poll_end_days_since_start: _ * _,
            poll_end_time: void 0,
            results_visibility_settings: _._.k_EPollResult_Visible_On_Demand,
            voter_eligibility: _._.k_EPollVoter_AnyUser,
          };
        }
        return _
          ? {
              ..._,
              localized_poll_description: [..._.localized_poll_description],
            }
          : ((0, _._)(
              !1,
              "HelperCreateOrCloneUserPollModel Expect Create or previous model",
            ),
            null);
      }
      function _(_) {
        const {
            bCreate: _,
            hideModal: __webpack_require__,
            pollOptionsInput: _,
            fnUpdatePollOption: _,
          } = _,
          [_, _] = (0, _.useState)(() => _(_, _)),
          _ = (0, _._)();
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)(
                _ ? "#UserPolls_Option_Create" : "#UserPolls_Option_Edit",
              ),
              onOK: () => {
                _(_), __webpack_require__();
              },
              onCancel: () => {
                _(_(_, _)), __webpack_require__();
              },
            },
            _.createElement(
              "div",
              {
                className: _().DialogCtn,
              },
              _.createElement(_._, {
                type: "text",
                label: (0, _._)("#UserPolls_Option_Title"),
                value: _._.Get(_.localized_option, _),
                onChange: (_) => {
                  const _ = {
                    ..._,
                  };
                  (_.localized_option = [..._.localized_option]),
                    (_.localized_option = _._.Set(
                      _.localized_option,
                      _,
                      _.currentTarget.value,
                    )),
                    _(_);
                },
              }),
            ),
          ),
        );
      }
      function _(_, _) {
        if (_) {
          const _ = _._.GetEditModel().GetEventModel().jsondata.user_polls,
            _ =
              null == _ ? void 0 : _.reduce((_, _) => _.concat(_.options), []);
          let _ = 0;
          do {
            _ = Math.floor(1e4 + 9e4 * Math.random());
          } while (_ && _.findIndex((_) => _.option_id == _) >= 0);
          return {
            option_id: _,
            localized_option: (0, _._)([], 31, null),
          };
        }
        return _
          ? {
              ..._,
            }
          : ((0, _._)(
              !1,
              "HelperCreateOrClonePollOptionModel Expect Create or previous model",
            ),
            null);
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const _ = _._.GetEditModel();
        for (let _ = 0; _ < _.GetEventModel().jsondata.user_polls.length; ++_) {
          const _ = _.GetEventModel().jsondata.user_polls[_];
          for (let _ = 0; _ < _.options.length; ++_)
            if (_.options[_].option_id == _)
              return {
                pollIndex: _,
                optionIndex: _,
              };
        }
        return null;
      }
      function _(_) {
        const _ = _._.GetEditModel();
        for (let _ = 0; _ < _.GetEventModel().jsondata.user_polls.length; ++_) {
          const _ = _.GetEventModel().jsondata.user_polls[_];
          if (_.poll_id == _)
            return {
              userPollDef: _,
              pollIndex: _,
            };
        }
        return null;
      }
      var _ = __webpack_require__("chunkid");
      function _(_) {
        const { focusView: _, removeNode: __webpack_require__, poll_id: _ } = _,
          _ = (0, _._)(),
          _ = (0, _._)(() => {
            var _;
            return null === (_ = _.GetEventModel().jsondata.user_polls) ||
              void 0 === _
              ? void 0
              : _.find((_) => _.poll_id == _);
          }),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _();
          }, [_, _]),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _();
          }, [_, _]);
        return _
          ? _.createElement(
              "div",
              {
                className: _().EditorCtn,
              },
              _.createElement(_, {
                userPollDef: _,
                focusView: _,
              }),
              _.createElement(
                "div",
                {
                  className: _().controls,
                },
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Edit"),
                  },
                  _.createElement(_.ffu, null),
                ),
                _.createElement(
                  _._,
                  {
                    onClick: _,
                    tooltip: (0, _._)("#Button_Delete"),
                  },
                  _.createElement(_.sED, null),
                ),
                _.createElement(
                  _._,
                  {
                    onClick: () => {},
                    tooltip: _(_.results_visibility_settings),
                  },
                  _.createElement(_.WLA, null),
                ),
                _.createElement(
                  _._,
                  {
                    onClick: () => {},
                    tooltip: _(_.voter_eligibility),
                  },
                  _.createElement(_.JpU, null),
                ),
              ),
              Boolean(_) &&
                _.createElement(_, {
                  hideModal: _,
                  userPollDef: _,
                  clanAccountID: _.GetClanAccountID(),
                  fnUpdateUserPollDef: (_) => {
                    const { pollIndex: _ } = _(_.poll_id),
                      _ = _._.GetEditModel();
                    (__webpack_require__.GetEventModel().jsondata.user_polls[
                      _
                    ] = _),
                      __webpack_require__.SetDirty(_._.description);
                  },
                }),
              Boolean(_) &&
                _.createElement(
                  _._,
                  {
                    active: !0,
                  },
                  _.createElement(_._, {
                    strTitle: (0, _._)("#Button_Delete"),
                    strDescription: (0, _._)("#Dialog_AreYouSure"),
                    onOK: () => {
                      const { pollIndex: _ } = _(_.poll_id),
                        _ = _._.GetEditModel(),
                        _ = [..._.GetEventModel().jsondata.user_polls];
                      _.splice(_, 1),
                        (_.GetEventModel().jsondata.user_polls = _),
                        _.SetDirty(_._.description),
                        __webpack_require__();
                    },
                    closeModal: _,
                  }),
                ),
            )
          : _.createElement(
              "div",
              {
                className: _.ErrorStylesWithIcon,
              },
              (0, _._)("#UserPolls_Editor_FailToFindModel", _),
            );
      }
      function _(_) {
        const { userPollDef: _, focusView: __webpack_require__ } = _,
          [_, _] = (0, _._)(() => [_.options || [], _.randomize_option_order]),
          _ = (0, _._)(),
          _ = (0, _._)(),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            __webpack_require__(), _();
          }, [__webpack_require__, _]),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            __webpack_require__(), _();
          }, [__webpack_require__, _]);
        return _
          ? _.createElement(
              _._,
              {
                userPollDef: _,
                eventModel: _.GetEventModel(),
                lang: _,
              },
              _.map((_) =>
                _.createElement(_, {
                  key: "polloption" + _.poll_id + "_" + _.option_id,
                  focusView: __webpack_require__,
                  optionID: _.option_id,
                }),
              ),
              _.createElement(
                "div",
                {
                  className: _().AdminOptions,
                },
                _.createElement(
                  _._,
                  {
                    className: "",
                    onClick: _,
                  },
                  (0, _._)("#UserPolls_Option_Add"),
                ),
                _.createElement(
                  _._,
                  {
                    className: "",
                    onClick: _,
                  },
                  (0, _._)("#UserPolls_Option_Reorder"),
                ),
              ),
              _ &&
                _.createElement(_, {
                  bCreate: !0,
                  hideModal: _,
                  fnUpdatePollOption: (_) => {
                    const _ = _._.GetEditModel();
                    _.options || (_.options = []),
                      _.options.push(_),
                      __webpack_require__.SetDirty(_._.description);
                  },
                }),
              _ &&
                _.createElement(_, {
                  hideModal: _,
                  options: _,
                  bRandomize: _,
                  fnUpdateOptions: (_, _) => {
                    (_.randomize_option_order = _), (_.options = _);
                  },
                }),
            )
          : null;
      }
      function _(_) {
        const {
            options: _,
            bRandomize: __webpack_require__,
            fnUpdateOptions: _,
            hideModal: _,
          } = _,
          _ = (0, _._)(),
          [_, _] = (0, _.useState)(__webpack_require__),
          [_, _] = (0, _.useState)(_);
        return _.createElement(
          _._,
          {
            active: !0,
          },
          _.createElement(
            _._,
            {
              strTitle: (0, _._)("#UserPolls_Option_Reorder"),
              strDescription: (0, _._)("#UserPolls_Option_Reorder_desc"),
              onCancel: () => {
                _(__webpack_require__), _(_);
              },
              onOK: () => {
                _([..._], _);
              },
              closeModal: _,
            },
            _.createElement(_._, {
              label: (0, _._)("#UserPolls_Option_Randomize"),
              checked: _,
              onChange: _,
            }),
            _.createElement(_._, {
              items: _,
              render: (_) => {
                var _, _;
                return _.createElement(
                  "div",
                  null,
                  (null === (_ = _.localized_option) || void 0 === _
                    ? void 0
                    : _[_]) ||
                    (null === (_ = _.localized_option) || void 0 === _
                      ? void 0
                      : _[0]) ||
                    "",
                );
              },
              onReorder: (_) => _(_),
            }),
          ),
        );
      }
      function _(_) {
        const { optionID: _, focusView: __webpack_require__ } = _,
          [_, _] = (0, _._)(),
          _ = (0, _._)(() => {
            const { optionIndex: _, pollIndex: __webpack_require__ } = _(_);
            return _._.GetEditModel().GetEventModel().jsondata.user_polls[
              __webpack_require__
            ].options[_];
          }),
          _ = (0, _._)(),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            __webpack_require__(), _();
          }, [__webpack_require__, _]),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            __webpack_require__(), _();
          }, [__webpack_require__, _]);
        return _.createElement(
          "div",
          {
            className: _().Column,
            ..._,
          },
          _.createElement(_._, {
            pollOptionDef: _,
            lang: _,
          }),
          Boolean(_) &&
            _.createElement(
              "div",
              {
                className: _().controls,
              },
              _.createElement(
                _._,
                {
                  onClick: _,
                  tooltip: (0, _._)("#Button_Edit"),
                },
                _.createElement(_.ffu, null),
              ),
              _.createElement(
                _._,
                {
                  onClick: _,
                  tooltip: (0, _._)("#Button_Delete"),
                },
                _.createElement(_.sED, null),
              ),
            ),
          Boolean(_) &&
            _.createElement(_, {
              bCreate: !1,
              hideModal: _,
              pollOptionsInput: _,
              fnUpdatePollOption: (_) => {
                const _ = _._.GetEditModel(),
                  { optionIndex: _, pollIndex: _ } = _(_),
                  _ = [
                    ...__webpack_require__.GetEventModel().jsondata.user_polls[
                      _
                    ].options,
                  ];
                (_[_] = _),
                  (__webpack_require__.GetEventModel().jsondata.user_polls[
                    _
                  ].options = _),
                  __webpack_require__.SetDirty(_._.description);
              },
            }),
          Boolean(_) &&
            _.createElement(
              _._,
              {
                active: !0,
              },
              _.createElement(_._, {
                strTitle: (0, _._)("#Button_Delete"),
                strDescription: (0, _._)("#Dialog_AreYouSure"),
                onOK: () => {
                  const _ = _._.GetEditModel(),
                    { optionIndex: __webpack_require__, pollIndex: _ } = _(_),
                    _ = [..._.GetEventModel().jsondata.user_polls[_].options];
                  _.splice(__webpack_require__, 1),
                    (_.GetEventModel().jsondata.user_polls[_].options = _),
                    _.SetDirty(_._.description);
                },
                closeModal: _,
              }),
            ),
        );
      }
      const _ = _.memo(function (_) {
        const {
          view: _,
          schema: __webpack_require__,
          refUpdateToolbar: _,
          className: _,
          clanSteamID: _,
          bSpellcheckEnabled: _,
          setSpellcheckEnabled: _,
        } = _;
        return _.createElement(
          _._,
          {
            refUpdateToolbar: _,
            view: _,
          },
          _.createElement(
            "div",
            {
              className: _.className,
            },
            _.createElement(
              _._,
              {
                className: _.className,
              },
              _.createElement(_._, null),
              _.createElement(_._, null),
              _.createElement(_._, {
                schema: __webpack_require__,
              }),
              _.createElement(_._, null),
              __webpack_require__.marks.link &&
                _.createElement(_, {
                  schema: __webpack_require__,
                }),
              _.createElement(_._, null),
              _.createElement(_._, {
                schema: __webpack_require__,
              }),
              _.createElement(_._, {
                schema: __webpack_require__,
                levels: 3,
              }),
              _.createElement(_._, null),
              _.createElement(_, {
                schema: __webpack_require__,
              }),
              _.createElement(_, {
                schema: __webpack_require__,
                clanSteamID: _,
              }),
              _.createElement(_, {
                schema: __webpack_require__,
              }),
              _.createElement(_._, {
                schema: __webpack_require__,
                showIndentButtonsAsNeeded: !0,
              }),
              _.createElement(_._, null),
              _ &&
                _.createElement(_._, {
                  bSpellcheckEnabled: _,
                  setSpellcheckEnabled: _,
                }),
              __webpack_require__.nodes.meetsteamsessiongroup &&
                _.createElement(_, {
                  schema: __webpack_require__,
                }),
              __webpack_require__.nodes.meetsteamscheduleview &&
                _.createElement(_, {
                  schema: __webpack_require__,
                }),
              __webpack_require__.nodes.userpolls &&
                _._.is_support &&
                _.createElement(_, {
                  schema: __webpack_require__,
                }),
            ),
            _.createElement(_, {
              className: _.className,
              schema: __webpack_require__,
            }),
          ),
        );
      });
      function _(_) {
        const _ = (0, _._)();
        return _.createElement(_._, {
          schema: _.schema,
          addtlAttrs: _,
        });
      }
      function _(_) {
        const { schema: _ } = _,
          { callbacks: __webpack_require__, view: _ } = (0, _._)(),
          _ = (0, _._)(),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _.focus();
          }, [_, _]),
          _ = _.useCallback(
            (_) => {
              _.GetEventModel().jsondata.user_polls ||
                (_.GetEventModel().jsondata.user_polls = []),
                _.GetEventModel().jsondata.user_polls.push({
                  ..._,
                }),
                (function (_, _, _) {
                  _.dispatch(
                    _.state._.insert(
                      _.state.selection._,
                      _.create({
                        poll_id: _,
                      }),
                    ),
                  );
                })(_, _.nodes.userpolls, _.poll_id),
                _();
            },
            [_, _, _, _],
          );
        return _.createElement(
          _.Fragment,
          null,
          _ &&
            _.createElement(_, {
              hideModal: _,
              clanAccountID: _.GetClanAccountID(),
              fnUpdateSession: _,
            }),
          _.createElement(
            _._,
            {
              tooltip: "#UserPolls_Toolbar_ttip",
              onClick: _,
              toggled: _,
            },
            _.createElement(_.fQB, null),
          ),
        );
      }
      function _(_) {
        const { schema: _, clanSteamID: __webpack_require__ } = _,
          { callbacks: _, view: _ } = (0, _._)(),
          { image: _, video: _, previewyoutube: _ } = _.nodes,
          _ = _.useCallback(
            (_, _) => {
              _.dispatch(_.state._.insert(_.state.selection._, _.create(_)));
            },
            [_],
          ),
          _ = _.useCallback(() => _.focus(), [_]),
          {
            showInsertImageModal: _,
            showInsertVideoModal: _,
            imageModal: _,
            activeModal: _,
          } = _({
            clanSteamID: __webpack_require__,
            imageNodeType: _,
            videoNodeType: _,
            onItemSelected: _,
            onHideModal: _,
          });
        return _.createElement(
          _.Fragment,
          null,
          _,
          _ &&
            _.createElement(
              _._,
              {
                tooltip: "#EventEditor_InsertImage_Title",
                onClick: _,
                toggled: "image" == _,
              },
              _.createElement(_._V3, null),
            ),
          _ &&
            _.createElement(
              _._,
              {
                tooltip: "#EventEditor_EditVideo_Title",
                onClick: _,
                toggled: "video" == _,
              },
              _.createElement(_.CeX, null),
            ),
          _ &&
            _.createElement(_, {
              schema: _,
            }),
          (_ || _ || _) && _.createElement(_._, null),
        );
      }
      function _(_) {
        const { schema: _ } = _,
          { callbacks: __webpack_require__, view: _ } = (0, _._)(),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _.focus();
          }, [_, _]),
          _ = _.useCallback(
            (_, _) => {
              !(function (_, _, _, _ = _._.left) {
                _.dispatch(
                  _.state._.insert(
                    _.state.selection._,
                    _.create({
                      videoID: _,
                      align: _,
                    }),
                  ),
                );
              })(_, _.nodes.previewyoutube, _, _),
                _();
            },
            [_, _, _],
          );
        return _.createElement(
          _.Fragment,
          null,
          _ &&
            _.createElement(_, {
              hideModal: _,
              onSave: _,
            }),
          _.createElement(
            _._,
            {
              tooltip: "#EventEditor_InsertYouTube",
              onClick: _,
              toggled: _,
            },
            _.createElement("img", {
              src: _._,
            }),
          ),
        );
      }
      function _(_) {
        const { schema: _ } = _,
          { callbacks: __webpack_require__, view: _ } = (0, _._)(),
          _ = (0, _._)(),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _.focus();
          }, [_, _]),
          _ = _.useCallback(
            (_, _) => {
              _.GetEventModel().jsondata.meet_steam_groups ||
                (_.GetEventModel().jsondata.meet_steam_groups = []),
                _.GetEventModel().jsondata.meet_steam_groups.push({
                  ..._,
                  sessions: [_],
                }),
                (function (_, _, _) {
                  _.dispatch(
                    _.state._.insert(
                      _.state.selection._,
                      _.create({
                        group_id: _,
                      }),
                    ),
                  );
                })(_, _.nodes.meetsteamsessiongroup, _.group_id),
                _();
            },
            [_, _, _, _],
          );
        if ((null == _ ? void 0 : _.GetClanAccountID()) == (0, _._)())
          return _.createElement(
            _.Fragment,
            null,
            _ &&
              _.createElement(_, {
                hideModal: _,
                fnUpdateSession: _,
              }),
            _.createElement(
              _._,
              {
                tooltip: "#MeetSteam_add_group_ttip",
                onClick: _,
                toggled: _,
              },
              _.createElement("img", {
                src: _._,
              }),
            ),
          );
      }
      function _(_) {
        const { schema: _ } = _,
          { callbacks: __webpack_require__, view: _ } = (0, _._)(),
          _ = (0, _._)(),
          [_, _, _] = (0, _._)(),
          _ = _.useCallback(() => {
            _(), _.focus();
          }, [_, _]),
          _ = _.useCallback(
            (_) => {
              _.GetEventModel().jsondata.meet_steam_schedules ||
                (_.GetEventModel().jsondata.meet_steam_schedules = []),
                _.GetEventModel().jsondata.meet_steam_schedules.push({
                  ..._,
                }),
                (function (_, _, _) {
                  _.dispatch(
                    _.state._.insert(
                      _.state.selection._,
                      _.create({
                        schedule_id: _,
                      }),
                    ),
                  );
                })(_, _.nodes.meetsteamscheduleview, _.schedule_id),
                _();
            },
            [_, _, _, _],
          );
        if ((null == _ ? void 0 : _.GetClanAccountID()) == (0, _._)())
          return _.createElement(
            _.Fragment,
            null,
            _ &&
              _.createElement(_, {
                hideModal: _,
                inputScheduleModel: null,
                fnUpdateSession: _,
              }),
            _.createElement(
              _._,
              {
                tooltip: "#MeetSteam_add_schedule_ttip",
                onClick: _,
                toggled: _,
              },
              _.createElement("img", {
                src: _._,
              }),
            ),
          );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const { schema: _, emoticonStore: __webpack_require__ } = _,
          _ = _.nodes.emoticon;
        (0, _._)(__webpack_require__),
          (0, _._)(
            _.useMemo(
              () =>
                (0, _._)({
                  rules: [_(/:([a-zA-Z0-9_]+):$/, _, __webpack_require__)],
                }),
              [_, __webpack_require__],
            ),
          );
        const _ = _.useMemo(
          () => [
            {
              type: _,
              component: _,
              readProps: (_) => ({
                emoticonStore: __webpack_require__,
                emoticon: _.textContent,
              }),
            },
          ],
          [_, __webpack_require__],
        );
        return _.createElement(_._, {
          specs: _,
        });
      }
      function _(_) {
        const {
          selected: _,
          emoticonStore: __webpack_require__,
          emoticon: _,
        } = _;
        (0, _._)(__webpack_require__);
        if (__webpack_require__.BHasEmoticon(_)) {
          const _ = _
            ? {
                background: "#54a5d4",
                filter: "brightness(1.2)",
              }
            : void 0;
          return _.createElement(
            "span",
            {
              style: _,
            },
            _.createElement(_._, {
              emoticon: _,
            }),
          );
        }
        return `:${_}:`;
      }
      function _(_, _, _) {
        return new _._(_, (_, _, _, _) => {
          const _ = _[1];
          if (!__webpack_require__.BHasEmoticon(_)) return null;
          const _ = _.create(null, _.schema.text(_));
          return _._.replaceWith(_, _, _);
        });
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        const { editModel: _, href: __webpack_require__ } = _,
          _ = (0, _._)(__webpack_require__);
        if (_) {
          const _ = _.fnBBComponent(__webpack_require__, {
            partnerEventStore: _._,
            event: _.GetEventModel(),
          });
          return _.createElement(
            _,
            {
              toolbar: _.createElement(_, {
                href: __webpack_require__,
                removeNode: _.removeNode,
                update: _.update,
                schema: _.schema,
              }),
            },
            _,
          );
        }
        return _.createElement(
          "a",
          {
            href: __webpack_require__,
          },
          __webpack_require__,
        );
      }
      function _(_) {
        const {
          href: _,
          removeNode: __webpack_require__,
          update: _,
          schema: _,
        } = _;
        return _.createElement(
          _,
          {
            onDeleteClick: __webpack_require__,
          },
          _.createElement(
            _,
            {
              onClick: () => window.open(_),
              description: (0, _._)("#ContextMenu_OpenLinkInNewWindow"),
            },
            _.createElement(_.YNO, null),
          ),
          _.createElement(
            _,
            {
              onClick: () =>
                _(
                  (0, _._)(
                    _.text(_, [
                      _.marks.link.create({
                        href: _,
                      }),
                    ]),
                  ),
                ),
              description: (0, _._)(
                "#EventEditor_DynamicLink_ConvertToTextLink",
              ),
            },
            _.createElement(_.Rkk, null),
          ),
        );
      }
      var _ = __webpack_require__("chunkid");
      const _ = (0, _._)(function (_) {
        const { editModel: _ } = _,
          _ = _.GetEventModel().loadedAllLanguages,
          _ = _.GetCurEditLanguage();
        return _
          ? _.createElement(
              _._,
              null,
              _.createElement(_, {
                ..._,
                eCurrentEditLanguage: _,
              }),
            )
          : null;
      });
      const _ = _.memo(function (_) {
        const {
            editModel: _,
            refOnInsertImage: __webpack_require__,
            limitBBCode: _,
            eCurrentEditLanguage: _,
          } = _,
          [_, _] = _.useState(),
          _ = _.useMemo(() => (0, _._)(_), [_]),
          [_, _] = _.useState(),
          _ = (function (_, _) {
            const { nodes: __webpack_require__ } = _.pm_schema,
              _ = (function (_, _, _) {
                const _ = _.useCallback(
                  (_) => {
                    const _ = `^https?://${_._.CLAN_CDN_ASSET_URL.replace(/^http[^\/]*\/\//, "")}images/(?<clanid>[0-9]+)/(?<filename>.*)(?<extension>\\.[^\\.]*)$`,
                      _ = _.match(_);
                    if (
                      _ &&
                      _.groups.clanid == _.GetClanAccountID().toString()
                    ) {
                      const _ = _._.GetClanImageByImageHash(
                        _.GetClanSteamID(),
                        _.groups.filename,
                      );
                      let _ = _ && _(_, _, _);
                      if (_) return _;
                    }
                    return "default";
                  },
                  [_, _, _],
                );
                return _ ? _ : void 0;
              })(_, __webpack_require__.image, __webpack_require__.video),
              _ = (function (_, _) {
                const _ = _.useCallback(
                  (_) =>
                    (0, _._)(_)
                      ? _.create({
                          href: _,
                        })
                      : "default",
                  [_],
                );
                return _ ? _ : void 0;
              })(0, __webpack_require__.dynamiclink);
            return _.useCallback(
              (..._) => {
                let _ = "default";
                return (
                  _ && (_ = _(..._)), "default" == _ && _ && (_ = _(..._)), _
                );
              },
              [_, _],
            );
          })(_, _);
        _.useEffect(() => {
          _(
            (function (_, _, _, _) {
              let _ = _.GetDescription(_);
              return (
                (_ =
                  null == _
                    ? void 0
                    : _.replace(
                        _._.GetUnvalidatedEmoticonReplaceRegex(),
                        "[emoticon]$1[/emoticon]",
                      )),
                new _._(_, _, (_) => _.SetDescription(_, _), {
                  parser: {
                    fnProcessText: (_) =>
                      (0, _._)(_.pm_schema, _, _.pm_schema.marks.link, _),
                  },
                })
              );
            })(_, _, _, _),
          );
        }, [_, _, _, _]);
        const _ = _.useRef(void 0);
        (0, _._)(_, {
          msAutosaveTimeout: 1e3,
        });
        const { nodes: _, marks: _ } = _.pm_schema;
        return (
          (function (_, _, _, _, _) {
            _.useEffect(() => {
              if (!_ || !_) return;
              const _ = (_, _) => {
                let _;
                switch (_) {
                  case _._.k_eInsertFullImage:
                    _ = _.create({
                      src: (0, _._)(_),
                    });
                    break;
                  case _._.k_eInsertThumbnail:
                    _ = _.create(
                      {
                        src: (0, _._)(_, !0),
                      },
                      null,
                      [
                        _.create({
                          href: (0, _._)(_),
                        }),
                      ],
                    );
                    break;
                  case _._.k_eInsertVideo:
                    let _;
                    4 == _.file_type
                      ? (_ = {
                          mp4: (0, _._)(_),
                        })
                      : 5 == _.file_type &&
                        (_ = {
                          webm: (0, _._)(_),
                        }),
                      _ && _ && (_ = __webpack_require__.create(_));
                    break;
                  case _._.k_eShowImageGroup:
                    break;
                  default:
                    (0, _._)(_, `Unhandled insert type ${_}`);
                }
                if (_) {
                  const _ = _.state._;
                  _.selection.replaceWith(_, _), _.dispatch(_);
                }
              };
              return (
                (_.current = _),
                () => {
                  _.current == _ && (_.current = void 0);
                }
              );
            }, [_, _, _, _, _]);
          })(__webpack_require__, _.image, _.video, _.link, _),
          _.createElement(
            _,
            {
              editModel: _,
              imageNode: _.image,
              videoNode: _.video,
            },
            _.createElement(
              "div",
              {
                className: _().EventDescriptionContainer,
              },
              _.createElement(_, {
                view: _,
                schema: _.pm_schema,
                refUpdateToolbar: _,
                className: _().ToolBar,
                clanSteamID: _.GetClanSteamID(),
              }),
              _.createElement(
                "div",
                {
                  className: _().EventDescriptionArea,
                },
                _.createElement(
                  _._,
                  {
                    pmState: _,
                    className: (0, _._)(
                      _().EventDescriptionRichField,
                      _().EventDetailsBody,
                    ),
                    refOnUpdate: _,
                    refView: _,
                    panelProps: {
                      onBlur: () => _.CommitChanges(),
                    },
                  },
                  _.createElement(_, {
                    eventSchemaConfig: _,
                    editModel: _,
                    onURLPasted: _,
                  }),
                ),
              ),
            ),
          )
        );
      });
      const _ = _.memo(function (_) {
        const {
            eventSchemaConfig: _,
            editModel: __webpack_require__,
            onURLPasted: _,
          } = _,
          { marks: _, nodes: _ } = _.pm_schema;
        return _.createElement(
          _.Fragment,
          null,
          _.createElement(_._, {
            linkMarkType: _.link,
            onURLPasted: _,
            schema: _.pm_schema,
          }),
          _.image &&
            _.createElement(_._, {
              nodeType: _.image,
            }),
          _.createElement(_, {
            schemaConfig: _,
            editModel: __webpack_require__,
            clanSteamID: __webpack_require__.GetClanSteamID(),
          }),
          _.createElement(_, {
            emoticonStore: _._,
            schema: _.pm_schema,
          }),
        );
      });
      function _(_) {
        const {
            schemaConfig: _,
            editModel: __webpack_require__,
            clanSteamID: _,
          } = _,
          _ = _.pm_schema,
          _ = _.useMemo(
            () =>
              (function (_) {
                return _._({
                  rules: [_._(/^>$/, _.nodes.quote)],
                });
              })(_),
            [_],
          );
        (0, _._)(_);
        const _ = _.nodes,
          _ = _.image,
          _ = _.video,
          _ = _.carousel,
          _ = _.useCallback(
            (_, _) => ({
              schemaConfig: _,
              node: _,
              imageNodeType: _,
              videoNodeType: _,
              carouselNodeType: _,
              editModel: __webpack_require__,
              clanSteamID: _,
            }),
            [_, _, _, _, __webpack_require__, _],
          ),
          _ = _.useMemo(
            () => [
              _.previewyoutube && {
                type: _.previewyoutube,
                component: _,
                readProps: (_) => ({
                  videoID: _.attrs.videoID,
                  align: _.attrs.align,
                  editModel: __webpack_require__,
                }),
              },
              _ && {
                type: _,
                component: _,
                readProps: (_) => _("image", _),
              },
              _ && {
                type: _,
                component: _,
                readProps: (_) => _("video", _),
              },
              _.meetsteamsessiongroup && {
                type: _.meetsteamsessiongroup,
                component: _,
                readProps: (_) => ({
                  group_id: _.attrs.group_id,
                }),
              },
              _.meetsteamscheduleview && {
                type: _.meetsteamscheduleview,
                component: _,
                readProps: (_) => ({
                  schedule_id: _.attrs.schedule_id,
                }),
              },
              _.userpolls && {
                type: _.userpolls,
                component: _,
                readProps: (_) => ({
                  poll_id: _.attrs.poll_id,
                }),
              },
              _.dynamiclink && {
                type: _.dynamiclink,
                component: _,
                readProps: (_) => ({
                  editModel: __webpack_require__,
                  href: _.attrs.href,
                  schema: _.pm_schema,
                }),
              },
              _.carousel && {
                type: _.carousel,
                component: _,
                readProps: (_) => ({
                  node: _,
                  imageNodeType: _,
                  videoNodeType: _,
                  schemaConfig: _,
                  editModel: __webpack_require__,
                }),
              },
            ],
            [_, _, _, __webpack_require__, _, _],
          );
        return _.createElement(_._, {
          specs: _,
        });
      }
    },
  },
]);
