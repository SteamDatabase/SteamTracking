"use strict";
(self.webpackChunkcommunity = self.webpackChunkcommunity || []).push([
  [3359],
  {
    chunkid: (module, module_exports, __webpack_require__) => {
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
      });
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = "undefined" != typeof document ? _.useLayoutEffect : _.useEffect;
      function _(_, _) {
        if (_ === _) return !0;
        if (typeof _ != typeof _) return !1;
        if ("function" == typeof _ && _.toString() === _.toString()) return !0;
        let _, _, _;
        if (_ && _ && "object" == typeof _) {
          if (Array.isArray(_)) {
            if (((_ = _.length), _ !== _.length)) return !1;
            for (_ = _; 0 != _--; ) if (!_(_[_], _[_])) return !1;
            return !0;
          }
          if (
            ((_ = Object.keys(_)), (_ = _.length), _ !== Object.keys(_).length)
          )
            return !1;
          for (_ = _; 0 != _--; )
            if (!{}.hasOwnProperty.call(_, _[_])) return !1;
          for (_ = _; 0 != _--; ) {
            const _ = _[_];
            if (("_owner" !== _ || !_.$$typeof) && !_(_[_], _[_])) return !1;
          }
          return !0;
        }
        return _ != _ && _ != _;
      }
      function _(_) {
        if ("undefined" == typeof window) return 1;
        return (_.ownerDocument.defaultView || window).devicePixelRatio || 1;
      }
      function _(_, _) {
        const _ = _(_);
        return Math.round(_ * _) / _;
      }
      function _(_) {
        const _ = _.useRef(_);
        return (
          _(() => {
            _.current = _;
          }),
          _
        );
      }
      function _(_) {
        void 0 === _ && (_ = {});
        const {
            placement: _ = "bottom",
            strategy: __webpack_require__ = "absolute",
            middleware: _ = [],
            platform: _,
            elements: { reference: _, floating: _ } = {},
            transform: _ = !0,
            whileElementsMounted: _,
            open: _,
          } = _,
          [_, _] = _.useState({
            _: 0,
            _: 0,
            strategy: __webpack_require__,
            placement: _,
            middlewareData: {},
            isPositioned: !1,
          }),
          [_, _] = _.useState(_);
        _(_, _) || _(_);
        const [_, _] = _.useState(null),
          [_, _] = _.useState(null),
          _ = _.useCallback((_) => {
            _ !== _.current && ((_.current = _), _(_));
          }, []),
          _ = _.useCallback((_) => {
            _ !== _.current && ((_.current = _), _(_));
          }, []),
          _ = _ || _,
          _ = _ || _,
          _ = _.useRef(null),
          _ = _.useRef(null),
          _ = _.useRef(_),
          _ = null != _,
          _ = _(_),
          _ = _(_),
          _ = _(_),
          _ = _.useCallback(() => {
            if (!_.current || !_.current) return;
            const _ = {
              placement: _,
              strategy: __webpack_require__,
              middleware: _,
            };
            _.current && (_.platform = _.current),
              (0, _._)(_.current, _.current, _).then((_) => {
                const _ = {
                  ..._,
                  isPositioned: !1 !== _.current,
                };
                _.current &&
                  !_(_.current, _) &&
                  ((_.current = _),
                  _.flushSync(() => {
                    _(_);
                  }));
              });
          }, [_, _, __webpack_require__, _, _]);
        _(() => {
          !1 === _ &&
            _.current.isPositioned &&
            ((_.current.isPositioned = !1),
            _((_) => ({
              ..._,
              isPositioned: !1,
            })));
        }, [_]);
        const _ = _.useRef(!1);
        _(
          () => (
            (_.current = !0),
            () => {
              _.current = !1;
            }
          ),
          [],
        ),
          _(() => {
            if ((_ && (_.current = _), _ && (_.current = _), _ && _)) {
              if (_.current) return _.current(_, _, _);
              _();
            }
          }, [_, _, _, _, _]);
        const _ = _.useMemo(
            () => ({
              reference: _,
              floating: _,
              setReference: _,
              setFloating: _,
            }),
            [_, _],
          ),
          _ = _.useMemo(
            () => ({
              reference: _,
              floating: _,
            }),
            [_, _],
          ),
          _ = _.useMemo(() => {
            const _ = {
              position: __webpack_require__,
              left: 0,
              top: 0,
            };
            if (!_.floating) return _;
            const _ = _(_.floating, _._),
              _ = _(_.floating, _._);
            return _
              ? {
                  ..._,
                  transform: "translate(" + _ + "px, " + _ + "px)",
                  ...(_(_.floating) >= 1.5 && {
                    willChange: "transform",
                  }),
                }
              : {
                  position: __webpack_require__,
                  left: _,
                  top: _,
                };
          }, [__webpack_require__, _, _.floating, _._, _._]);
        return _.useMemo(
          () => ({
            ..._,
            update: _,
            refs: _,
            elements: _,
            floatingStyles: _,
          }),
          [_, _, _, _, _],
        );
      }
      const _ = (_, _) => ({
          ...(0, _._)(_),
          options: [_, _],
        }),
        _ = (_, _) => ({
          ...(0, _._)(_),
          options: [_, _],
        }),
        _ = (_, _) => ({
          ...(0, _._)(_),
          options: [_, _],
        }),
        _ = (_, _) => ({
          ...(0, _._)(_),
          options: [_, _],
        });
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
      });
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_, 2),
        _ = __webpack_require__("chunkid");
      function _(_) {
        let _ = _.activeElement;
        for (
          ;
          null !=
          (null == (__webpack_require__ = _) ||
          null == (__webpack_require__ = __webpack_require__.shadowRoot)
            ? void 0
            : __webpack_require__.activeElement);
        ) {
          var _;
          _ = _.shadowRoot.activeElement;
        }
        return _;
      }
      function _(_, _) {
        if (!_ || !_) return !1;
        const _ = null == _.getRootNode ? void 0 : _.getRootNode();
        if (_.contains(_)) return !0;
        if (_ && (0, _._)(_)) {
          let _ = _;
          for (; _; ) {
            if (_ === _) return !0;
            _ = _.parentNode || _.host;
          }
        }
        return !1;
      }
      function _() {
        const _ = navigator.userAgentData;
        return null != _ && _.platform ? _.platform : navigator.platform;
      }
      function _() {
        const _ = navigator.userAgentData;
        return _ && Array.isArray(_.brands)
          ? _.brands
              .map((_) => {
                let { brand: _, version: __webpack_require__ } = _;
                return _ + "/" + __webpack_require__;
              })
              .join(" ")
          : navigator.userAgent;
      }
      function _(_) {
        return (
          !(0 !== _.mozInputSource || !_.isTrusted) ||
          (_() && _.pointerType
            ? "click" === _.type && 1 === _.buttons
            : 0 === _.detail && !_.pointerType)
        );
      }
      function _(_) {
        return (
          !_().includes("jsdom/") &&
          ((!_() && 0 === _.width && 0 === _.height) ||
            (_() &&
              1 === _.width &&
              1 === _.height &&
              0 === _.pressure &&
              0 === _.detail &&
              "mouse" === _.pointerType) ||
            (_.width < 1 &&
              _.height < 1 &&
              0 === _.pressure &&
              0 === _.detail &&
              "touch" === _.pointerType))
        );
      }
      function _() {
        return /apple/i.test(navigator.vendor);
      }
      function _() {
        const _ = /android/i;
        return _.test(_()) || _.test(_());
      }
      function _(_, _) {
        const _ = ["mouse", "pen"];
        return (
          _ || __webpack_require__.push("", void 0),
          __webpack_require__.includes(_)
        );
      }
      function _(_) {
        return (null == _ ? void 0 : _.ownerDocument) || document;
      }
      function _(_, _) {
        if (null == _) return !1;
        if ("composedPath" in _) return _.composedPath().includes(_);
        const _ = _;
        return null != _.target && _.contains(_.target);
      }
      function _(_) {
        return "composedPath" in _ ? _.composedPath()[0] : _.target;
      }
      const _ =
        "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
      function _(_) {
        return (0, _._)(_) && _.matches(_);
      }
      function _(_) {
        _.preventDefault(), _.stopPropagation();
      }
      function _(_) {
        return !!_ && "combobox" === _.getAttribute("role") && _(_);
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = [
          "input:not([inert])",
          "select:not([inert])",
          "textarea:not([inert])",
          "a[href]:not([inert])",
          "button:not([inert])",
          "[tabindex]:not(slot):not([inert])",
          "audio[controls]:not([inert])",
          "video[controls]:not([inert])",
          '[contenteditable]:not([contenteditable="false"]):not([inert])',
          "details>summary:first-of-type:not([inert])",
          "details:not([inert])",
        ],
        _ = _.join(","),
        _ = "undefined" == typeof Element,
        _ = _
          ? function () {}
          : Element.prototype.matches ||
            Element.prototype.msMatchesSelector ||
            Element.prototype.webkitMatchesSelector,
        _ =
          !_ && Element.prototype.getRootNode
            ? function (_) {
                var _;
                return null == _ || null === (_ = _.getRootNode) || void 0 === _
                  ? void 0
                  : _.call(_);
              }
            : function (_) {
                return null == _ ? void 0 : _.ownerDocument;
              },
        _ = function _(_, _) {
          var _;
          void 0 === _ && (_ = !0);
          var _ =
            null == _ || null === (_ = _.getAttribute) || void 0 === _
              ? void 0
              : _.call(_, "inert");
          return "" === _ || "true" === _ || (_ && _ && _(_.parentNode));
        },
        _ = function (_, _, _) {
          if (_(_)) return [];
          var _ = Array.prototype.slice.apply(_.querySelectorAll(_));
          return _ && _.call(_, _) && _.unshift(_), (_ = _.filter(_));
        },
        _ = function _(_, _, _) {
          for (var _ = [], _ = Array.from(_); _.length; ) {
            var _ = _.shift();
            if (!_(_, !1))
              if ("SLOT" === _.tagName) {
                var _ = _.assignedElements(),
                  _ = _(_.length ? _ : _.children, !0, _);
                _.flatten
                  ? _.push.apply(_, _)
                  : _.push({
                      scopeParent: _,
                      candidates: _,
                    });
              } else {
                _.call(_, _) &&
                  _.filter(_) &&
                  (_ || !_.includes(_)) &&
                  _.push(_);
                var _ =
                    _.shadowRoot ||
                    ("function" == typeof _.getShadowRoot &&
                      _.getShadowRoot(_)),
                  _ =
                    !_(_, !1) && (!_.shadowRootFilter || _.shadowRootFilter(_));
                if (_ && _) {
                  var _ = _(!0 === _ ? _.children : _.children, !0, _);
                  _.flatten
                    ? _.push.apply(_, _)
                    : _.push({
                        scopeParent: _,
                        candidates: _,
                      });
                } else _.unshift.apply(_, _.children);
              }
          }
          return _;
        },
        _ = function (_) {
          return !isNaN(parseInt(_.getAttribute("tabindex"), 10));
        },
        _ = function (_) {
          if (!_) throw new Error("No node provided");
          return _.tabIndex < 0 &&
            (/^(AUDIO|VIDEO|DETAILS)$/.test(_.tagName) ||
              (function (_) {
                var _,
                  _ =
                    null == _ || null === (_ = _.getAttribute) || void 0 === _
                      ? void 0
                      : _.call(_, "contenteditable");
                return "" === _ || "true" === _;
              })(_)) &&
            !_(_)
            ? 0
            : _.tabIndex;
        },
        _ = function (_, _) {
          return _.tabIndex === _.tabIndex
            ? _.documentOrder - _.documentOrder
            : _.tabIndex - _.tabIndex;
        },
        _ = function (_) {
          return "INPUT" === _.tagName;
        },
        _ = function (_) {
          return (
            (function (_) {
              return _(_) && "radio" === _.type;
            })(_) &&
            !(function (_) {
              if (!_.name) return !0;
              var _,
                _ = _.form || _(_),
                _ = function (_) {
                  return __webpack_require__.querySelectorAll(
                    'input[type="radio"][name="' + _ + '"]',
                  );
                };
              if (
                "undefined" != typeof window &&
                void 0 !== window.CSS &&
                "function" == typeof window.CSS.escape
              )
                _ = _(window.CSS.escape(_.name));
              else
                try {
                  _ = _(_.name);
                } catch (_) {
                  return (
                    console.error(
                      "Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",
                      _.message,
                    ),
                    !1
                  );
                }
              var _ = (function (_, _) {
                for (var _ = 0; _ < _.length; _++)
                  if (_[_].checked && _[_].form === _) return _[_];
              })(_, _.form);
              return !_ || _ === _;
            })(_)
          );
        },
        _ = function (_) {
          var _ = _.getBoundingClientRect(),
            _ = _.width,
            _ = _.height;
          return 0 === _ && 0 === _;
        },
        _ = function (_, _) {
          var _ = _.displayCheck,
            _ = _.getShadowRoot;
          if ("hidden" === getComputedStyle(_).visibility) return !0;
          var _ = _.call(_, "details>summary:first-of-type")
            ? _.parentElement
            : _;
          if (_.call(_, "details:not([open]) *")) return !0;
          if (_ && "full" !== _ && "legacy-full" !== _) {
            if ("non-zero-area" === _) return _(_);
          } else {
            if ("function" == typeof _) {
              for (var _ = _; _; ) {
                var _ = _.parentElement,
                  _ = _(_);
                if (_ && !_.shadowRoot && !0 === _(_)) return _(_);
                _ = _.assignedSlot
                  ? _.assignedSlot
                  : _ || _ === _.ownerDocument
                    ? _
                    : _.host;
              }
              _ = _;
            }
            if (
              (function (_) {
                var _,
                  _,
                  _,
                  _,
                  _ = _ && _(_),
                  _ = null === (_ = _) || void 0 === _ ? void 0 : _.host,
                  _ = !1;
                if (_ && _ !== _)
                  for (
                    _ = !!(
                      (null !== (_ = _) &&
                        void 0 !== _ &&
                        null !== (_ = _.ownerDocument) &&
                        void 0 !== _ &&
                        _.contains(_)) ||
                      (null != _ &&
                        null !== (_ = _.ownerDocument) &&
                        void 0 !== _ &&
                        _.contains(_))
                    );
                    !_ && _;
                  ) {
                    var _, _, _;
                    _ = !(
                      null ===
                        (_ = _ =
                          null === (_ = _ = _(_)) || void 0 === _
                            ? void 0
                            : _.host) ||
                      void 0 === _ ||
                      null === (_ = _.ownerDocument) ||
                      void 0 === _ ||
                      !_.contains(_)
                    );
                  }
                return _;
              })(_)
            )
              return !_.getClientRects().length;
            if ("legacy-full" !== _) return !0;
          }
          return !1;
        },
        _ = function (_, _) {
          return !(
            _.disabled ||
            _(_) ||
            (function (_) {
              return _(_) && "hidden" === _.type;
            })(_) ||
            _(_, _) ||
            (function (_) {
              return (
                "DETAILS" === _.tagName &&
                Array.prototype.slice.apply(_.children).some(function (_) {
                  return "SUMMARY" === _.tagName;
                })
              );
            })(_) ||
            (function (_) {
              if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(_.tagName))
                for (var _ = _.parentElement; _; ) {
                  if ("FIELDSET" === _.tagName && _.disabled) {
                    for (var _ = 0; _ < _.children.length; _++) {
                      var _ = _.children.item(_);
                      if ("LEGEND" === _.tagName)
                        return (
                          !!_.call(_, "fieldset[disabled] *") || !_.contains(_)
                        );
                    }
                    return !0;
                  }
                  _ = _.parentElement;
                }
              return !1;
            })(_)
          );
        },
        _ = function (_, _) {
          return !(_(_) || _(_) < 0 || !_(_, _));
        },
        _ = function (_) {
          var _ = parseInt(_.getAttribute("tabindex"), 10);
          return !!(isNaN(_) || _ >= 0);
        },
        _ = function _(_) {
          var _ = [],
            _ = [];
          return (
            _.forEach(function (_, _) {
              var _ = !!_.scopeParent,
                _ = _ ? _.scopeParent : _,
                _ = (function (_, _) {
                  var _ = _(_);
                  return _ < 0 && _ && !_(_) ? 0 : _;
                })(_, _),
                _ = _ ? _(_.candidates) : _;
              0 === _
                ? _
                  ? _.push.apply(_, _)
                  : __webpack_require__.push(_)
                : _.push({
                    documentOrder: _,
                    tabIndex: _,
                    item: _,
                    isScope: _,
                    content: _,
                  });
            }),
            _.sort(_)
              .reduce(function (_, _) {
                return (
                  _.isScope ? _.push.apply(_, _.content) : _.push(_.content), _
                );
              }, [])
              .concat(_)
          );
        },
        _ = function (_, _) {
          var _;
          return (
            (_ = (_ = _ || {}).getShadowRoot
              ? _([_], _.includeContainer, {
                  filter: _.bind(null, _),
                  flatten: !1,
                  getShadowRoot: _.getShadowRoot,
                  shadowRootFilter: _,
                })
              : _(_, _.includeContainer, _.bind(null, _))),
            _(_)
          );
        },
        _ = function (_, _) {
          if (((_ = _ || {}), !_)) throw new Error("No node provided");
          return !1 !== _.call(_, _) && _(_, _);
        },
        _ = (__webpack_require__("chunkid"), __webpack_require__("chunkid"));
      function _(_) {
        const _ = _.useRef(void 0),
          _ = _.useCallback((_) => {
            const _ = _.map((_) => {
              if (null != _) {
                if ("function" == typeof _) {
                  const _ = _,
                    _ = __webpack_require__(_);
                  return "function" == typeof _
                    ? _
                    : () => {
                        __webpack_require__(null);
                      };
                }
                return (
                  (_.current = _),
                  () => {
                    _.current = null;
                  }
                );
              }
            });
            return () => {
              __webpack_require__.forEach((_) => (null == _ ? void 0 : _()));
            };
          }, _);
        return _.useMemo(
          () =>
            _.every((_) => null == _)
              ? null
              : (_) => {
                  _.current && (_.current(), (_.current = void 0)),
                    null != _ && (_.current = __webpack_require__(_));
                },
          _,
        );
      }
      const _ = {
          ..._,
        },
        _ = _.useInsertionEffect || ((_) => _());
      function _(_) {
        const _ = _.useRef(() => {
          0;
        });
        return (
          _(() => {
            _.current = _;
          }),
          _.useCallback(function () {
            for (var _ = arguments.length, _ = new Array(_), _ = 0; _ < _; _++)
              _[_] = arguments[_];
            return null == _.current ? void 0 : _.current(..._);
          }, [])
        );
      }
      const _ = "ArrowUp",
        _ = "ArrowDown",
        _ = "ArrowLeft",
        _ = "ArrowRight";
      function _(_, _, _) {
        return Math.floor(_ / _) !== _;
      }
      function _(_, _) {
        return _ < 0 || _ >= _.current.length;
      }
      function _(_, _) {
        return _(_, {
          disabledIndices: _,
        });
      }
      function _(_, _) {
        return _(_, {
          decrement: !0,
          startingIndex: _.current.length,
          disabledIndices: _,
        });
      }
      function _(_, _) {
        let {
          startingIndex: __webpack_require__ = -1,
          decrement: _ = !1,
          disabledIndices: _,
          amount: _ = 1,
        } = void 0 === _ ? {} : _;
        const _ = _.current;
        let _ = __webpack_require__;
        do {
          _ += _ ? -_ : _;
        } while (_ >= 0 && _ <= _.length - 1 && _(_, _, _));
        return _;
      }
      function _(_, _) {
        let {
            event: __webpack_require__,
            orientation: _,
            loop: _,
            rtl: _,
            cols: _,
            disabledIndices: _,
            minIndex: _,
            maxIndex: _,
            prevIndex: _,
            stopEvent: _ = !1,
          } = _,
          _ = _;
        if (__webpack_require__.key === _) {
          if ((_ && _(__webpack_require__), -1 === _)) _ = _;
          else if (
            ((_ = _(_, {
              startingIndex: _,
              amount: _,
              decrement: !0,
              disabledIndices: _,
            })),
            _ && (_ - _ < _ || _ < 0))
          ) {
            const _ = _ % _,
              _ = _ % _,
              _ = _ - (_ - _);
            _ = _ === _ ? _ : _ > _ ? _ : _ - _;
          }
          _(_, _) && (_ = _);
        }
        if (
          (_.key === _ &&
            (_ && _(_),
            -1 === _
              ? (_ = _)
              : ((_ = _(_, {
                  startingIndex: _,
                  amount: _,
                  disabledIndices: _,
                })),
                _ &&
                  _ + _ > _ &&
                  (_ = _(_, {
                    startingIndex: (_ % _) - _,
                    amount: _,
                    disabledIndices: _,
                  }))),
            _(_, _) && (_ = _)),
          "both" === _)
        ) {
          const _ = (0, _._)(_ / _);
          _.key === (_ ? _ : _) &&
            (_ && _(_),
            _ % _ != _ - 1
              ? ((_ = _(_, {
                  startingIndex: _,
                  disabledIndices: _,
                })),
                _ &&
                  _(_, _, _) &&
                  (_ = _(_, {
                    startingIndex: _ - (_ % _) - 1,
                    disabledIndices: _,
                  })))
              : _ &&
                (_ = _(_, {
                  startingIndex: _ - (_ % _) - 1,
                  disabledIndices: _,
                })),
            _(_, _, _) && (_ = _)),
            _.key === (_ ? _ : _) &&
              (_ && _(_),
              _ % _ != 0
                ? ((_ = _(_, {
                    startingIndex: _,
                    decrement: !0,
                    disabledIndices: _,
                  })),
                  _ &&
                    _(_, _, _) &&
                    (_ = _(_, {
                      startingIndex: _ + (_ - (_ % _)),
                      decrement: !0,
                      disabledIndices: _,
                    })))
                : _ &&
                  (_ = _(_, {
                    startingIndex: _ + (_ - (_ % _)),
                    decrement: !0,
                    disabledIndices: _,
                  })),
              _(_, _, _) && (_ = _));
          const _ = (0, _._)(_ / _) === _;
          _(_, _) &&
            (_ =
              _ && _
                ? _.key === (_ ? _ : _)
                  ? _
                  : _(_, {
                      startingIndex: _ - (_ % _) - 1,
                      disabledIndices: _,
                    })
                : _);
        }
        return _;
      }
      function _(_, _, _) {
        const _ = [];
        let _ = 0;
        return (
          _.forEach((_, _) => {
            let { width: _, height: _ } = _,
              _ = !1;
            for (_ && (_ = 0); !_; ) {
              const _ = [];
              for (let _ = 0; _ < _; _++)
                for (let _ = 0; _ < _; _++) _.push(_ + _ + _ * _);
              (_ % _) + _ <= _ && _.every((_) => null == _[_])
                ? (_.forEach((_) => {
                    _[_] = _;
                  }),
                  (_ = !0))
                : _++;
            }
          }),
          [..._]
        );
      }
      function _(_, _, _, _, _) {
        if (-1 === _) return -1;
        const _ = __webpack_require__.indexOf(_),
          _ = _[_];
        switch (_) {
          case "tl":
            return _;
          case "tr":
            return _ ? _ + _.width - 1 : _;
          case "bl":
            return _ ? _ + (_.height - 1) * _ : _;
          case "br":
            return __webpack_require__.lastIndexOf(_);
        }
      }
      function _(_, _) {
        return _.flatMap((_, _) => (_.includes(_) ? [_] : []));
      }
      function _(_, _, _) {
        if (_) return __webpack_require__.includes(_);
        const _ = _[_];
        return (
          null == _ ||
          _.hasAttribute("disabled") ||
          "true" === _.getAttribute("aria-disabled")
        );
      }
      var _ = "undefined" != typeof document ? _.useLayoutEffect : _.useEffect;
      function _(_, _) {
        const _ = _.compareDocumentPosition(_);
        return _ & Node.DOCUMENT_POSITION_FOLLOWING ||
          _ & Node.DOCUMENT_POSITION_CONTAINED_BY
          ? -1
          : _ & Node.DOCUMENT_POSITION_PRECEDING ||
              _ & Node.DOCUMENT_POSITION_CONTAINS
            ? 1
            : 0;
      }
      const _ = _.createContext({
        register: () => {},
        unregister: () => {},
        map: new Map(),
        elementsRef: {
          current: [],
        },
      });
      function _(_) {
        const {
            children: _,
            elementsRef: __webpack_require__,
            labelsRef: _,
          } = _,
          [_, _] = _.useState(() => new Set()),
          _ = _.useCallback((_) => {
            _((_) => new Set(_).add(_));
          }, []),
          _ = _.useCallback((_) => {
            _((_) => {
              const _ = new Set(_);
              return __webpack_require__.delete(_), _;
            });
          }, []),
          _ = _.useMemo(() => {
            const _ = new Map();
            return (
              Array.from(_.keys())
                .sort(_)
                .forEach((_, _) => {
                  _.set(_, _);
                }),
              _
            );
          }, [_]);
        return (0, _.jsx)(_.Provider, {
          value: _.useMemo(
            () => ({
              register: _,
              unregister: _,
              map: _,
              elementsRef: __webpack_require__,
              labelsRef: _,
            }),
            [_, _, _, __webpack_require__, _],
          ),
          children: _,
        });
      }
      function _(_) {
        void 0 === _ && (_ = {});
        const { label: _ } = _,
          {
            register: __webpack_require__,
            unregister: _,
            map: _,
            elementsRef: _,
            labelsRef: _,
          } = _.useContext(_),
          [_, _] = _.useState(null),
          _ = _.useRef(null),
          _ = _.useCallback(
            (_) => {
              if (((_.current = _), null !== _ && ((_.current[_] = _), _))) {
                var _;
                const _ = void 0 !== _;
                _.current[_] = _
                  ? _
                  : null != (_ = null == _ ? void 0 : _.textContent)
                    ? _
                    : null;
              }
            },
            [_, _, _, _],
          );
        return (
          _(() => {
            const _ = _.current;
            if (_)
              return (
                __webpack_require__(_),
                () => {
                  _(_);
                }
              );
          }, [__webpack_require__, _]),
          _(() => {
            const _ = _.current ? _.get(_.current) : null;
            null != _ && _(_);
          }, [_]),
          _.useMemo(
            () => ({
              ref: _,
              index: null == _ ? -1 : _,
            }),
            [_, _],
          )
        );
      }
      const _ = [_, _],
        _ = [_, _];
      let _ = !1,
        _ = 0;
      const _ = () =>
        "floating-ui-" + Math.random().toString(36).slice(2, 6) + _++;
      const _ =
        _.useId ||
        function () {
          const [_, _] = _.useState(() => (_ ? _() : void 0));
          return (
            _(() => {
              null == _ && _(_());
            }, []),
            _.useEffect(() => {
              _ = !0;
            }, []),
            _
          );
        };
      function _() {
        const _ = new Map();
        return {
          emit(_, _) {
            var _;
            null == (_ = _.get(_)) || _.forEach((_) => _(_));
          },
          _(_, _) {
            _.set(_, [...(_.get(_) || []), _]);
          },
          off(_, _) {
            var _;
            _.set(
              _,
              (null == (_ = _.get(_)) ? void 0 : _.filter((_) => _ !== _)) ||
                [],
            );
          },
        };
      }
      const _ = _.createContext(null),
        _ = _.createContext(null),
        _ = () => {
          var _;
          return (null == (_ = _.useContext(_)) ? void 0 : _._) || null;
        },
        _ = () => _.useContext(_);
      function _(_) {
        return "data-floating-ui-" + _;
      }
      function _(_) {
        -1 !== _.current && (clearTimeout(_.current), (_.current = -1));
      }
      function _(_) {
        const _ = (0, _.useRef)(_);
        return (
          _(() => {
            _.current = _;
          }),
          _
        );
      }
      let _ = 0;
      function _(_, _) {
        void 0 === _ && (_ = {});
        const {
          preventScroll: __webpack_require__ = !1,
          cancelPrevious: _ = !0,
          sync: _ = !1,
        } = _;
        _ && cancelAnimationFrame(_);
        const _ = () =>
          null == _
            ? void 0
            : _.focus({
                preventScroll: __webpack_require__,
              });
        _ ? _() : (_ = requestAnimationFrame(_));
      }
      function _(_, _) {
        var _;
        let _ = [],
          _ = null == (_ = _.find((_) => _._ === _)) ? void 0 : _.parentId;
        for (; _; ) {
          const _ = _.find((_) => _._ === _);
          (_ = null == _ ? void 0 : _.parentId), _ && (_ = _.concat(_));
        }
        return _;
      }
      function _(_, _) {
        let _ = _.filter((_) => {
            var _;
            return (
              _.parentId === _ && (null == (_ = _.context) ? void 0 : _.open)
            );
          }),
          _ = _;
        for (; _.length; )
          (_ = _.filter((_) => {
            var _;
            return null == (_ = _)
              ? void 0
              : _.some((_) => {
                  var _;
                  return (
                    _.parentId === _._ &&
                    (null == (_ = _.context) ? void 0 : _.open)
                  );
                });
          })),
            (_ = __webpack_require__.concat(_));
        return _;
      }
      let _ = new WeakMap(),
        _ = new WeakSet(),
        _ = {},
        _ = 0;
      const _ = () =>
          "undefined" != typeof HTMLElement && "inert" in HTMLElement.prototype,
        _ = (_) => _ && (_.host || _(_.parentNode)),
        _ = (_, _) =>
          _.map((_) => {
            if (_.contains(_)) return _;
            const _ = _(_);
            return _.contains(_) ? _ : null;
          }).filter((_) => null != _);
      function _(_, _, _) {
        void 0 === _ && (_ = !1), void 0 === _ && (_ = !1);
        const _ = _(_[0]).body;
        return (function (_, _, _, _) {
          const _ = "data-floating-ui-inert",
            _ = _ ? "inert" : _ ? "aria-hidden" : null,
            _ = _(_, _),
            _ = new Set(),
            _ = new Set(_),
            _ = [];
          _[_] || (_[_] = new WeakMap());
          const _ = _[_];
          return (
            _.forEach(function _(_) {
              _ && !_.has(_) && (_.add(_), _.parentNode && _(_.parentNode));
            }),
            (function _(_) {
              _ &&
                !_.has(_) &&
                [].forEach.call(_.children, (_) => {
                  if ("script" !== (0, _._)(_))
                    if (_.has(_)) _(_);
                    else {
                      const _ = _ ? _.getAttribute(_) : null,
                        _ = null !== _ && "false" !== _,
                        _ = _.get(_) || 0,
                        _ = _ ? _ + 1 : _,
                        _ = (_.get(_) || 0) + 1;
                      _.set(_, _),
                        _.set(_, _),
                        _.push(_),
                        1 === _ && _ && _.add(_),
                        1 === _ && _.setAttribute(_, ""),
                        !_ && _ && _.setAttribute(_, "true");
                    }
                });
            })(_),
            _.clear(),
            _++,
            () => {
              _.forEach((_) => {
                const _ = _.get(_) || 0,
                  _ = _ ? _ - 1 : _,
                  _ = (_.get(_) || 0) - 1;
                _.set(_, _),
                  _.set(_, _),
                  _ || (!_.has(_) && _ && _.removeAttribute(_), _.delete(_)),
                  _ || _.removeAttribute(_);
              }),
                _--,
                _ ||
                  ((_ = new WeakMap()),
                  (_ = new WeakMap()),
                  (_ = new WeakSet()),
                  (_ = {}));
            }
          );
        })(_.concat(Array.from(_.querySelectorAll("[aria-live]"))), _, _, _);
      }
      const _ = () => ({
        getShadowRoot: !0,
        displayCheck:
          "function" == typeof ResizeObserver &&
          ResizeObserver.toString().includes("[native code]")
            ? "full"
            : "none",
      });
      function _(_, _) {
        const _ = _(_, _());
        "prev" === _ && __webpack_require__.reverse();
        const _ = __webpack_require__.indexOf(_(_(_)));
        return __webpack_require__.slice(_ + 1)[0];
      }
      function _() {
        return _(document.body, "next");
      }
      function _() {
        return _(document.body, "prev");
      }
      function _(_, _) {
        const _ = _ || _.currentTarget,
          _ = _.relatedTarget;
        return !_ || !_(_, _);
      }
      const _ = {
          border: 0,
          clip: "rect(0 0 0 0)",
          height: "1px",
          margin: "-1px",
          overflow: "hidden",
          padding: 0,
          position: "fixed",
          whiteSpace: "nowrap",
          width: "1px",
          top: 0,
          left: 0,
        },
        _ = _.forwardRef(function (_, _) {
          const [__webpack_require__, _] = _.useState();
          _(() => {
            _() && _("button");
          }, []);
          const _ = {
            ref: _,
            tabIndex: 0,
            role: __webpack_require__,
            "aria-hidden": !__webpack_require__ || void 0,
            [_("focus-guard")]: "",
            style: _,
          };
          return (0, _.jsx)("span", {
            ..._,
            ..._,
          });
        }),
        _ = _.createContext(null);
      const _ = () => _.useContext(_),
        _ = "data-floating-ui-focusable";
      function _(_) {
        return _
          ? _.hasAttribute(_)
            ? _
            : _.querySelector("[" + _ + "]") || _
          : null;
      }
      function _(_) {
        return _.useMemo(
          () => (_) => {
            _.forEach((_) => {
              _ && (_.current = _);
            });
          },
          _,
        );
      }
      const _ = 20;
      let _ = [];
      function _() {
        return _.slice()
          .reverse()
          .find((_) => _.isConnected);
      }
      const _ = _.forwardRef(function (_, _) {
        return (0, _.jsx)("button", {
          ..._,
          type: "button",
          ref: _,
          tabIndex: -1,
          style: _,
        });
      });
      function _(_) {
        const {
            context: _,
            children: __webpack_require__,
            disabled: _ = !1,
            order: _ = ["content"],
            guards: _ = !0,
            initialFocus: _ = 0,
            returnFocus: _ = !0,
            restoreFocus: _ = !1,
            modal: _ = !0,
            visuallyHiddenDismiss: _ = !1,
            closeOnFocusOut: _ = !0,
            outsideElementsInert: _ = !1,
          } = _,
          {
            open: _,
            onOpenChange: _,
            events: _,
            dataRef: _,
            elements: { domReference: _, floating: _ },
          } = _,
          _ = _(() => {
            var _;
            return null == (_ = _.current.floatingContext) ? void 0 : _.nodeId;
          }),
          _ = "number" == typeof _ && _ < 0,
          _ = _(_) && _,
          _ = _(),
          _ = !_ || _,
          _ = !_ || (_ && _),
          _ = _(_),
          _ = _(_),
          _ = _(_),
          _ = _(),
          _ = _(),
          _ = _.useRef(null),
          _ = _.useRef(null),
          _ = _.useRef(!1),
          _ = _.useRef(!1),
          _ = _.useRef(-1),
          _ = null != _,
          _ = _(_),
          _ = _(function (_) {
            return void 0 === _ && (_ = _), _ ? _(_, _()) : [];
          }),
          _ = _((_) => {
            const _ = _(_);
            return _.current
              .map((_) =>
                _ && "reference" === _ ? _ : _ && "floating" === _ ? _ : _,
              )
              .filter(Boolean)
              .flat();
          });
        _.useEffect(() => {
          if (_) return;
          if (!_) return;
          function _(_) {
            if ("Tab" === _.key) {
              _(_, _(_(_))) && 0 === _().length && !_ && _(_);
              const _ = _(),
                _ = _(_);
              "reference" === _.current[0] &&
                _ === _ &&
                (_(_), _.shiftKey ? _(_[_.length - 1]) : _(_[1])),
                "floating" === _.current[1] &&
                  _ === _ &&
                  _.shiftKey &&
                  (_(_), _(_[0]));
            }
          }
          const _ = _(_);
          return (
            _.addEventListener("keydown", _),
            () => {
              _.removeEventListener("keydown", _);
            }
          );
        }, [_, _, _, _, _, _, _, _]),
          _.useEffect(() => {
            if (!_ && _)
              return (
                _.addEventListener("focusin", _),
                () => {
                  _.removeEventListener("focusin", _);
                }
              );
            function _(_) {
              const _ = _(_),
                _ = _().indexOf(_);
              -1 !== _ && (_.current = _);
            }
          }, [_, _, _]),
          _.useEffect(() => {
            if (!_ && _)
              return _ && (0, _._)(_)
                ? (_.addEventListener("focusout", _),
                  _.addEventListener("pointerdown", _),
                  _.addEventListener("focusout", _),
                  () => {
                    _.removeEventListener("focusout", _),
                      _.removeEventListener("pointerdown", _),
                      _.removeEventListener("focusout", _);
                  })
                : void 0;
            function _() {
              (_.current = !0),
                setTimeout(() => {
                  _.current = !1;
                });
            }
            function _(_) {
              const _ = _.relatedTarget;
              queueMicrotask(() => {
                const _ = _(),
                  _ = !(
                    _(_, _) ||
                    _(_, _) ||
                    _(_, _) ||
                    _(null == _ ? void 0 : _.portalNode, _) ||
                    (null != _ && _.hasAttribute(_("focus-guard"))) ||
                    (_ &&
                      (_(_.nodesRef.current, _).find((_) => {
                        var _, _;
                        return (
                          _(
                            null == (_ = _.context)
                              ? void 0
                              : _.elements.floating,
                            _,
                          ) ||
                          _(
                            null == (_ = _.context)
                              ? void 0
                              : _.elements.domReference,
                            _,
                          )
                        );
                      }) ||
                        _(_.nodesRef.current, _).find((_) => {
                          var _, _, _;
                          return (
                            [
                              null == (_ = _.context)
                                ? void 0
                                : _.elements.floating,
                              _(
                                null == (_ = _.context)
                                  ? void 0
                                  : _.elements.floating,
                              ),
                            ].includes(_) ||
                            (null == (_ = _.context)
                              ? void 0
                              : _.elements.domReference) === _
                          );
                        })))
                  );
                if (_ && _ && _(_(_)) === _(_).body) {
                  (0, _._)(_) && _.focus();
                  const _ = _.current,
                    _ = _(),
                    _ = _[_] || _[_.length - 1] || _;
                  (0, _._)(_) && __webpack_require__.focus();
                }
                (!_ && _) ||
                  !_ ||
                  !_ ||
                  _.current ||
                  _ === _() ||
                  ((_.current = !0), _(!1, _, "focus-out"));
              });
            }
          }, [_, _, _, _, _, _, _, _, _, _, _, _, _]);
        const _ = _.useRef(null),
          _ = _.useRef(null),
          _ = _([_, null == _ ? void 0 : _.beforeInsideRef]),
          _ = _([_, null == _ ? void 0 : _.afterInsideRef]);
        function _(_) {
          return !_ && _ && _
            ? (0, _.jsx)(_, {
                ref: "start" === _ ? _ : _,
                onClick: (_) => _(!1, _.nativeEvent),
                children: "string" == typeof _ ? _ : "Dismiss",
              })
            : null;
        }
        _.useEffect(() => {
          var _;
          if (_) return;
          if (!_) return;
          const _ = Array.from(
              (null == _ || null == (_ = _.portalNode)
                ? void 0
                : _.querySelectorAll("[" + _("portal") + "]")) || [],
            ),
            _ =
              _ && !_
                ? _(null == _ ? void 0 : _.nodesRef.current, _()).map((_) => {
                    var _;
                    return null == (_ = _.context)
                      ? void 0
                      : _.elements.floating;
                  })
                : [],
            _ = [
              _,
              ..._,
              ..._,
              _.current,
              _.current,
              _.current,
              _.current,
              null == _ ? void 0 : _.beforeOutsideRef.current,
              null == _ ? void 0 : _.afterOutsideRef.current,
              _.current.includes("reference") || _ ? _ : null,
            ].filter((_) => null != _),
            _ = _ || _ ? _(_, !_, _) : _(_);
          return () => {
            _();
          };
        }, [_, _, _, _, _, _, _, _, _, _, _]),
          _(() => {
            if (_ || !(0, _._)(_)) return;
            const _ = _(_(_));
            queueMicrotask(() => {
              const _ = _(_),
                _ = _.current,
                _ = ("number" == typeof _ ? _[_] : _.current) || _,
                _ = _(_, _);
              _ ||
                _ ||
                !_ ||
                _(_, {
                  preventScroll: _ === _,
                });
            });
          }, [_, _, _, _, _, _]),
          _(() => {
            if (_ || !_) return;
            let _ = !1,
              _ = !1;
            const _ = _(_),
              _ = _(_);
            let _ = _.current.openEvent;
            var _;
            function _(_) {
              let { open: _, reason: _, event: _, nested: _ } = _;
              if (
                (_ && (_ = _),
                "escape-key" === _ && (_ = !0),
                ["hover", "safe-polygon"].includes(_) &&
                  "mouseleave" === _.type &&
                  (_.current = !0),
                "outside-press" === _)
              )
                if (_) (_.current = !1), (_ = !0);
                else if (_(_) || _(_)) _.current = !1;
                else {
                  let _ = !1;
                  document.createElement("div").focus({
                    get preventScroll() {
                      return (_ = !0), !1;
                    },
                  }),
                    _ ? ((_.current = !1), (_ = !0)) : (_.current = !0);
                }
            }
            (_ = _),
              (_ = _.filter((_) => _.isConnected)),
              _ &&
                "body" !== (0, _._)(_) &&
                (_.push(_), _.length > _ && (_ = _.slice(-_))),
              _._("openchange", _);
            const _ = __webpack_require__.createElement("span");
            return (
              _.setAttribute("tabindex", "-1"),
              _.setAttribute("aria-hidden", "true"),
              Object.assign(_.style, _),
              _ && _ && _.insertAdjacentElement("afterend", _),
              () => {
                _.off("openchange", _);
                const _ = _(_),
                  _ =
                    _(_, _) ||
                    (_ &&
                      _(_.nodesRef.current, _()).some((_) => {
                        var _;
                        return _(
                          null == (_ = _.context)
                            ? void 0
                            : _.elements.floating,
                          _,
                        );
                      }));
                (_ || (_ && ["click", "mousedown"].includes(_.type))) &&
                  (_ = !0);
                const _ =
                  "boolean" == typeof _.current
                    ? _ && _
                      ? _
                      : _() || _
                    : _.current.current || _;
                queueMicrotask(() => {
                  const _ = (function (_) {
                    const _ = _();
                    return _(_, _) ? _ : _(_, _)[0] || _;
                  })(_);
                  _.current &&
                    !_.current &&
                    (0, _._)(_) &&
                    (_ === _ || _ === _.body || _) &&
                    _.focus({
                      preventScroll: _,
                    }),
                    _.remove();
                });
              }
            );
          }, [_, _, _, _, _, _, _, _, _, _]),
          _.useEffect(() => {
            queueMicrotask(() => {
              _.current = !1;
            });
          }, [_]),
          _(() => {
            if (!_ && _)
              return (
                _.setFocusManagerState({
                  modal: _,
                  closeOnFocusOut: _,
                  open: _,
                  onOpenChange: _,
                  domReference: _,
                }),
                () => {
                  _.setFocusManagerState(null);
                }
              );
          }, [_, _, _, _, _, _, _]),
          _(() => {
            if (_) return;
            if (!_) return;
            if ("function" != typeof MutationObserver) return;
            if (_) return;
            const _ = () => {
              const _ = _.getAttribute("tabindex"),
                _ = _(),
                _ = _(_(_)),
                _ = _.indexOf(_);
              -1 !== _ && (_.current = _),
                _.current.includes("floating") || (_ !== _ && 0 === _.length)
                  ? "0" !== _ && _.setAttribute("tabindex", "0")
                  : "-1" !== _ && _.setAttribute("tabindex", "-1");
            };
            _();
            const _ = new MutationObserver(_);
            return (
              _.observe(_, {
                childList: !0,
                subtree: !0,
                attributes: !0,
              }),
              () => {
                _.disconnect();
              }
            );
          }, [_, _, _, _, _, _, _]);
        const _ = !_ && _ && (!_ || !_) && (_ || _);
        return (0, _.jsxs)(_.Fragment, {
          children: [
            _ &&
              (0, _.jsx)(_, {
                "data-type": "inside",
                ref: _,
                onFocus: (_) => {
                  if (_) {
                    const _ = _();
                    _("reference" === _[0] ? _[0] : _[_.length - 1]);
                  } else if (null != _ && _.preserveTabOrder && _.portalNode)
                    if (((_.current = !1), _(_, _.portalNode))) {
                      const _ = _() || _;
                      null == _ || _.focus();
                    } else {
                      var _;
                      null == (_ = _.beforeOutsideRef.current) || _.focus();
                    }
                },
              }),
            !_ && _("start"),
            __webpack_require__,
            _("end"),
            _ &&
              (0, _.jsx)(_, {
                "data-type": "inside",
                ref: _,
                onFocus: (_) => {
                  if (_) _(_()[0]);
                  else if (null != _ && _.preserveTabOrder && _.portalNode)
                    if ((_ && (_.current = !0), _(_, _.portalNode))) {
                      const _ = _() || _;
                      null == _ || _.focus();
                    } else {
                      var _;
                      null == (_ = _.afterOutsideRef.current) || _.focus();
                    }
                },
              }),
          ],
        });
      }
      function _(_) {
        return (0, _._)(_.target) && "BUTTON" === _.target.tagName;
      }
      function _(_) {
        return _(_);
      }
      function _(_, _) {
        void 0 === _ && (_ = {});
        const {
            open: __webpack_require__,
            onOpenChange: _,
            dataRef: _,
            elements: { domReference: _ },
          } = _,
          {
            enabled: _ = !0,
            event: _ = "click",
            toggle: _ = !0,
            ignoreMouse: _ = !1,
            keyboardHandlers: _ = !0,
            stickIfOpen: _ = !0,
          } = _,
          _ = _.useRef(),
          _ = _.useRef(!1),
          _ = _.useMemo(
            () => ({
              onPointerDown(_) {
                _.current = _.pointerType;
              },
              onMouseDown(_) {
                const _ = _.current;
                0 === _.button &&
                  "click" !== _ &&
                  ((_(_, !0) && _) ||
                    (!__webpack_require__ ||
                    !_ ||
                    (_.current.openEvent &&
                      _ &&
                      "mousedown" !== _.current.openEvent.type)
                      ? (_.preventDefault(), _(!0, _.nativeEvent, "click"))
                      : _(!1, _.nativeEvent, "click")));
              },
              onClick(_) {
                const _ = _.current;
                "mousedown" === _ && _.current
                  ? (_.current = void 0)
                  : (_(_, !0) && _) ||
                    (!__webpack_require__ ||
                    !_ ||
                    (_.current.openEvent &&
                      _ &&
                      "click" !== _.current.openEvent.type)
                      ? _(!0, _.nativeEvent, "click")
                      : _(!1, _.nativeEvent, "click"));
              },
              onKeyDown(_) {
                (_.current = void 0),
                  _.defaultPrevented ||
                    !_ ||
                    _(_) ||
                    (" " !== _.key ||
                      _(_) ||
                      (_.preventDefault(), (_.current = !0)),
                    "Enter" === _.key &&
                      _(!__webpack_require__ || !_, _.nativeEvent, "click"));
              },
              onKeyUp(_) {
                _.defaultPrevented ||
                  !_ ||
                  _(_) ||
                  _(_) ||
                  (" " === _.key &&
                    _.current &&
                    ((_.current = !1),
                    _(!__webpack_require__ || !_, _.nativeEvent, "click")));
              },
            }),
            [_, _, _, _, _, _, __webpack_require__, _, _],
          );
        return _.useMemo(
          () =>
            _
              ? {
                  reference: _,
                }
              : {},
          [_, _],
        );
      }
      const _ = {
          pointerdown: "onPointerDown",
          mousedown: "onMouseDown",
          click: "onClick",
        },
        _ = {
          pointerdown: "onPointerDownCapture",
          mousedown: "onMouseDownCapture",
          click: "onClickCapture",
        },
        _ = (_) => {
          var _, _;
          return {
            escapeKey:
              "boolean" == typeof _
                ? _
                : null != (_ = null == _ ? void 0 : _.escapeKey) && _,
            outsidePress:
              "boolean" == typeof _
                ? _
                : null == (_ = null == _ ? void 0 : _.outsidePress) || _,
          };
        };
      function _(_, _) {
        void 0 === _ && (_ = {});
        const {
            open: __webpack_require__,
            onOpenChange: _,
            elements: _,
            dataRef: _,
          } = _,
          {
            enabled: _ = !0,
            escapeKey: _ = !0,
            outsidePress: _ = !0,
            outsidePressEvent: _ = "pointerdown",
            referencePress: _ = !1,
            referencePressEvent: _ = "pointerdown",
            ancestorScroll: _ = !1,
            bubbles: _,
            capture: _,
          } = _,
          _ = _(),
          _ = _("function" == typeof _ ? _ : () => !1),
          _ = "function" == typeof _ ? _ : _,
          _ = _.useRef(!1),
          _ = _.useRef(!1),
          { escapeKey: _, outsidePress: _ } = _(_),
          { escapeKey: _, outsidePress: _ } = _(_),
          _ = _.useRef(!1),
          _ = _((_) => {
            var _;
            if (!__webpack_require__ || !_ || !_ || "Escape" !== _.key) return;
            if (_.current) return;
            const _ =
                null == (_ = _.current.floatingContext) ? void 0 : _.nodeId,
              _ = _ ? _(_.nodesRef.current, _) : [];
            if (!_ && (_.stopPropagation(), _.length > 0)) {
              let _ = !0;
              if (
                (_.forEach((_) => {
                  var _;
                  null == (_ = _.context) ||
                    !_.open ||
                    _.context.dataRef.current.__escapeKeyBubbles ||
                    (_ = !1);
                }),
                !_)
              )
                return;
            }
            _(
              !1,
              (function (_) {
                return "nativeEvent" in _;
              })(_)
                ? _.nativeEvent
                : _,
              "escape-key",
            );
          }),
          _ = _((_) => {
            var _;
            const _ = () => {
              var _;
              _(_), null == (_ = _(_)) || _.removeEventListener("keydown", _);
            };
            null == (_ = _(_)) || _.addEventListener("keydown", _);
          }),
          _ = _((_) => {
            var _;
            const _ = _.current;
            _.current = !1;
            const _ = _.current;
            if (((_.current = !1), "click" === _ && _)) return;
            if (_) return;
            if ("function" == typeof _ && !_(_)) return;
            const _ = _(_),
              _ = "[" + _("inert") + "]",
              _ = _(_.floating).querySelectorAll(_);
            let _ = (0, _._)(_) ? _ : null;
            for (; _ && !(0, _._)(_); ) {
              const _ = (0, _._)(_);
              if ((0, _._)(_) || !(0, _._)(_)) break;
              _ = _;
            }
            if (
              _.length &&
              (0, _._)(_) &&
              !_.matches("html,body") &&
              !_(_, _.floating) &&
              Array.from(_).every((_) => !_(_, _))
            )
              return;
            if ((0, _._)(_) && _) {
              const _ = (0, _._)(_),
                _ = (0, _._)(_),
                _ = /auto|scroll/,
                _ = _ || _.test(_.overflowX),
                _ = _ || _.test(_.overflowY),
                _ = _ && _.clientWidth > 0 && _.scrollWidth > _.clientWidth,
                _ = _ && _.clientHeight > 0 && _.scrollHeight > _.clientHeight,
                _ = "rtl" === _.direction,
                _ =
                  _ &&
                  (_
                    ? _.offsetX <= _.offsetWidth - _.clientWidth
                    : _.offsetX > _.clientWidth),
                _ = _ && _.offsetY > _.clientHeight;
              if (_ || _) return;
            }
            const _ =
                null == (_ = _.current.floatingContext) ? void 0 : _.nodeId,
              _ =
                _ &&
                _(_.nodesRef.current, _).some((_) => {
                  var _;
                  return _(
                    _,
                    null == (_ = _.context) ? void 0 : _.elements.floating,
                  );
                });
            if (_(_, _.floating) || _(_, _.domReference) || _) return;
            const _ = _ ? _(_.nodesRef.current, _) : [];
            if (_.length > 0) {
              let _ = !0;
              if (
                (_.forEach((_) => {
                  var _;
                  null == (_ = _.context) ||
                    !_.open ||
                    _.context.dataRef.current.__outsidePressBubbles ||
                    (_ = !1);
                }),
                !_)
              )
                return;
            }
            _(!1, _, "outside-press");
          }),
          _ = _((_) => {
            var _;
            const _ = () => {
              var _;
              _(_), null == (_ = _(_)) || _.removeEventListener(_, _);
            };
            null == (_ = _(_)) || _.addEventListener(_, _);
          });
        _.useEffect(() => {
          if (!__webpack_require__ || !_) return;
          (_.current.__escapeKeyBubbles = _),
            (_.current.__outsidePressBubbles = _);
          let _ = -1;
          function _(_) {
            _(!1, _, "ancestor-scroll");
          }
          function _() {
            window.clearTimeout(_), (_.current = !0);
          }
          function _() {
            _ = window.setTimeout(
              () => {
                _.current = !1;
              },
              (0, _._)() ? 5 : 0,
            );
          }
          const _ = _(_.floating);
          _ &&
            (_.addEventListener("keydown", _ ? _ : _, _),
            _.addEventListener("compositionstart", _),
            _.addEventListener("compositionend", _)),
            _ && _.addEventListener(_, _ ? _ : _, _);
          let _ = [];
          return (
            _ &&
              ((0, _._)(_.domReference) && (_ = (0, _._)(_.domReference)),
              (0, _._)(_.floating) && (_ = _.concat((0, _._)(_.floating))),
              !(0, _._)(_.reference) &&
                _.reference &&
                _.reference.contextElement &&
                (_ = _.concat((0, _._)(_.reference.contextElement)))),
            (_ = _.filter((_) => {
              var _;
              return (
                _ !== (null == (_ = _.defaultView) ? void 0 : _.visualViewport)
              );
            })),
            _.forEach((_) => {
              _.addEventListener("scroll", _, {
                passive: !0,
              });
            }),
            () => {
              _ &&
                (_.removeEventListener("keydown", _ ? _ : _, _),
                _.removeEventListener("compositionstart", _),
                _.removeEventListener("compositionend", _)),
                _ && _.removeEventListener(_, _ ? _ : _, _),
                _.forEach((_) => {
                  _.removeEventListener("scroll", _);
                }),
                window.clearTimeout(_);
            }
          );
        }, [
          _,
          _,
          _,
          _,
          _,
          __webpack_require__,
          _,
          _,
          _,
          _,
          _,
          _,
          _,
          _,
          _,
          _,
          _,
        ]),
          _.useEffect(() => {
            _.current = !1;
          }, [_, _]);
        const _ = _.useMemo(
            () => ({
              onKeyDown: _,
              ...(_ && {
                [_[_]]: (_) => {
                  _(!1, _.nativeEvent, "reference-press");
                },
                ...("click" !== _ && {
                  onClick(_) {
                    _(!1, _.nativeEvent, "reference-press");
                  },
                }),
              }),
            }),
            [_, _, _, _],
          ),
          _ = _.useMemo(
            () => ({
              onKeyDown: _,
              onMouseDown() {
                _.current = !0;
              },
              onMouseUp() {
                _.current = !0;
              },
              [_[_]]: () => {
                _.current = !0;
              },
            }),
            [_, _],
          );
        return _.useMemo(
          () =>
            _
              ? {
                  reference: _,
                  floating: _,
                }
              : {},
          [_, _, _],
        );
      }
      function _(_) {
        void 0 === _ && (_ = {});
        const { nodeId: _ } = _,
          _ = (function (_) {
            const { open: _ = !1, onOpenChange: _, elements: _ } = _,
              _ = _(),
              _ = _.useRef({}),
              [_] = _.useState(() => _()),
              _ = null != _(),
              [_, _] = _.useState(_.reference),
              _ = _((_, _, _) => {
                (_.current.openEvent = _ ? _ : void 0),
                  _.emit("openchange", {
                    open: _,
                    event: _,
                    reason: _,
                    nested: _,
                  }),
                  null == _ || __webpack_require__(_, _, _);
              }),
              _ = _.useMemo(
                () => ({
                  setPositionReference: _,
                }),
                [],
              ),
              _ = _.useMemo(
                () => ({
                  reference: _ || _.reference || null,
                  floating: _.floating || null,
                  domReference: _.reference,
                }),
                [_, _.reference, _.floating],
              );
            return _.useMemo(
              () => ({
                dataRef: _,
                open: _,
                onOpenChange: _,
                elements: _,
                events: _,
                floatingId: _,
                refs: _,
              }),
              [_, _, _, _, _, _],
            );
          })({
            ..._,
            elements: {
              reference: null,
              floating: null,
              ..._.elements,
            },
          }),
          _ = _.rootContext || _,
          _ = _.elements,
          [_, _] = _.useState(null),
          [_, _] = _.useState(null),
          _ = (null == _ ? void 0 : _.domReference) || _,
          _ = _.useRef(null),
          _ = _();
        _(() => {
          _ && (_.current = _);
        }, [_]);
        const _ = (0, _._)({
            ..._,
            elements: {
              ..._,
              ...(_ && {
                reference: _,
              }),
            },
          }),
          _ = _.useCallback(
            (_) => {
              const _ = (0, _._)(_)
                ? {
                    getBoundingClientRect: () => _.getBoundingClientRect(),
                    contextElement: _,
                  }
                : _;
              _(_), _.refs.setReference(_);
            },
            [_.refs],
          ),
          _ = _.useCallback(
            (_) => {
              ((0, _._)(_) || null === _) && ((_.current = _), _(_)),
                ((0, _._)(_.refs.reference.current) ||
                  null === _.refs.reference.current ||
                  (null !== _ && !(0, _._)(_))) &&
                  _.refs.setReference(_);
            },
            [_.refs],
          ),
          _ = _.useMemo(
            () => ({
              ..._.refs,
              setReference: _,
              setPositionReference: _,
              domReference: _,
            }),
            [_.refs, _, _],
          ),
          _ = _.useMemo(
            () => ({
              ..._.elements,
              domReference: _,
            }),
            [_.elements, _],
          ),
          _ = _.useMemo(
            () => ({
              ..._,
              ..._,
              refs: _,
              elements: _,
              nodeId: _,
            }),
            [_, _, _, _, _],
          );
        return (
          _(() => {
            _.dataRef.current.floatingContext = _;
            const _ =
              null == _ ? void 0 : _.nodesRef.current.find((_) => _._ === _);
            _ && (_.context = _);
          }),
          _.useMemo(
            () => ({
              ..._,
              context: _,
              refs: _,
              elements: _,
            }),
            [_, _, _, _],
          )
        );
      }
      function _(_, _) {
        void 0 === _ && (_ = {});
        const {
            open: __webpack_require__,
            onOpenChange: _,
            events: _,
            dataRef: _,
            elements: _,
          } = _,
          { enabled: _ = !0, visibleOnly: _ = !0 } = _,
          _ = _.useRef(!1),
          _ = _.useRef(-1),
          _ = _.useRef(!0);
        _.useEffect(() => {
          if (!_) return;
          const _ = (0, _._)(_.domReference);
          function _() {
            !__webpack_require__ &&
              (0, _._)(_.domReference) &&
              _.domReference === _(_(_.domReference)) &&
              (_.current = !0);
          }
          function _() {
            _.current = !0;
          }
          return (
            _.addEventListener("blur", _),
            _.addEventListener("keydown", _, !0),
            () => {
              _.removeEventListener("blur", _),
                _.removeEventListener("keydown", _, !0);
            }
          );
        }, [_.domReference, __webpack_require__, _]),
          _.useEffect(() => {
            if (_)
              return (
                _._("openchange", _),
                () => {
                  _.off("openchange", _);
                }
              );
            function _(_) {
              let { reason: _ } = _;
              ("reference-press" !== _ && "escape-key" !== _) ||
                (_.current = !0);
            }
          }, [_, _]),
          _.useEffect(
            () => () => {
              _(_);
            },
            [],
          );
        const _ = _.useMemo(
          () => ({
            onPointerDown(_) {
              _(_.nativeEvent) || (_.current = !1);
            },
            onMouseLeave() {
              _.current = !1;
            },
            onFocus(_) {
              if (_.current) return;
              const _ = _(_.nativeEvent);
              if (_ && (0, _._)(_))
                try {
                  if (
                    _() &&
                    _().toLowerCase().startsWith("mac") &&
                    !navigator.maxTouchPoints
                  )
                    throw Error();
                  if (!_.matches(":focus-visible")) return;
                } catch (_) {
                  if (!_.current && !_(_)) return;
                }
              _(!0, _.nativeEvent, "focus");
            },
            onBlur(_) {
              _.current = !1;
              const _ = _.relatedTarget,
                _ = _.nativeEvent,
                _ =
                  (0, _._)(_) &&
                  _.hasAttribute(_("focus-guard")) &&
                  "outside" === _.getAttribute("data-type");
              _.current = window.setTimeout(() => {
                var _;
                const _ = _(
                  _.domReference ? _.domReference.ownerDocument : document,
                );
                (_ || _ !== _.domReference) &&
                  (_(
                    null == (_ = _.current.floatingContext)
                      ? void 0
                      : _.refs.floating.current,
                    _,
                  ) ||
                    _(_.domReference, _) ||
                    _ ||
                    _(!1, _, "focus"));
              });
            },
          }),
          [_, _.domReference, _, _],
        );
        return _.useMemo(
          () =>
            _
              ? {
                  reference: _,
                }
              : {},
          [_, _],
        );
      }
      const _ = "active",
        _ = "selected";
      function _(_, _, _) {
        const _ = new Map(),
          _ = "item" === _;
        let _ = _;
        if (_ && _) {
          const { [_]: _, [_]: _, ..._ } = _;
          _ = _;
        }
        return {
          ...("floating" === _ && {
            tabIndex: -1,
            [_]: "",
          }),
          ..._,
          ..._.map((_) => {
            const _ = _ ? _[_] : null;
            return "function" == typeof _ ? (_ ? _(_) : null) : _;
          })
            .concat(_)
            .reduce(
              (_, _) =>
                _
                  ? (Object.entries(_).forEach((_) => {
                      let [_, _] = _;
                      var _;
                      (_ && [_, _].includes(_)) ||
                        (0 === __webpack_require__.indexOf("on")
                          ? (_.has(_) || _.set(_, []),
                            "function" == typeof _ &&
                              (null == (_ = _.get(_)) || _.push(_),
                              (_[_] = function () {
                                for (
                                  var _,
                                    _ = arguments.length,
                                    _ = new Array(_),
                                    _ = 0;
                                  _ < _;
                                  _++
                                )
                                  _[_] = arguments[_];
                                return null == (_ = _.get(_))
                                  ? void 0
                                  : _.map((_) => _(..._)).find(
                                      (_) => void 0 !== _,
                                    );
                              })))
                          : (_[_] = _));
                    }),
                    _)
                  : _,
              {},
            ),
        };
      }
      function _(_) {
        void 0 === _ && (_ = []);
        const _ = _.map((_) => (null == _ ? void 0 : _.reference)),
          _ = _.map((_) => (null == _ ? void 0 : _.floating)),
          _ = _.map((_) => (null == _ ? void 0 : _.item)),
          _ = _.useCallback((_) => _(_, _, "reference"), _),
          _ = _.useCallback((_) => _(_, _, "floating"), _),
          _ = _.useCallback((_) => _(_, _, "item"), _);
        return _.useMemo(
          () => ({
            getReferenceProps: _,
            getFloatingProps: _,
            getItemProps: _,
          }),
          [_, _, _],
        );
      }
      const _ = "Escape";
      function _(_, _, _) {
        switch (_) {
          case "vertical":
            return _;
          case "horizontal":
            return _;
          default:
            return _ || _;
        }
      }
      function _(_, _) {
        return _(_, _ === _ || _ === _, _ === _ || _ === _);
      }
      function _(_, _, _) {
        return (
          _(_, _ === _, _ ? _ === _ : _ === _) ||
          "Enter" === _ ||
          " " === _ ||
          "" === _
        );
      }
      function _(_, _, _) {
        return _(_, _ ? _ === _ : _ === _, _ === _);
      }
      function _(_, _, _, _) {
        return "both" === _ || ("horizontal" === _ && _ && _ > 1)
          ? _ === _
          : _(_, _ ? _ === _ : _ === _, _ === _);
      }
      function _(_, _) {
        const { open: __webpack_require__, onOpenChange: _, elements: _ } = _,
          {
            listRef: _,
            activeIndex: _,
            onNavigate: _ = () => {},
            enabled: _ = !0,
            selectedIndex: _ = null,
            allowEscape: _ = !1,
            loop: _ = !1,
            nested: _ = !1,
            rtl: _ = !1,
            virtual: _ = !1,
            focusItemOnOpen: _ = "auto",
            focusItemOnHover: _ = !0,
            openOnArrowKeyDown: _ = !0,
            disabledIndices: _,
            orientation: _ = "vertical",
            cols: _ = 1,
            scrollItemIntoView: _ = !0,
            virtualItemRef: _,
            itemSizes: _,
            dense: _ = !1,
          } = _;
        const _ = _(_(_.floating)),
          _ = _(),
          _ = _();
        _(() => {
          _.dataRef.current.orientation = _;
        }, [_, _]);
        const _ = _(() => {
            _(-1 === _.current ? null : _.current);
          }),
          _ = _(_.domReference),
          _ = _.useRef(_),
          _ = _.useRef(null != _ ? _ : -1),
          _ = _.useRef(null),
          _ = _.useRef(!0),
          _ = _.useRef(_),
          _ = _.useRef(!!_.floating),
          _ = _.useRef(__webpack_require__),
          _ = _.useRef(!1),
          _ = _.useRef(!1),
          _ = _(_),
          _ = _(__webpack_require__),
          _ = _(_),
          _ = _(_),
          [_, _] = _.useState(),
          [_, _] = _.useState(),
          _ = _(() => {
            function _(_) {
              _
                ? (_(_._),
                  null == _ || _.events.emit("virtualfocus", _),
                  _ && (_.current = _))
                : _(_, {
                    sync: _.current,
                    preventScroll: !0,
                  });
            }
            const _ = _.current[_.current];
            _ && _(_);
            (_.current ? (_) => _() : requestAnimationFrame)(() => {
              const _ = _.current[_.current] || _;
              if (!_) return;
              _ || _(_);
              const _ = _.current;
              _ &&
                _ &&
                (_.current || !_.current) &&
                (null == _.scrollIntoView ||
                  __webpack_require__.scrollIntoView(
                    "boolean" == typeof _
                      ? {
                          block: "nearest",
                          inline: "nearest",
                        }
                      : _,
                  ));
            });
          });
        _(() => {
          _ &&
            (__webpack_require__ && _.floating
              ? _.current &&
                null != _ &&
                ((_.current = !0), (_.current = _), _())
              : _.current && ((_.current = -1), _.current()));
        }, [_, __webpack_require__, _.floating, _, _]),
          _(() => {
            if (_ && __webpack_require__ && _.floating)
              if (null == _) {
                if (((_.current = !1), null != _.current)) return;
                if (
                  (_.current && ((_.current = -1), _()),
                  (!_.current || !_.current) &&
                    _.current &&
                    (null != _.current ||
                      (!0 === _.current && null == _.current)))
                ) {
                  let _ = 0;
                  const _ = () => {
                    if (null == _.current[0]) {
                      if (_ < 2) {
                        (_ ? requestAnimationFrame : queueMicrotask)(_);
                      }
                      _++;
                    } else
                      (_.current =
                        null == _.current || _(_.current, _, _) || _
                          ? _(_, _.current)
                          : _(_, _.current)),
                        (_.current = null),
                        _();
                  };
                  _();
                }
              } else _(_, _) || ((_.current = _), _(), (_.current = !1));
          }, [_, __webpack_require__, _.floating, _, _, _, _, _, _, _, _, _]),
          _(() => {
            var _;
            if (!_ || _.floating || !_ || _ || !_.current) return;
            const _ = _.nodesRef.current,
              _ =
                null == (_ = _.find((_) => _._ === _)) ||
                null == (_ = _.context)
                  ? void 0
                  : _.elements.floating,
              _ = _(_(_.floating)),
              _ = _.some((_) => _.context && _(_.context.elements.floating, _));
            _ &&
              !_ &&
              _.current &&
              __webpack_require__.focus({
                preventScroll: !0,
              });
          }, [_, _.floating, _, _, _]),
          _(() => {
            if (_ && _ && _ && !_)
              return (
                _.events._("virtualfocus", _),
                () => {
                  _.events.off("virtualfocus", _);
                }
              );
            function _(_) {
              _(_._), _ && (_.current = _);
            }
          }, [_, _, _, _, _]),
          _(() => {
            (_.current = _),
              (_.current = __webpack_require__),
              (_.current = !!_.floating);
          }),
          _(() => {
            __webpack_require__ || (_.current = null);
          }, [__webpack_require__]);
        const _ = null != _,
          _ = _.useMemo(() => {
            function _(_) {
              if (!__webpack_require__) return;
              const _ = _.current.indexOf(_);
              -1 !== _ && _.current !== _ && ((_.current = _), _());
            }
            return {
              onFocus(_) {
                let { currentTarget: __webpack_require__ } = _;
                (_.current = !0), _(__webpack_require__);
              },
              onClick: (_) => {
                let { currentTarget: _ } = _;
                return _.focus({
                  preventScroll: !0,
                });
              },
              ...(_ && {
                onMouseMove(_) {
                  let { currentTarget: __webpack_require__ } = _;
                  (_.current = !0), (_.current = !1), _(__webpack_require__);
                },
                onPointerLeave(_) {
                  let { pointerType: _ } = _;
                  var _;
                  _.current &&
                    "touch" !== _ &&
                    ((_.current = !0),
                    (_.current = -1),
                    _(),
                    _ ||
                      null == (_ = _.current) ||
                      __webpack_require__.focus({
                        preventScroll: !0,
                      }));
                },
              }),
            };
          }, [__webpack_require__, _, _, _, _, _]),
          _ = _((_) => {
            if (((_.current = !1), (_.current = !0), 229 === _.which)) return;
            if (!_.current && _.currentTarget === _.current) return;
            if (_ && _(_.key, _, _, _))
              return (
                _(_),
                _(!1, _.nativeEvent, "list-navigation"),
                void (
                  (0, _._)(_.domReference) &&
                  (_
                    ? null == _ || _.events.emit("virtualfocus", _.domReference)
                    : _.domReference.focus())
                )
              );
            const _ = _.current,
              _ = _(_, _),
              _ = _(_, _);
            if (
              (_ ||
                ("Home" === _.key && (_(_), (_.current = _), _()),
                "End" === _.key && (_(_), (_.current = _), _())),
              _ > 1)
            ) {
              const _ =
                  _ ||
                  Array.from(
                    {
                      length: _.current.length,
                    },
                    () => ({
                      width: 1,
                      height: 1,
                    }),
                  ),
                _ = _(_, _, _),
                _ = __webpack_require__.findIndex(
                  (_) => null != _ && !_(_.current, _, _),
                ),
                _ = __webpack_require__.reduce(
                  (_, _, _) => (null == _ || _(_.current, _, _) ? _ : _),
                  -1,
                ),
                _ =
                  _[
                    _(
                      {
                        current: __webpack_require__.map((_) =>
                          null != _ ? _.current[_] : null,
                        ),
                      },
                      {
                        event: _,
                        orientation: _,
                        loop: _,
                        rtl: _,
                        cols: _,
                        disabledIndices: _(
                          [
                            ...(_ ||
                              _.current.map((_, _) =>
                                _(_.current, _) ? _ : void 0,
                              )),
                            void 0,
                          ],
                          _,
                        ),
                        minIndex: _,
                        maxIndex: _,
                        prevIndex: _(
                          _.current > _ ? _ : _.current,
                          _,
                          _,
                          _,
                          _.key === _
                            ? "bl"
                            : _.key === (_ ? _ : _)
                              ? "tr"
                              : "tl",
                        ),
                        stopEvent: !0,
                      },
                    )
                  ];
              if ((null != _ && ((_.current = _), _()), "both" === _)) return;
            }
            if (_(_.key, _)) {
              if (
                (_(_),
                _ && !_ && _(_.currentTarget.ownerDocument) === _.currentTarget)
              )
                return (_.current = _(_.key, _, _) ? _ : _), void _();
              _(_.key, _, _)
                ? (_.current = _
                    ? _ >= _
                      ? _ && _ !== _.current.length
                        ? -1
                        : _
                      : _(_, {
                          startingIndex: _,
                          disabledIndices: _,
                        })
                    : Math.min(
                        _,
                        _(_, {
                          startingIndex: _,
                          disabledIndices: _,
                        }),
                      ))
                : (_.current = _
                    ? _ <= _
                      ? _ && -1 !== _
                        ? _.current.length
                        : _
                      : _(_, {
                          startingIndex: _,
                          decrement: !0,
                          disabledIndices: _,
                        })
                    : Math.max(
                        _,
                        _(_, {
                          startingIndex: _,
                          decrement: !0,
                          disabledIndices: _,
                        }),
                      )),
                _(_, _.current) && (_.current = -1),
                _();
            }
          }),
          _ = _.useMemo(
            () =>
              _ &&
              __webpack_require__ &&
              _ && {
                "aria-activedescendant": _ || _,
              },
            [_, __webpack_require__, _, _, _],
          ),
          _ = _.useMemo(
            () => ({
              "aria-orientation": "both" === _ ? void 0 : _,
              ...(_ ? {} : _),
              onKeyDown: _,
              onPointerMove() {
                _.current = !0;
              },
            }),
            [_, _, _, _],
          ),
          _ = _.useMemo(() => {
            function _(_) {
              "auto" === _ && _(_.nativeEvent) && (_.current = !0);
            }
            function _(_) {
              (_.current = _),
                "auto" === _ && _(_.nativeEvent) && (_.current = !0);
            }
            return {
              ..._,
              onKeyDown(_) {
                var _;
                _.current = !1;
                const _ = _.key.startsWith("Arrow"),
                  _ = ["Home", "End"].includes(_.key),
                  _ = _ || _,
                  _ =
                    null == _ ||
                    null == (_ = _.nodesRef.current.find((_) => _._ === _)) ||
                    null == (_ = _.context) ||
                    null == (_ = _.dataRef)
                      ? void 0
                      : _.current.orientation,
                  _ = _(_.key, _, _),
                  _ = _(_.key, _, _, _),
                  _ = _(_.key, _, _),
                  _ = _(_.key, _),
                  _ = (_ ? _ : _) || "Enter" === _.key || "" === _.key.trim();
                if (_ && __webpack_require__) {
                  const _ =
                      null == _
                        ? void 0
                        : _.nodesRef.current.find((_) => null == _.parentId),
                    _ =
                      _ && _
                        ? (function (_, _) {
                            let _,
                              _ = -1;
                            return (
                              (function _(_, _) {
                                _ > _ && ((_ = _), (_ = _)),
                                  _(_, _).forEach((_) => {
                                    _(_._, _ + 1);
                                  });
                              })(_, 0),
                              _.find((_) => _._ === _)
                            );
                          })(_.nodesRef.current, _._)
                        : null;
                  if (_ && _ && _) {
                    const _ = new KeyboardEvent("keydown", {
                      key: _.key,
                      bubbles: !0,
                    });
                    if (_ || _) {
                      var _, _;
                      const _ =
                          (null == (_ = _.context)
                            ? void 0
                            : _.elements.domReference) === _.currentTarget,
                        _ =
                          _ && !_
                            ? null == (_ = _.context)
                              ? void 0
                              : _.elements.domReference
                            : _
                              ? _.current.find(
                                  (_) => (null == _ ? void 0 : _._) === _,
                                )
                              : null;
                      _ && (_(_), _.dispatchEvent(_), _(void 0));
                    }
                    var _;
                    if ((_ || _) && _.context)
                      if (
                        _.context.open &&
                        _.parentId &&
                        _.currentTarget !== _.context.elements.domReference
                      )
                        return (
                          _(_),
                          void (
                            null == (_ = _.context.elements.domReference) ||
                            _.dispatchEvent(_)
                          )
                        );
                  }
                  return _(_);
                }
                if (_ || _ || !_) {
                  if (_) {
                    const _ = _(_.key, _);
                    _.current = _ && _ ? null : _.key;
                  }
                  _
                    ? _ &&
                      (_(_),
                      _
                        ? ((_.current = _(_, _.current)), _())
                        : _(!0, _.nativeEvent, "list-navigation"))
                    : _ &&
                      (null != _ && (_.current = _),
                      _(_),
                      !_ && _ ? _(!0, _.nativeEvent, "list-navigation") : _(_),
                      _ && _());
                }
              },
              onFocus() {
                __webpack_require__ && !_ && ((_.current = -1), _());
              },
              onPointerDown: _,
              onPointerEnter: _,
              onMouseDown: _,
              onClick: _,
            };
          }, [
            _,
            _,
            _,
            _,
            _,
            _,
            _,
            _,
            _,
            _,
            __webpack_require__,
            _,
            _,
            _,
            _,
            _,
            _,
            _,
            _,
          ]);
        return _.useMemo(
          () =>
            _
              ? {
                  reference: _,
                  floating: _,
                  item: _,
                }
              : {},
          [_, _, _, _],
        );
      }
      const _ = new Map([
        ["select", "listbox"],
        ["combobox", "listbox"],
        ["label", !1],
      ]);
      function _(_, _) {
        var _;
        void 0 === _ && (_ = {});
        const { open: _, floatingId: _ } = _,
          { enabled: _ = !0, role: _ = "dialog" } = _,
          _ = null != (_ = _.get(_)) ? _ : _,
          _ = _(),
          _ = null != _(),
          _ = _.useMemo(
            () =>
              "tooltip" === _ || "label" === _
                ? {
                    ["aria-" + ("label" === _ ? "labelledby" : "describedby")]:
                      _ ? _ : void 0,
                  }
                : {
                    "aria-expanded": _ ? "true" : "false",
                    "aria-haspopup": "alertdialog" === _ ? "dialog" : _,
                    "aria-controls": _ ? _ : void 0,
                    ...("listbox" === _ && {
                      role: "combobox",
                    }),
                    ...("menu" === _ && {
                      _: _,
                    }),
                    ...("menu" === _ &&
                      _ && {
                        role: "menuitem",
                      }),
                    ...("select" === _ && {
                      "aria-autocomplete": "none",
                    }),
                    ...("combobox" === _ && {
                      "aria-autocomplete": "list",
                    }),
                  },
            [_, _, _, _, _, _],
          ),
          _ = _.useMemo(() => {
            const _ = {
              _: _,
              ...(_ && {
                role: _,
              }),
            };
            return "tooltip" === _ || "label" === _
              ? _
              : {
                  ..._,
                  ...("menu" === _ && {
                    "aria-labelledby": _,
                  }),
                };
          }, [_, _, _, _]),
          _ = _.useCallback(
            (_) => {
              let { active: _, selected: _ } = _;
              const _ = {
                role: "option",
                ...(_ && {
                  _: _ + "-option",
                }),
              };
              switch (_) {
                case "select":
                  return {
                    ..._,
                    "aria-selected": _ && _,
                  };
                case "combobox":
                  return {
                    ..._,
                    ...(_ && {
                      "aria-selected": !0,
                    }),
                  };
              }
              return {};
            },
            [_, _],
          );
        return _.useMemo(
          () =>
            _
              ? {
                  reference: _,
                  floating: _,
                  item: _,
                }
              : {},
          [_, _, _, _],
        );
      }
      function _(_, _) {
        var _;
        const { open: _, dataRef: _ } = _,
          {
            listRef: _,
            activeIndex: _,
            onMatch: _,
            onTypingChange: _,
            enabled: _ = !0,
            findMatch: _ = null,
            resetMs: _ = 750,
            ignoreKeys: _ = [],
            selectedIndex: _ = null,
          } = _,
          _ = _.useRef(-1),
          _ = _.useRef(""),
          _ = _.useRef(null != (_ = null != _ ? _ : _) ? _ : -1),
          _ = _.useRef(null),
          _ = _(_),
          _ = _(_),
          _ = _(_),
          _ = _(_);
        _(() => {
          _ && (_(_), (_.current = null), (_.current = ""));
        }, [_]),
          _(() => {
            var _;
            _ &&
              "" === _.current &&
              (_.current = null != (_ = null != _ ? _ : _) ? _ : -1);
          }, [_, _, _]);
        const _ = _((_) => {
            _
              ? _.current.typing || ((_.current.typing = _), _(_))
              : _.current.typing && ((_.current.typing = _), _(_));
          }),
          _ = _((_) => {
            function _(_, _, _) {
              const _ = _.current
                ? _.current(_, _)
                : _.find(
                    (_) =>
                      0 ===
                      (null == _
                        ? void 0
                        : _.toLocaleLowerCase().indexOf(
                            __webpack_require__.toLocaleLowerCase(),
                          )),
                  );
              return _ ? _.indexOf(_) : -1;
            }
            const _ = _.current;
            if (
              (_.current.length > 0 &&
                " " !== _.current[0] &&
                (-1 === _(_, _, _.current) ? _(!1) : " " === _.key && _(_)),
              null == _ ||
                _.current.includes(_.key) ||
                1 !== _.key.length ||
                _.ctrlKey ||
                _.metaKey ||
                _.altKey)
            )
              return;
            _ && " " !== _.key && (_(_), _(!0));
            __webpack_require__.every((_) => {
              var _, _;
              return (
                !_ ||
                (null == (_ = _[0]) ? void 0 : _.toLocaleLowerCase()) !==
                  (null == (_ = _[1])
                    ? void 0
                    : __webpack_require__.toLocaleLowerCase())
              );
            }) &&
              _.current === _.key &&
              ((_.current = ""), (_.current = _.current)),
              (_.current += _.key),
              _(_),
              (_.current = window.setTimeout(() => {
                (_.current = ""), (_.current = _.current), _(!1);
              }, _));
            const _ = _.current,
              _ = _(
                _,
                [
                  ...__webpack_require__.slice((_ || 0) + 1),
                  ...__webpack_require__.slice(0, (_ || 0) + 1),
                ],
                _.current,
              );
            -1 !== _
              ? (_(_), (_.current = _))
              : " " !== _.key && ((_.current = ""), _(!1));
          }),
          _ = _.useMemo(
            () => ({
              onKeyDown: _,
            }),
            [_],
          ),
          _ = _.useMemo(
            () => ({
              onKeyDown: _,
              onKeyUp(_) {
                " " === _.key && _(!1);
              },
            }),
            [_, _],
          );
        return _.useMemo(
          () =>
            _
              ? {
                  reference: _,
                  floating: _,
                }
              : {},
          [_, _, _],
        );
      }
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      __webpack_require__._(module_exports, {
        _: () => _,
      });
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      const _ =
        "undefined" != typeof document ? _.useLayoutEffect : _.useEffect;
      function _(_) {
        const _ = _.useReducer(() => ({}), {})[1],
          _ = {
            ..._,
            onChange: (_, _) => {
              var _;
              _ ? (0, _.flushSync)(_) : _(),
                null == (_ = _.onChange) || _.call(_, _, _);
            },
          },
          [_] = _.useState(() => new _._(_));
        return (
          _.setOptions(_),
          _(() => _._didMount(), []),
          _(() => _._willUpdate()),
          _
        );
      }
      function _(_) {
        return _({
          observeElementRect: _._,
          observeElementOffset: _._,
          scrollToFn: _._,
          ..._,
        });
      }
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      function _(_, _, _) {
        let _,
          _ = _.initialDeps ?? [];
        function _() {
          var _, _, _, _;
          let _;
          _.key &&
            (null == (_ = _.debug) ? void 0 : _.call(_)) &&
            (_ = Date.now());
          const _ = _();
          if (!(_.length !== _.length || _.some((_, _) => _[_] !== _)))
            return _;
          let _;
          if (
            ((_ = _),
            _.key &&
              (null == (_ = _.debug) ? void 0 : _.call(_)) &&
              (_ = Date.now()),
            (_ = _(..._)),
            _.key && (null == (_ = _.debug) ? void 0 : _.call(_)))
          ) {
            const _ = Math.round(100 * (Date.now() - _)) / 100,
              _ = Math.round(100 * (Date.now() - _)) / 100,
              _ = _ / 16,
              _ = (_, _) => {
                for (_ = String(_); _.length < _; ) _ = " " + _;
                return _;
              };
            console.info(
              `%c ${_(_, 5)} /${_(_, 5)} ms`,
              `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * _, 120))}deg 100% 31%);`,
              null == _ ? void 0 : _.key,
            );
          }
          return (
            null == (_ = null == _ ? void 0 : _.onChange) || _.call(_, _), _
          );
        }
        return (
          (_.updateDeps = (_) => {
            _ = _;
          }),
          _
        );
      }
      function _(_, _) {
        if (void 0 === _)
          throw new Error("Unexpected undefined" + (_ ? `: ${_}` : ""));
        return _;
      }
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
      });
      const _ = (_, _, _) => {
          let _;
          return function (..._) {
            _.clearTimeout(_), (_ = _.setTimeout(() => _.apply(this, _), _));
          };
        },
        _ = (_) => {
          const { offsetWidth: _, offsetHeight: __webpack_require__ } = _;
          return {
            width: _,
            height: __webpack_require__,
          };
        },
        _ = (_) => _,
        _ = (_) => {
          const _ = Math.max(_.startIndex - _.overscan, 0),
            _ = Math.min(_.endIndex + _.overscan, _.count - 1),
            _ = [];
          for (let _ = _; _ <= _; _++) _.push(_);
          return _;
        },
        _ = (_, _) => {
          const _ = _.scrollElement;
          if (!_) return;
          const _ = _.targetWindow;
          if (!_) return;
          const _ = (_) => {
            const { width: _, height: _ } = _;
            _({
              width: Math.round(_),
              height: Math.round(_),
            });
          };
          if ((_(_(_)), !_.ResizeObserver)) return () => {};
          const _ = new _.ResizeObserver((_) => {
            const _ = () => {
              const _ = _[0];
              if (null == _ ? void 0 : _.borderBoxSize) {
                const _ = _.borderBoxSize[0];
                if (_)
                  return void _({
                    width: _.inlineSize,
                    height: _.blockSize,
                  });
              }
              _(_(_));
            };
            _.options.useAnimationFrameWithResizeObserver
              ? requestAnimationFrame(_)
              : _();
          });
          return (
            _.observe(_, {
              box: "border-box",
            }),
            () => {
              _.unobserve(_);
            }
          );
        },
        _ = {
          passive: !0,
        },
        _ = "undefined" == typeof window || "onscrollend" in window,
        _ = (_, _) => {
          const _ = _.scrollElement;
          if (!_) return;
          const _ = _.targetWindow;
          if (!_) return;
          let _ = 0;
          const _ =
              _.options.useScrollendEvent && _
                ? () => {}
                : _(
                    _,
                    () => {
                      _(_, !1);
                    },
                    _.options.isScrollingResetDelay,
                  ),
            _ = (_) => () => {
              const { horizontal: _, isRtl: _ } = _.options;
              (_ = _ ? _.scrollLeft * (_ ? -1 : 1) : _.scrollTop), _(), _(_, _);
            },
            _ = _(!0),
            _ = _(!1);
          _(), __webpack_require__.addEventListener("scroll", _, _);
          const _ = _.options.useScrollendEvent && _;
          return (
            _ && __webpack_require__.addEventListener("scrollend", _, _),
            () => {
              __webpack_require__.removeEventListener("scroll", _),
                _ && __webpack_require__.removeEventListener("scrollend", _);
            }
          );
        },
        _ = (_, _, _) => {
          if (null == _ ? void 0 : _.borderBoxSize) {
            const _ = _.borderBoxSize[0];
            if (_) {
              return Math.round(
                _[_.options.horizontal ? "inlineSize" : "blockSize"],
              );
            }
          }
          return _[_.options.horizontal ? "offsetWidth" : "offsetHeight"];
        },
        _ = (_, { adjustments: _ = 0, behavior: __webpack_require__ }, _) => {
          var _, _;
          const _ = _ + _;
          null == (_ = null == (_ = _.scrollElement) ? void 0 : _.scrollTo) ||
            _.call(_, {
              [_.options.horizontal ? "left" : "top"]: _,
              behavior: __webpack_require__,
            });
        };
      class _ {
        constructor(_) {
          (this.unsubs = []),
            (this.scrollElement = null),
            (this.targetWindow = null),
            (this.isScrolling = !1),
            (this.measurementsCache = []),
            (this.itemSizeCache = new Map()),
            (this.pendingMeasuredCacheIndexes = []),
            (this.scrollRect = null),
            (this.scrollOffset = null),
            (this.scrollDirection = null),
            (this.scrollAdjustments = 0),
            (this.elementsCache = new Map()),
            (this.observer = (() => {
              let _ = null;
              const _ = () =>
                _ ||
                (this.targetWindow && this.targetWindow.ResizeObserver
                  ? (_ = new this.targetWindow.ResizeObserver((_) => {
                      _.forEach((_) => {
                        const _ = () => {
                          this._measureElement(_.target, _);
                        };
                        this.options.useAnimationFrameWithResizeObserver
                          ? requestAnimationFrame(_)
                          : _();
                      });
                    }))
                  : null);
              return {
                disconnect: () => {
                  var _;
                  null == (_ = _()) || __webpack_require__.disconnect(),
                    (_ = null);
                },
                observe: (_) => {
                  var _;
                  return null == (_ = _())
                    ? void 0
                    : __webpack_require__.observe(_, {
                        box: "border-box",
                      });
                },
                unobserve: (_) => {
                  var _;
                  return null == (_ = _())
                    ? void 0
                    : __webpack_require__.unobserve(_);
                },
              };
            })()),
            (this.range = null),
            (this.setOptions = (_) => {
              Object.entries(_).forEach(([_, __webpack_require__]) => {
                void 0 === __webpack_require__ && delete _[_];
              }),
                (this.options = {
                  debug: !1,
                  initialOffset: 0,
                  overscan: 1,
                  paddingStart: 0,
                  paddingEnd: 0,
                  scrollPaddingStart: 0,
                  scrollPaddingEnd: 0,
                  horizontal: !1,
                  getItemKey: _,
                  rangeExtractor: _,
                  onChange: () => {},
                  measureElement: _,
                  initialRect: {
                    width: 0,
                    height: 0,
                  },
                  scrollMargin: 0,
                  gap: 0,
                  indexAttribute: "data-index",
                  initialMeasurementsCache: [],
                  lanes: 1,
                  isScrollingResetDelay: 150,
                  enabled: !0,
                  isRtl: !1,
                  useScrollendEvent: !1,
                  useAnimationFrameWithResizeObserver: !1,
                  ..._,
                });
            }),
            (this.notify = (_) => {
              var _, _;
              null == (_ = (_ = this.options).onChange) ||
                __webpack_require__.call(_, this, _);
            }),
            (this.maybeNotify = _(
              () => (
                this.calculateRange(),
                [
                  this.isScrolling,
                  this.range ? this.range.startIndex : null,
                  this.range ? this.range.endIndex : null,
                ]
              ),
              (_) => {
                this.notify(_);
              },
              {
                key: !1,
                debug: () => this.options.debug,
                initialDeps: [
                  this.isScrolling,
                  this.range ? this.range.startIndex : null,
                  this.range ? this.range.endIndex : null,
                ],
              },
            )),
            (this.cleanup = () => {
              this.unsubs.filter(Boolean).forEach((_) => _()),
                (this.unsubs = []),
                this.observer.disconnect(),
                (this.scrollElement = null),
                (this.targetWindow = null);
            }),
            (this._didMount = () => () => {
              this.cleanup();
            }),
            (this._willUpdate = () => {
              var _;
              const _ = this.options.enabled
                ? this.options.getScrollElement()
                : null;
              if (this.scrollElement !== _) {
                if ((this.cleanup(), !_)) return void this.maybeNotify();
                (this.scrollElement = _),
                  this.scrollElement && "ownerDocument" in this.scrollElement
                    ? (this.targetWindow =
                        this.scrollElement.ownerDocument.defaultView)
                    : (this.targetWindow =
                        (null == (_ = this.scrollElement)
                          ? void 0
                          : _.window) ?? null),
                  this.elementsCache.forEach((_) => {
                    this.observer.observe(_);
                  }),
                  this._scrollToOffset(this.getScrollOffset(), {
                    adjustments: void 0,
                    behavior: void 0,
                  }),
                  this.unsubs.push(
                    this.options.observeElementRect(this, (_) => {
                      (this.scrollRect = _), this.maybeNotify();
                    }),
                  ),
                  this.unsubs.push(
                    this.options.observeElementOffset(this, (_, _) => {
                      (this.scrollAdjustments = 0),
                        (this.scrollDirection = _
                          ? this.getScrollOffset() < _
                            ? "forward"
                            : "backward"
                          : null),
                        (this.scrollOffset = _),
                        (this.isScrolling = _),
                        this.maybeNotify();
                    }),
                  );
              }
            }),
            (this.getSize = () =>
              this.options.enabled
                ? ((this.scrollRect =
                    this.scrollRect ?? this.options.initialRect),
                  this.scrollRect[this.options.horizontal ? "width" : "height"])
                : ((this.scrollRect = null), 0)),
            (this.getScrollOffset = () =>
              this.options.enabled
                ? ((this.scrollOffset =
                    this.scrollOffset ??
                    ("function" == typeof this.options.initialOffset
                      ? this.options.initialOffset()
                      : this.options.initialOffset)),
                  this.scrollOffset)
                : ((this.scrollOffset = null), 0)),
            (this.getFurthestMeasurement = (_, _) => {
              const _ = new Map(),
                _ = new Map();
              for (let _ = _ - 1; _ >= 0; _--) {
                const _ = _[_];
                if (__webpack_require__.has(_.lane)) continue;
                const _ = _.get(_.lane);
                if (
                  (null == _ || _.end > _.end
                    ? _.set(_.lane, _)
                    : _.end < _.end && __webpack_require__.set(_.lane, !0),
                  _.size === this.options.lanes)
                )
                  break;
              }
              return _.size === this.options.lanes
                ? Array.from(_.values()).sort((_, _) =>
                    _.end === _.end ? _.index - _.index : _.end - _.end,
                  )[0]
                : void 0;
            }),
            (this.getMeasurementOptions = _(
              () => [
                this.options.count,
                this.options.paddingStart,
                this.options.scrollMargin,
                this.options.getItemKey,
                this.options.enabled,
              ],
              (_, _, _, _, _) => (
                (this.pendingMeasuredCacheIndexes = []),
                {
                  count: _,
                  paddingStart: _,
                  scrollMargin: _,
                  getItemKey: _,
                  enabled: _,
                }
              ),
              {
                key: !1,
              },
            )),
            (this.getMeasurements = _(
              () => [this.getMeasurementOptions(), this.itemSizeCache],
              (
                {
                  count: _,
                  paddingStart: _,
                  scrollMargin: __webpack_require__,
                  getItemKey: _,
                  enabled: _,
                },
                _,
              ) => {
                if (!_)
                  return (
                    (this.measurementsCache = []),
                    this.itemSizeCache.clear(),
                    []
                  );
                0 === this.measurementsCache.length &&
                  ((this.measurementsCache =
                    this.options.initialMeasurementsCache),
                  this.measurementsCache.forEach((_) => {
                    this.itemSizeCache.set(_.key, _.size);
                  }));
                const _ =
                  this.pendingMeasuredCacheIndexes.length > 0
                    ? Math.min(...this.pendingMeasuredCacheIndexes)
                    : 0;
                this.pendingMeasuredCacheIndexes = [];
                const _ = this.measurementsCache.slice(0, _);
                for (let _ = _; _ < _; _++) {
                  const _ = _(_),
                    _ =
                      1 === this.options.lanes
                        ? _[_ - 1]
                        : this.getFurthestMeasurement(_, _),
                    _ = _ ? _.end + this.options.gap : _ + __webpack_require__,
                    _ = _.get(_),
                    _ = "number" == typeof _ ? _ : this.options.estimateSize(_),
                    _ = _ + _,
                    _ = _ ? _.lane : _ % this.options.lanes;
                  _[_] = {
                    index: _,
                    start: _,
                    size: _,
                    end: _,
                    key: _,
                    lane: _,
                  };
                }
                return (this.measurementsCache = _), _;
              },
              {
                key: !1,
                debug: () => this.options.debug,
              },
            )),
            (this.calculateRange = _(
              () => [
                this.getMeasurements(),
                this.getSize(),
                this.getScrollOffset(),
                this.options.lanes,
              ],
              (_, _, _, _) =>
                (this.range =
                  _.length > 0 && _ > 0
                    ? (function ({
                        measurements: _,
                        outerSize: _,
                        scrollOffset: _,
                        lanes: _,
                      }) {
                        const _ = _.length - 1,
                          _ = (_) => _[_].start;
                        if (_.length <= _)
                          return {
                            startIndex: 0,
                            endIndex: _,
                          };
                        let _ = _(0, _, _, _),
                          _ = _;
                        if (1 === _) for (; _ < _ && _[_].end < _ + _; ) _++;
                        else if (_ > 1) {
                          const _ = Array(_).fill(0);
                          for (; _ < _ && _.some((_) => _ < _ + _); ) {
                            const _ = _[_];
                            (_[_.lane] = _.end), _++;
                          }
                          const _ = Array(_).fill(_ + _);
                          for (; _ >= 0 && _.some((_) => _ >= _); ) {
                            const _ = _[_];
                            (_[_.lane] = _.start), _--;
                          }
                          (_ = Math.max(0, _ - (_ % _))),
                            (_ = Math.min(_, _ + (_ - 1 - (_ % _))));
                        }
                        return {
                          startIndex: _,
                          endIndex: _,
                        };
                      })({
                        measurements: _,
                        outerSize: _,
                        scrollOffset: _,
                        lanes: _,
                      })
                    : null),
              {
                key: !1,
                debug: () => this.options.debug,
              },
            )),
            (this.getVirtualIndexes = _(
              () => {
                let _ = null,
                  _ = null;
                const _ = this.calculateRange();
                return (
                  _ && ((_ = _.startIndex), (_ = _.endIndex)),
                  this.maybeNotify.updateDeps([this.isScrolling, _, _]),
                  [
                    this.options.rangeExtractor,
                    this.options.overscan,
                    this.options.count,
                    _,
                    _,
                  ]
                );
              },
              (_, _, _, _, _) =>
                null === _ || null === _
                  ? []
                  : _({
                      startIndex: _,
                      endIndex: _,
                      overscan: _,
                      count: _,
                    }),
              {
                key: !1,
                debug: () => this.options.debug,
              },
            )),
            (this.indexFromElement = (_) => {
              const _ = this.options.indexAttribute,
                _ = _.getAttribute(_);
              return _
                ? parseInt(_, 10)
                : (console.warn(
                    `Missing attribute name '${_}={index}' on measured element.`,
                  ),
                  -1);
            }),
            (this._measureElement = (_, _) => {
              const _ = this.indexFromElement(_),
                _ = this.measurementsCache[_];
              if (!_) return;
              const _ = _.key,
                _ = this.elementsCache.get(_);
              _ !== _ &&
                (_ && this.observer.unobserve(_),
                this.observer.observe(_),
                this.elementsCache.set(_, _)),
                _.isConnected &&
                  this.resizeItem(_, this.options.measureElement(_, _, this));
            }),
            (this.resizeItem = (_, _) => {
              const _ = this.measurementsCache[_];
              if (!_) return;
              const _ = _ - (this.itemSizeCache.get(_.key) ?? _.size);
              0 !== _ &&
                ((void 0 !== this.shouldAdjustScrollPositionOnItemSizeChange
                  ? this.shouldAdjustScrollPositionOnItemSizeChange(_, _, this)
                  : _.start <
                    this.getScrollOffset() + this.scrollAdjustments) &&
                  this._scrollToOffset(this.getScrollOffset(), {
                    adjustments: (this.scrollAdjustments += _),
                    behavior: void 0,
                  }),
                this.pendingMeasuredCacheIndexes.push(_.index),
                (this.itemSizeCache = new Map(
                  this.itemSizeCache.set(_.key, _),
                )),
                this.notify(!1));
            }),
            (this.measureElement = (_) => {
              _
                ? this._measureElement(_, void 0)
                : this.elementsCache.forEach((_, _) => {
                    _.isConnected ||
                      (this.observer.unobserve(_),
                      this.elementsCache.delete(_));
                  });
            }),
            (this.getVirtualItems = _(
              () => [this.getVirtualIndexes(), this.getMeasurements()],
              (_, _) => {
                const _ = [];
                for (let _ = 0, _ = _.length; _ < _; _++) {
                  const _ = _[_[_]];
                  __webpack_require__.push(_);
                }
                return _;
              },
              {
                key: !1,
                debug: () => this.options.debug,
              },
            )),
            (this.getVirtualItemForOffset = (_) => {
              const _ = this.getMeasurements();
              if (0 !== _.length)
                return _(_[_(0, _.length - 1, (_) => _(_[_]).start, _)]);
            }),
            (this.getOffsetForAlignment = (_, _, __webpack_require__ = 0) => {
              const _ = this.getSize(),
                _ = this.getScrollOffset();
              "auto" === _ && (_ = _ >= _ + _ ? "end" : "start"),
                "center" === _
                  ? (_ += (__webpack_require__ - _) / 2)
                  : "end" === _ && (_ -= _);
              const _ = this.getTotalSize() + this.options.scrollMargin - _;
              return Math.max(Math.min(_, _), 0);
            }),
            (this.getOffsetForIndex = (_, _ = "auto") => {
              _ = Math.max(0, Math.min(_, this.options.count - 1));
              const _ = this.measurementsCache[_];
              if (!_) return;
              const _ = this.getSize(),
                _ = this.getScrollOffset();
              if ("auto" === _)
                if (_.end >= _ + _ - this.options.scrollPaddingEnd) _ = "end";
                else {
                  if (!(_.start <= _ + this.options.scrollPaddingStart))
                    return [_, _];
                  _ = "start";
                }
              const _ =
                "end" === _
                  ? _.end + this.options.scrollPaddingEnd
                  : _.start - this.options.scrollPaddingStart;
              return [this.getOffsetForAlignment(_, _, _.size), _];
            }),
            (this.isDynamicMode = () => this.elementsCache.size > 0),
            (this.scrollToOffset = (
              _,
              { align: _ = "start", behavior: __webpack_require__ } = {},
            ) => {
              "smooth" === __webpack_require__ &&
                this.isDynamicMode() &&
                console.warn(
                  "The `smooth` scroll behavior is not fully supported with dynamic size.",
                ),
                this._scrollToOffset(this.getOffsetForAlignment(_, _), {
                  adjustments: void 0,
                  behavior: __webpack_require__,
                });
            }),
            (this.scrollToIndex = (
              _,
              { align: _ = "auto", behavior: __webpack_require__ } = {},
            ) => {
              "smooth" === __webpack_require__ &&
                this.isDynamicMode() &&
                console.warn(
                  "The `smooth` scroll behavior is not fully supported with dynamic size.",
                ),
                (_ = Math.max(0, Math.min(_, this.options.count - 1)));
              let _ = 0;
              const _ = (_) => {
                  if (!this.targetWindow) return;
                  const _ = this.getOffsetForIndex(_, _);
                  if (!_)
                    return void console.warn(
                      "Failed to get offset for index:",
                      _,
                    );
                  const [_, _] = _;
                  this._scrollToOffset(_, {
                    adjustments: void 0,
                    behavior: __webpack_require__,
                  }),
                    this.targetWindow.requestAnimationFrame(() => {
                      const _ = this.getScrollOffset(),
                        _ = this.getOffsetForIndex(_, _);
                      var _, _;
                      _
                        ? ((_ = _[0]), (_ = _), Math.abs(_ - _) < 1.01 || _(_))
                        : console.warn("Failed to get offset for index:", _);
                    });
                },
                _ = (_) => {
                  this.targetWindow &&
                    (_++,
                    _ < 10
                      ? this.targetWindow.requestAnimationFrame(() => _(_))
                      : console.warn(
                          `Failed to scroll to index ${_} after 10 attempts.`,
                        ));
                };
              _(_);
            }),
            (this.scrollBy = (_, { behavior: _ } = {}) => {
              "smooth" === _ &&
                this.isDynamicMode() &&
                console.warn(
                  "The `smooth` scroll behavior is not fully supported with dynamic size.",
                ),
                this._scrollToOffset(this.getScrollOffset() + _, {
                  adjustments: void 0,
                  behavior: _,
                });
            }),
            (this.getTotalSize = () => {
              var _;
              const _ = this.getMeasurements();
              let _;
              if (0 === _.length) _ = this.options.paddingStart;
              else if (1 === this.options.lanes)
                _ = (null == (_ = _[_.length - 1]) ? void 0 : _.end) ?? 0;
              else {
                const _ = Array(this.options.lanes).fill(null);
                let _ = _.length - 1;
                for (; _ >= 0 && _.some((_) => null === _); ) {
                  const _ = _[_];
                  null === _[_.lane] && (_[_.lane] = _.end), _--;
                }
                _ = Math.max(..._.filter((_) => null !== _));
              }
              return Math.max(
                _ - this.options.scrollMargin + this.options.paddingEnd,
                0,
              );
            }),
            (this._scrollToOffset = (
              _,
              { adjustments: _, behavior: __webpack_require__ },
            ) => {
              this.options.scrollToFn(
                _,
                {
                  behavior: __webpack_require__,
                  adjustments: _,
                },
                this,
              );
            }),
            (this.measure = () => {
              (this.itemSizeCache = new Map()), this.notify(!1);
            }),
            this.setOptions(_);
        }
      }
      const _ = (_, _, _, _) => {
        for (; _ <= _; ) {
          const _ = ((_ + _) / 2) | 0,
            _ = __webpack_require__(_);
          if (_ < _) _ = _ + 1;
          else {
            if (!(_ > _)) return _;
            _ = _ - 1;
          }
        }
        return _ > 0 ? _ - 1 : 0;
      };
    },
  },
]);
