(self.webpackChunkdeadlock_react = self.webpackChunkdeadlock_react || []).push([
  [792],
  {
    chunkid: (module, module_exports, __webpack_require__) => {
      var _ = {
        "./main_english.json": [7519, 519],
        "./oldgods_english.json": [9322, 322],
      };
      function _(_) {
        if (!__webpack_require__._(_, _))
          return Promise.resolve().then(() => {
            var _ = new Error("Cannot find module '" + _ + "'");
            throw ((_.code = "MODULE_NOT_FOUND"), _);
          });
        var _ = _[_],
          _ = _[0];
        return __webpack_require__
          ._(_[1])
          .then(() => __webpack_require__._(_, 19));
      }
      (_.keys = () => Object.keys(_)), (_._ = 9483), (module.exports = _);
    },
    chunkid: (module) => {
      module.exports = {
        HoverPosition: "_3vg1vYU7iTWqONciv9cuJN",
        Ready: "_1Ye_0niF2UqB8uQTbm8B6B",
        NoSpace: "pxVZHRCaftc2xXduMp7bg",
        EnablePointerEvents: "_2b9OEIbeIFhvcy770kO_TB",
        HoverAboveModal: "EQqOxt3B11pzZRCd8kmXj",
        HoverPositionOuter: "_2_lmTz0tA4NOSle5WaO1PZ",
      };
    },
    chunkid: (module) => {
      module.exports = {
        "duration-app-launch": "800ms",
        ContextMenuMouseOverlay: "_3Knd7Am6tTwTTu605YN4IX",
        ContextMenuPosition: "_2yAm5LY_eu-Vg_52l0HFlM",
        contextMenu: "PP7LM0Ow1K5qkR8WElLpt",
        ContextMenuPopup: "_14wqdluDeDnnEcg3OSLEmd",
        contextMenuContents: "_2EstNjFIIZm_WUSKm5Wt7n",
        contextMenuItem: "_1n7Wloe5jZ6fSuvV18NNWI",
        active: "_18z-3vkWndCBO5WJgFldRK",
        MenuSectionHeader: "_2Bb4JC5n6anf32WgmTfeMP",
        ContextMenuSeparator: "WUOrULWKkGLl3ZUQdDXg8",
        NoSeparation: "_3hRb6_cI8QWlZX-eZmRbXc",
        UpperCase: "uz1XmeUiC1KBA7Y9nOwtn",
        SubMenu: "_2RlEO6dx1vo3OB7EFJnzDi",
        Label: "_2qdHlYPUfe_wwwtyPIu7m3",
        Arrow: "_114nFoGF7tZ4PpremDP2w0",
        IconContainer: "_38-c8Lb-zCJc8GmvTzoyL1",
        ContextMenuHRSeparator: "IjIBR_wDDi2N77Oz4KAT4",
        ForceDesktop: "_3qIuY9S_vXm3IQS-uE9SRS",
        PopoutSubMenu: "Baq37ml_4RsqEDikF0aIo",
        PopoutSubMenuItems: "_2fZ_eG4hoUgJoNBzVAW8wq",
      };
    },
    chunkid: (module) => {
      module.exports = {
        BodyNoScroll: "_1Xs5dtPK2K37sd1U9BLX3S",
        BodyNoScrollDialog: "_3jhMIr8hczcBK_fOVtEVOK",
        OverlayModal: "_24YFXIVY7CC2quNzCN7015",
        GamepadOnlyModalWrapper: "_1GlTsstfPZWsQc4umFIvrX",
        GamepadOnlyPanelWrapper: "_1aY-rmUi48QSw7U1ZWa5DZ",
        ModalDialog: "_32QRvPPBL733SpNR9x0Gp3",
      };
    },
    chunkid: (module) => {
      module.exports = {
        "duration-app-launch": "800ms",
        HasHorizontalDirection: "vnlCrJZjobtJHaugGSLqP",
        EmoticonBow: "_2LlztGU9T4SNsTD6znahfe",
        EmoticonBow_st0: "Fw2WGmXjh2zUxYfuy3xDn",
        EmoticonBow_st1: "luj0tT8JHriKkK3r7pzqP",
        SteamDeckCompatInfo: "_3VPnvw_CDKU-PQKK1pSDlN",
        SteamDeckCompatLogo: "_1dzQL1mVR8GTmmSi_kpDgr",
        SteamDeckCompatIcon: "_3hAj0iMJsfhKwnm2mfE098",
        SteamDeckCompatVerified: "kEODDe6M5cuHWuPlcQexX",
        SteamDeckCompatPlayable: "mPD42Bwx3VAs0qw9wubf2",
        SteamDeckCompatUnsupported: "_2LAaxz6RtHXrJJj9NzCNL4",
        SteamDeckCompatUnknown: "xBqU_GerRwzHIs8N9ratU",
        SteamOSCompatInformation: "_1Gr-Q9sFTdr7XhK5-j_qux",
        SteamOSCompatCompatible: "_1IeRz_QzfsACNiXS4gXHIT",
        SteamTVIcon: "_15p32SPTbcOsOrlb8o1MdF",
        SteamTVLogo: "fX8M83YDC9--4QLgVAEir",
        SteamTVSteam: "_1GjVGP2qdwSOEBKimtRG0k",
        SteamTVTV: "_12AVA1wr7SWXg9INaLfBzD",
        FlipInRTL: "AMU5Zvf1pJLZGVqbpGcUC",
      };
    },
    chunkid: (module) => {
      module.exports = {
        TextToolTip: "_2FxbHJzYoH024ko7zqcJOf",
        ToolTipCustom: "_3XGRklQrZMakU2xaYB0cLD",
        ToolTipTitle: "_1LhVfNukndDa_XWzq0vdg1",
        Center: "_2ZDqET0UaJoW_KYhO0WdTz",
        ToolTipInsetContent: "i4LuYcvtfPgYKx3qqvKUq",
      };
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      var _ = {
        "./shared_arabic.json": [8476, 710],
        "./shared_brazilian.json": [9574, 562],
        "./shared_bulgarian.json": [3789, 449],
        "./shared_czech.json": [815, 591],
        "./shared_danish.json": [4289, 523],
        "./shared_dutch.json": [4978, 110],
        "./shared_english.json": [3800, 256],
        "./shared_finnish.json": [3907, 31],
        "./shared_french.json": [5040, 18],
        "./shared_german.json": [4750, 208],
        "./shared_greek.json": [9668, 712],
        "./shared_hungarian.json": [5233, 165],
        "./shared_indonesian.json": [200, 306],
        "./shared_italian.json": [1864, 912],
        "./shared_japanese.json": [7263, 973],
        "./shared_koreana.json": [295, 539],
        "./shared_latam.json": [559, 435],
        "./shared_norwegian.json": [6512, 320],
        "./shared_polish.json": [2889, 967],
        "./shared_portuguese.json": [2269, 239],
        "./shared_romanian.json": [4419, 749],
        "./shared_russian.json": [5777, 25],
        "./shared_sc_schinese.json": [3723, 27],
        "./shared_schinese.json": [5436, 786],
        "./shared_spanish.json": [6736, 632],
        "./shared_swedish.json": [4625, 225],
        "./shared_tchinese.json": [5191, 241],
        "./shared_thai.json": [4230, 976],
        "./shared_turkish.json": [4792, 152],
        "./shared_ukrainian.json": [7246, 954],
        "./shared_vietnamese.json": [9863, 149],
      };
      function _(_) {
        if (!__webpack_require__._(_, _))
          return Promise.resolve().then(() => {
            var _ = new Error("Cannot find module '" + _ + "'");
            throw ((_.code = "MODULE_NOT_FOUND"), _);
          });
        var _ = _[_],
          _ = _[0];
        return __webpack_require__
          ._(_[1])
          .then(() => __webpack_require__._(_, 19));
      }
      (_.keys = () => Object.keys(_)), (_._ = 4919), (module.exports = _);
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
      });
      var _ = __webpack_require__("chunkid");
      let _ = {
        EUNIVERSE: 0,
        WEB_UNIVERSE: "",
        LANGUAGE: "english",
        BASE_URL: "",
        IMG_URL: "",
        VIDEO_URL: "",
        AUDIO_URL: "",
        PROJECT_NAME: "",
        PROJECT_ROOT: "",
        VALVE_INTERNAL: !1,
      };
      function _() {
        let _ = (0, _._)("deadlock_react", "application_config");
        _ && Object.assign(_, _);
      }
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      const _ = () => `${_._.PROJECT_ROOT}`,
        _ = (_) => "/",
        _ = () => "/oldgods";
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_, _) {
        null != _ &&
          ("function" == typeof _ ? _(_) : "current" in _ && (_.current = _));
      }
      function _(..._) {
        return _.useCallback((_) => {
          for (const _ of _) _(_, _);
        }, _);
      }
      function _(_, _) {
        const _ = _.useRef(void 0);
        return _.useCallback((_) => {
          _.current && __webpack_require__.current(), (_.current = _(_));
        }, _);
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        return null != _ && void 0 !== _.focus;
      }
      function _(_, _) {
        let _ = _;
        for (; _; ) {
          if (
            (_.parentNode?.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
              (_ = _.parentNode.host),
            _ == _)
          )
            return !0;
          _ = _.parentElement;
        }
        return !1;
      }
      function _(_, _) {
        return {
          top: _.screenTop + _.top,
          bottom: _.screenTop + _.bottom,
          left: _.screenLeft + _.left,
          right: _.screenLeft + _.right,
        };
      }
      function _() {
        return (function (_) {
          const _ = {};
          return (
            _.querySelectorAll('link[rel="stylesheet"]').forEach((_) => {
              _[_.href] = _;
            }),
            _
          );
        })(document);
      }
      function _(_, _, _) {
        const _ = Object.assign({}, _),
          _ = _.getElementsByTagName("head")[0],
          _ = _.getElementsByTagName("link"),
          _ = _.length;
        for (let _ = 0; _ < _; ++_) {
          const _ = _[_];
          _[_.href] ? delete _[_.href] : _ && _.parentNode?.removeChild(_);
        }
        const _ = [];
        for (const _ in _) {
          const _ = _[_],
            _ = _.createElement("link");
          for (let _ = 0; _ < _.attributes.length; _++) {
            const _ = _.attributes.item(_);
            _.setAttribute(_.name, _.value);
          }
          _.push(_);
        }
        return _.prepend(..._), _;
      }
      function _(_, _, _, _) {
        _.useEffect(() => {
          if (_ && _)
            return (
              _.addEventListener(_, _, _), () => _.removeEventListener(_, _, _)
            );
        }, [_, _, _]);
      }
      function _() {
        const [, _] = _.useState(0);
        return _.useCallback(() => _((_) => _ + 1), []);
      }
      function _(_, _) {
        _.useLayoutEffect(() => {
          if (!_ || !_) return;
          const _ = _.Register(_);
          return () => __webpack_require__.Unregister();
        }, [_, _]);
      }
      function _(_) {
        return _;
      }
      function _() {}
      function _(_) {
        return _.useSyncExternalStore(
          _ ? _.SyncStore : _,
          _ ? _.GetValue : _,
          _ ? _.GetValue : _,
        );
      }
      function _(_, _) {
        return (
          (function (_, _) {
            const [__webpack_require__, _] = _.useState(_);
            return (
              _.useEffect(() => {
                if (!_) {
                  const _ = window.setTimeout(() => _(!1), _);
                  return () => window.clearTimeout(_);
                }
                _(!0);
              }, [_, _]),
              __webpack_require__
            );
          })(_, _) || _
        );
      }
      var _,
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_),
        _ = __webpack_require__("chunkid");
      !(function (_) {
        (_[(_.LaunchGame = 0)] = "LaunchGame"),
          (_[(_.FriendMessage = 1)] = "FriendMessage"),
          (_[(_.ChatMention = 2)] = "ChatMention"),
          (_[(_.ChatMessage = 3)] = "ChatMessage"),
          (_[(_.ToastMessage = 4)] = "ToastMessage"),
          (_[(_.ToastAchievement = 5)] = "ToastAchievement"),
          (_[(_.ToastMisc = 6)] = "ToastMisc"),
          (_[(_.ToastMiscShort = 7)] = "ToastMiscShort"),
          (_[(_.FriendOnline = 8)] = "FriendOnline"),
          (_[(_.FriendInGame = 9)] = "FriendInGame"),
          (_[(_.VolSound = 10)] = "VolSound"),
          (_[(_.ShowModal = 11)] = "ShowModal"),
          (_[(_.HideModal = 12)] = "HideModal"),
          (_[(_.IntoGameDetail = 13)] = "IntoGameDetail"),
          (_[(_.OutOfGameDetail = 14)] = "OutOfGameDetail"),
          (_[(_.PagedNavigation = 15)] = "PagedNavigation"),
          (_[(_.ToggleOn = 16)] = "ToggleOn"),
          (_[(_.ToggleOff = 17)] = "ToggleOff"),
          (_[(_.SliderUp = 18)] = "SliderUp"),
          (_[(_.SliderDown = 19)] = "SliderDown"),
          (_[(_.ChangeTabs = 20)] = "ChangeTabs"),
          (_[(_.DefaultOk = 21)] = "DefaultOk"),
          (_[(_.OpenSideMenu = 22)] = "OpenSideMenu"),
          (_[(_.CloseSideMenu = 23)] = "CloseSideMenu"),
          (_[(_.BasicNav = 24)] = "BasicNav"),
          (_[(_.FailedNav = 25)] = "FailedNav"),
          (_[(_.Typing = 26)] = "Typing"),
          (_[(_.TimerExpired = 27)] = "TimerExpired"),
          (_[(_.Screenshot = 28)] = "Screenshot");
      })(_ || (_ = {}));
      const _ = new (class {
          m_fnCallbackOnPlaySound = new _._();
          m_fnCallbackOnSuppressSound = new _._();
          RegisterCallbackOnPlaySound(_) {
            return this.m_fnCallbackOnPlaySound.Register(_);
          }
          PlayNavSound(_, _) {
            this.m_fnCallbackOnPlaySound.Dispatch(_, _);
          }
          RegisterCallbackOnSuppressNavImminentSound(_) {
            return this.m_fnCallbackOnSuppressSound.Register(_);
          }
          SuppressImminentNavSound() {
            this.m_fnCallbackOnSuppressSound.Dispatch();
          }
        })(),
        _ = _.createContext({
          focusNavWindow: null,
          bSupportsFocus: !0,
        });
      function _(_ = !0) {
        return _.useContext(_)?.bSupportsFocus ?? _;
      }
      var _ = __webpack_require__("chunkid");
      class _ {
        async GetObject(_, _) {
          try {
            const _ = await this.GetString(_);
            return _ ? JSON.parse(_, _) : null;
          } catch {
            return null;
          }
        }
        async StoreObject(_, _) {
          return this.StoreString(_, JSON.stringify(_));
        }
      }
      class _ extends _ {
        GetString(_) {
          return Promise.resolve(localStorage.getItem(_));
        }
        StoreString(_, _) {
          return localStorage.setItem(_, _), Promise.resolve();
        }
        RemoveObject(_) {
          return localStorage.removeItem(_), Promise.resolve();
        }
      }
      var _,
        _ = __webpack_require__("chunkid");
      !(function (_) {
        (_[(_.Debug = 0)] = "Debug"),
          (_[(_.Info = 1)] = "Info"),
          (_[(_.Warning = 2)] = "Warning"),
          (_[(_.Error = 3)] = "Error");
      })(_ || (_ = {}));
      class _ {
        m_sName;
        m_fnIdGenerator = void 0;
        constructor(_, _) {
          (this.m_sName = _),
            (this.m_fnIdGenerator = _),
            _.Get().RegisterLogName(_);
        }
        Debug(..._) {
          this.Log(_.Debug, ..._);
        }
        Info(..._) {
          this.Log(_.Info, ..._);
        }
        Warning(..._) {
          this.Log(_.Warning, ..._);
        }
        Error(..._) {
          this.Log(_.Error, ..._);
        }
        Assert(_, ..._) {
          _ || this.Log(_.Error, "Assertion failed:", ..._);
        }
        IsDebugEnabled() {
          return _.Get().IsDebugLogEnabled(this.m_sName);
        }
        Log(_, ..._) {
          const _ = _.Get().IsDebugLogEnabled(this.m_sName);
          if (_ == _.Debug && !_) return;
          let _ = this.m_sName;
          const _ = this.m_fnIdGenerator?.() ?? null;
          null != _ && (_ += " (" + _ + ")");
          _(_, _, _.Get().IncludeBacktraceInLog, _, this.m_sName, ..._);
        }
      }
      (0, _._)([_._], _.prototype, "Debug", null),
        (0, _._)([_._], _.prototype, "Info", null),
        (0, _._)([_._], _.prototype, "Warning", null),
        (0, _._)([_._], _.prototype, "Error", null),
        (0, _._)([_._], _.prototype, "Assert", null);
      class _ {
        static k_EnabledLogNames_StorageKey = "EnabledWebLogs";
        static k_IncludeBacktraceInLog_StorageKey = "IncludeBacktraceInLog";
        static s_Singleton = null;
        m_Storage = null;
        m_setKnownDebugLogs = new Set();
        m_setEnabledDebugLogs = new Set();
        m_bIncludeBacktraceInLog = !1;
        m_SettingsChangedCallback = new _._();
        m_bLoading = !1;
        constructor() {
          (this.m_Storage = new _()), this.LoadSettings();
        }
        LogAsLogManager(..._) {
          _(
            _.Info,
            !0,
            this.IncludeBacktraceInLog,
            "LogManager",
            "LogManager",
            ..._,
          );
        }
        async LoadSettings() {
          (this.m_bLoading = !0),
            (this.m_bIncludeBacktraceInLog = !!(await this.m_Storage?.GetObject(
              _.k_IncludeBacktraceInLog_StorageKey,
            )));
          const _ = await this.m_Storage?.GetObject(
            _.k_EnabledLogNames_StorageKey,
          );
          if (Array.isArray(_)) {
            this.m_setEnabledDebugLogs = new Set(_);
            for (const _ of _) this.m_setKnownDebugLogs.add(_);
            this.LogAsLogManager(
              "Loaded debug enabled log names. Will print log messages for:",
              Array.from(this.m_setEnabledDebugLogs),
            );
          } else 0;
          (this.m_bLoading = !1), this.m_SettingsChangedCallback.Dispatch();
        }
        async SaveSettings() {
          await this.m_Storage?.StoreObject(
            _.k_EnabledLogNames_StorageKey,
            Array.from(this.m_setEnabledDebugLogs),
          ),
            await this.m_Storage?.StoreObject(
              _.k_IncludeBacktraceInLog_StorageKey,
              this.m_bIncludeBacktraceInLog,
            ),
            this.LogAsLogManager(
              "Saved enabled debug log names. Will print log messages for:",
              Array.from(this.m_setEnabledDebugLogs),
            );
        }
        PrintEnabledLogs() {
          this.LogAsLogManager(
            "Will print log messages for:",
            Array.from(this.m_setEnabledDebugLogs),
          );
        }
        static Get() {
          return (
            null == _.s_Singleton && (_.s_Singleton = new _()), _.s_Singleton
          );
        }
        get Loading() {
          return this.m_bLoading;
        }
        get LogNames() {
          return this.m_setKnownDebugLogs.values();
        }
        RegisterLogName(_) {
          this.m_setKnownDebugLogs.add(_);
        }
        IsLogName(_) {
          return this.m_setKnownDebugLogs.has(_);
        }
        IsDebugLogEnabled(_) {
          return this.m_setEnabledDebugLogs.has(_);
        }
        async ToggleDebugLogEnabled(_) {
          this.SetDebugLogEnabled(_, !this.IsDebugLogEnabled(_));
        }
        async SetDebugLogEnabled(_, _) {
          _
            ? this.m_setEnabledDebugLogs.add(_)
            : this.m_setEnabledDebugLogs.delete(_),
            this.m_SettingsChangedCallback.Dispatch(),
            await this.SaveSettings();
        }
        async SetAllDebugLogsEnabled(_) {
          (this.m_setEnabledDebugLogs = _
            ? new Set(this.m_setKnownDebugLogs)
            : new Set()),
            this.m_SettingsChangedCallback.Dispatch(),
            await this.SaveSettings();
        }
        RegisterForSettingsChanges(_) {
          return this.m_SettingsChangedCallback.Register(_);
        }
        get IncludeBacktraceInLog() {
          return this.m_bIncludeBacktraceInLog;
        }
        async SetIncludeBacktraceInLog(_) {
          (this.m_bIncludeBacktraceInLog = _),
            this.m_SettingsChangedCallback.Dispatch(),
            await this.SaveSettings();
        }
      }
      function _(_, _, _, _, _, ..._) {
        const _ = (function (_) {
            let _ = 0;
            for (let _ = 0; _ < _.length; _++)
              _ = _.charCodeAt(_) + ((_ << 5) - _);
            return [(_ >> 0) & 255, (_ >> 8) & 255, (_ >> 16) & 255];
          })(_).map((_, _) =>
            Math.round(
              Math.max(0, Math.min(255, 255 * (0.8 * (_ / 255 - 0.5) + 0.15))),
            ),
          ),
          _ = (299 * (_ = _)[0] + 587 * _[1] + 114 * _[2]) / 1e3 >= 128;
        var _;
        let _ = _;
        _ &&
          (_ =
            (function (_) {
              switch (_) {
                case _.Debug:
                  return String.fromCodePoint(128027);
                case _.Info:
                  return String.fromCodePoint(8505);
                case _.Warning:
                  return String.fromCodePoint(9888);
                case _.Error:
                  return String.fromCodePoint(128165);
              }
            })(_) +
            " " +
            _);
        const _ =
            _.length >= 1 && "string" == typeof _[0] && _[0].includes("%c"),
          _ = _ && _.shift();
        let _;
        if (
          ((_ = _
            ? [
                `%c${_}%c:${_ ? " %c" + _ : ""}`,
                `color: ${_ ? "black" : "white"}; background: rgb(${_.join(",")}); padding: 0 1ch; border-radius: 3px;`,
                "color: transparent; margin-right: -1ch",
                ...(_ ? [""] : []),
                ..._,
              ]
            : _),
          _)
        )
          console.groupCollapsed(..._),
            console.trace("Callstack"),
            console.groupEnd();
        else
          switch (_) {
            case _.Debug:
            case _.Info:
              console.log(..._);
              break;
            case _.Warning:
              console.warn(..._);
              break;
            case _.Error:
              console.clogerror
                ? console.clogerror(3, ..._)
                : console.error(..._);
          }
      }
      const _ = () => [..._.Get().LogNames].sort(),
        _ = (_, _) => {
          _.Get().IsLogName(_)
            ? _.Get().SetDebugLogEnabled(_, _)
            : console.warn(`No log named "${_}", available logs:`, _());
        };
      var _, _, _;
      (window.DebugLogEnable = (..._) => _.forEach((_) => _(_, !0))),
        (window.DebugLogDisable = (..._) => _.forEach((_) => _(_, !1))),
        (window.DebugLogEnableAll = () => _.Get().SetAllDebugLogsEnabled(!0)),
        (window.DebugLogDisableAll = () => _.Get().SetAllDebugLogsEnabled(!1)),
        (window.DebugLogEnableBacktrace = () =>
          _.Get().SetIncludeBacktraceInLog(!0)),
        (window.DebugLogDisableBacktrace = () =>
          _.Get().SetIncludeBacktraceInLog(!1)),
        (window.DebugLogNames = _),
        (window.DebugLogEnabled = (..._) => {
          _.length > 0 &&
            console.warn(
              `Use DebugLogEnable( '${_.join("', '")}' ) to enable a log. This function tells you what's enabled.`,
            ),
            _.Get().PrintEnabledLogs();
        }),
        (window.EnableSteamConsole = (_ = !0) =>
          _.Get().SetDebugLogEnabled("SteamClient", _)),
        (function (_) {
          (_[(_.INVALID = 0)] = "INVALID"),
            (_[(_._ = 1)] = "OK"),
            (_[(_.CANCEL = 2)] = "CANCEL"),
            (_[(_.SECONDARY = 3)] = "SECONDARY"),
            (_[(_.OPTIONS = 4)] = "OPTIONS"),
            (_[(_.BUMPER_LEFT = 5)] = "BUMPER_LEFT"),
            (_[(_.BUMPER_RIGHT = 6)] = "BUMPER_RIGHT"),
            (_[(_.TRIGGER_LEFT = 7)] = "TRIGGER_LEFT"),
            (_[(_.TRIGGER_RIGHT = 8)] = "TRIGGER_RIGHT"),
            (_[(_.DIR_UP = 9)] = "DIR_UP"),
            (_[(_.DIR_DOWN = 10)] = "DIR_DOWN"),
            (_[(_.DIR_LEFT = 11)] = "DIR_LEFT"),
            (_[(_.DIR_RIGHT = 12)] = "DIR_RIGHT"),
            (_[(_.SELECT = 13)] = "SELECT"),
            (_[(_.START = 14)] = "START"),
            (_[(_.LSTICK_CLICK = 15)] = "LSTICK_CLICK"),
            (_[(_.RSTICK_CLICK = 16)] = "RSTICK_CLICK"),
            (_[(_.LSTICK_TOUCH = 17)] = "LSTICK_TOUCH"),
            (_[(_.RSTICK_TOUCH = 18)] = "RSTICK_TOUCH"),
            (_[(_.LPAD_TOUCH = 19)] = "LPAD_TOUCH"),
            (_[(_.LPAD_CLICK = 20)] = "LPAD_CLICK"),
            (_[(_.RPAD_TOUCH = 21)] = "RPAD_TOUCH"),
            (_[(_.RPAD_CLICK = 22)] = "RPAD_CLICK"),
            (_[(_.REAR_LEFT_UPPER = 23)] = "REAR_LEFT_UPPER"),
            (_[(_.REAR_LEFT_LOWER = 24)] = "REAR_LEFT_LOWER"),
            (_[(_.REAR_RIGHT_UPPER = 25)] = "REAR_RIGHT_UPPER"),
            (_[(_.REAR_RIGHT_LOWER = 26)] = "REAR_RIGHT_LOWER"),
            (_[(_.STEAM_GUIDE = 27)] = "STEAM_GUIDE"),
            (_[(_.STEAM_QUICK_MENU = 28)] = "STEAM_QUICK_MENU"),
            (_[(_.DUMMY_INPUT = 29)] = "DUMMY_INPUT");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.UNKNOWN = 0)] = "UNKNOWN"),
            (_[(_.GAMEPAD = 1)] = "GAMEPAD"),
            (_[(_.KEYBOARD_SIMULATOR = 2)] = "KEYBOARD_SIMULATOR"),
            (_[(_.MOUSE = 3)] = "MOUSE"),
            (_[(_.TOUCH = 4)] = "TOUCH"),
            (_[(_.LPAD = 5)] = "LPAD"),
            (_[(_.RPAD = 6)] = "RPAD");
        })(_ || (_ = {}));
      !(function (_) {
        (_[(_.GAMEPAD = 0)] = "GAMEPAD"),
          (_[(_.KEYBOARD = 1)] = "KEYBOARD"),
          (_[(_.APPLICATION = 2)] = "APPLICATION"),
          (_[(_.BROWSER = 3)] = "BROWSER");
      })(_ || (_ = {}));
      _._, _.CANCEL, _.SECONDARY, _.OPTIONS, _.START;
      function _(_, _, _) {
        return (
          _.addEventListener(_, _),
          () =>
            (function (_, _, _) {
              _.removeEventListener(_, _);
            })(_, _, _)
        );
      }
      function _(_, _) {
        return _(_, "vgp_onok", _(_));
      }
      function _(_, _) {
        return _(_, "vgp_ondirection", _(_));
      }
      function _(_, _) {
        return _(_, "vgp_onblur", _);
      }
      function _(_) {
        return (_) => {
          !1 !== _(_) && (_.stopPropagation(), _.preventDefault());
        };
      }
      const _ = new _("GamepadEvents").Debug;
      function _(_, _, _) {
        void 0 === _ &&
          (_ = [
            _.onButtonDown,
            _.onButtonUp,
            _.onOKButton,
            _.onCancelButton,
            _.onSecondaryButton,
            _.onOptionsButton,
            _.onMenuButton,
            _.onGamepadDirection,
            _.onGamepadFocus,
            _.onGamepadBlur,
          ]),
          _.useEffect(() => {
            let _ = _.current;
            const _ = [];
            return (
              _ &&
                (_.onButtonDown &&
                  _.push(
                    (function (_, _) {
                      return _(_, "vgp_onbuttondown", _);
                    })(_, _.onButtonDown),
                  ),
                _.onButtonUp &&
                  _.push(
                    (function (_, _) {
                      return _(_, "vgp_onbuttonup", _);
                    })(_, _.onButtonUp),
                  ),
                _.onOKButton && _.push(_(_, _.onOKButton)),
                _.onCancelButton &&
                  _.push(
                    (function (_, _) {
                      return _(_, "vgp_oncancel", _(_));
                    })(_, _.onCancelButton),
                  ),
                _.onSecondaryButton &&
                  _.push(
                    (function (_, _) {
                      return _(_, "vgp_onsecondaryaction", _(_));
                    })(_, _.onSecondaryButton),
                  ),
                _.onOptionsButton &&
                  _.push(
                    (function (_, _) {
                      return _(_, "vgp_onoptions", _(_));
                    })(_, _.onOptionsButton),
                  ),
                _.onMenuButton &&
                  _.push(
                    (function (_, _) {
                      return _(_, "vgp_onmenu", _(_));
                    })(_, _.onMenuButton),
                  ),
                _.onGamepadDirection && _.push(_(_, _.onGamepadDirection)),
                _.onGamepadFocus &&
                  _.push(
                    (function (_, _) {
                      return _(_, "vgp_onfocus", _);
                    })(_, _.onGamepadFocus),
                  ),
                _.onGamepadBlur && _.push(_(_, _.onGamepadBlur))),
              () => _.forEach((_) => _())
            );
          }, _);
      }
      function _(_) {
        return _.stopPropagation(), !1;
      }
      var _ = __webpack_require__("chunkid");
      const _ = new _("FocusHistory"),
        _ = _.Debug;
      class _ {
        m_root;
        constructor(_) {
          this.m_root = _;
        }
        static SerializeNavState(_, _ = !0, __webpack_require__ = !0) {
          return {
            root: _.SerializeNavNode(_, _, __webpack_require__),
            bHadFocus: _.BFocusWithin(),
          };
        }
        static SerializeNavNode(_, _ = !0, __webpack_require__ = !0) {
          let _ = null;
          const [_, _] = _.GetChildren();
          return (
            _.length &&
              -1 != _ &&
              _ &&
              (_ = _.map((_, _) =>
                _.SerializeNavNode(
                  _,
                  _ == _ || __webpack_require__,
                  __webpack_require__,
                ),
              )),
            {
              sNavKey: _.NavKey,
              iActiveChild: _,
              rgChildren: _,
            }
          );
        }
        static RestoreSerializedNavState(_, _, __webpack_require__ = 0) {
          const { root: _, bHadFocus: _ } = _;
          _.Tree.Controller.RestoreHistoryTransaction(() => {
            _.RestoreSerializedNavNode(_, _),
              (1 == __webpack_require__ || (0 == __webpack_require__ && _)) &&
                _.BTakeFocus(_.APPLICATION);
          });
        }
        static RestoreSerializedNavNode(_, _, __webpack_require__ = 0) {
          const { sNavKey: _, iActiveChild: _, rgChildren: _ } = _;
          _ && (0, _._)(_ == _.NavKey, "navkey mismatch"), _.SetActiveChild(_);
          const _ = _.IsDebugEnabled()
            ? `[${_.Tree._}]${(function (_) {
                if (0 == _) return "";
                let _ = "";
                for (let _ = 0; _ < _; _++) _ += "*";
                return (_ += " "), _;
              })(__webpack_require__)}`
            : "";
          if (_ && _.length) {
            const [_] = _.GetChildren();
            -1 != _ &&
              _(
                `${_}Restoring node ${_.NavKey} which had active child ${_} of ${_.length} - now ${_.length} children.`,
              );
            let _ = new Map();
            _.forEach((_) => {
              _.NavKey && _.set(_.NavKey, _);
            });
            for (const _ of _) {
              if (!_.sNavKey) continue;
              const _ = _.get(_.sNavKey);
              _ && _.RestoreSerializedNavNode(_, _, __webpack_require__ + 1);
            }
            if (-1 != _ && _[_]?.sNavKey) {
              const _ = _.get(_[_].sNavKey);
              _(
                `${_}Restoring node ${_.NavKey}, child with focus: ${_[_].sNavKey} ${void 0 === _ ? "MISSING!!" : ""}`,
              ),
                _ && _.SetActiveChild(_.indexOf(_));
            }
            let _ = 0,
              _ = 0;
            for (; _ < _.length && _ < _.length; ) {
              for (; _ < _.length && _[_].NavKey; ) _++;
              for (; _ < _.length && _[_].sNavKey; ) _++;
              if (_ >= _.length || _ >= _.length) break;
              _.RestoreSerializedNavNode(_[_], _[_], _ + 1), _++, _++;
            }
          }
        }
      }
      class _ extends _ {
        m_rgHistory = [];
        PushState() {
          this.m_rgHistory.push(_.SerializeNavState(this.m_root));
        }
        PopState(_ = 0) {
          this.m_rgHistory.length &&
            _.RestoreSerializedNavState(this.m_root, this.m_rgHistory.pop(), _);
        }
      }
      class _ extends _ {
        m_mapHistory = new Map();
        SaveState(_) {
          this.m_mapHistory.set(_, _.SerializeNavState(this.m_root));
        }
        RestoreState(_, _ = 0) {
          const _ = this.m_mapHistory.get(_);
          return (
            !!_ &&
            (console.log(`Restoring history for state ${_}`),
            _.RestoreSerializedNavState(this.m_root, _, _),
            !0)
          );
        }
      }
      const _ = {
        _: "y",
        _: "x",
      };
      function _(_, _, _) {
        const _ = [],
          [_, _] = _.GetChildren(),
          _ = _.GetActiveChild();
        let _;
        const _ = _ ? _.Element?.getBoundingClientRect() : null;
        if (_) {
          const _ = _(_, _, _);
          if (
            _ &&
            !_.offScreen &&
            ((_ = _(_, _, _.overlap, _)), _ && !_.visibility.offScreen)
          )
            return _;
          _ &&
            _.push({
              child: _,
              visibility: _,
            });
        }
        const _ = _ || _;
        for (let _ = 0; _ < _.length; _++) {
          const _ = _[_];
          if (_ == _) continue;
          const _ = _(_, _, _ ?? void 0);
          _ &&
            _.push({
              child: _,
              visibility: _,
            });
        }
        let _;
        _.sort(_);
        for (const _ of _) {
          const { child: _, visibility: _ } = _;
          if (_.offScreen && _) {
            if (!_.visibility.offScreen) break;
            if (_.distance && _.distance > _.visibility.distance) break;
          }
          const _ = _ == _ ? _ : _(_, _, _.overlap || _, _ ?? void 0);
          _ && (!_ || _(_, _) < 0) && (_ = _);
        }
        return _;
      }
      function _(_, _, _, _) {
        switch (_.GetFocusable()) {
          case "none":
            return;
          case "children":
            return _(_, _.overlap || _, _);
          case "self":
            return {
              child: _,
              visibility: _,
            };
        }
      }
      function _(_, _) {
        const _ = _.visibility,
          _ = _.visibility;
        return _.offScreen
          ? _.offScreen
            ? _.distance - _.distance
            : 1
          : _.offScreen
            ? -1
            : _.distance - _.distance;
      }
      function _(_, _, _) {
        const _ = _.Element?.getBoundingClientRect(),
          _ = _.GetFocusable();
        let _;
        if ("none" == _ || !_ || !_) return null;
        if ("self" == _) {
          if (
            _.top < _.top ||
            _.right > _.right ||
            _.bottom > _.bottom ||
            _.left < _.left
          ) {
            const _ = _.top + _.height / 2,
              _ = _.left + _.width / 2;
            if (_ < _.top)
              return {
                offScreen: "top",
                distance: _.top - _,
              };
            if (_ > _.right)
              return {
                offScreen: "right",
                distance: _ - _.right,
              };
            if (_ > _.bottom)
              return {
                offScreen: "bottom",
                distance: _ - _.bottom,
              };
            if (_ < _.left)
              return {
                offScreen: "left",
                distance: _.left - _,
              };
          }
          _ &&
            (_ = (function (_, _) {
              let _ = 0,
                _ = 0;
              return (
                _.right < _.left
                  ? (_ = _.left - _.right)
                  : _.left > _.right && (_ = _.left - _.right),
                _.bottom < _.top
                  ? (_ = _.top - _.bottom)
                  : _.top > _.bottom && (_ = _.top - _.bottom),
                Math.sqrt(_ * _ + _ * _)
              );
            })(_, _));
        } else if ("children" == _) {
          const _ = _.Element;
          if (!_) return null;
          if (_.scrollHeight > _.height || _.scrollWidth > _.width) {
            const _ = _.ownerDocument.defaultView.getComputedStyle(_);
            if ("visible" == _.overflowX || "visible" == _.overflowY)
              return {
                overlap: _,
              };
          }
          if (_.bottom < _.top)
            return {
              offScreen: "top",
              distance: _.top - _.bottom,
            };
          if (_.left > _.right)
            return {
              offScreen: "right",
              distance: _.left - _.right,
            };
          if (_.top > _.bottom)
            return {
              offScreen: "bottom",
              distance: _.top - _.bottom,
            };
          if (_.right < _.left)
            return {
              offScreen: "left",
              distance: _.left - _.right,
            };
        }
        return {
          overlap: {
            top: Math.max(_.top, _.top),
            right: Math.min(_.right, _.right),
            bottom: Math.min(_.bottom, _.bottom),
            left: Math.max(_.left, _.left),
          },
          distance: _,
        };
      }
      var _ = __webpack_require__("chunkid");
      function _(_) {
        return null != _ && void 0 !== _.focus;
      }
      function _(_, _) {
        let _ = 0,
          _ = 0;
        return (
          _.right < _.left
            ? (_ = _.left - _.right)
            : _.left > _.right && (_ = _.left - _.right),
          _.bottom < _.top
            ? (_ = _.top - _.bottom)
            : _.top > _.bottom && (_ = _.top - _.bottom),
          Math.sqrt(_ * _ + _ * _)
        );
      }
      function _(_) {
        let _;
        return _ && (_ = _.ownerDocument.defaultView), _;
      }
      function _(_, _) {
        let _ = _?.parentElement;
        for (; _; ) {
          if (_(_)) {
            const _ = window.getComputedStyle(_);
            if (
              !(
                (_ && "x" != _) ||
                ("scroll" != _.overflowX &&
                  "auto" != _.overflowX &&
                  "fixed" != _.position)
              )
            )
              break;
            if (
              !(
                (_ && "y" != _) ||
                ("scroll" != _.overflowY &&
                  "auto" != _.overflowY &&
                  "fixed" != _.position)
              )
            )
              break;
          }
          _ = _.parentElement;
        }
        return _(_) ? _ : null;
      }
      function _(_, _) {
        if (!("ownerDocument" in _)) return !0;
        const _ = _.ownerDocument.defaultView.getComputedStyle(_),
          _ = "x" === _ ? _.overflowX : _.overflowY;
        return "auto" === _ || "scroll" === _;
      }
      class _ {
        m_options;
        m_msStart;
        m_msEnd;
        m_bActive = !1;
        m_fnBoundAnimationFunc = void 0;
        m_window;
        constructor(_, _) {
          (this.m_window = _),
            (this.m_options = {
              timing: "sine",
              ..._,
            });
        }
        Start() {
          let _;
          switch (
            ((this.m_msStart = performance.now()),
            (this.m_msEnd = this.m_msStart + this.m_options.msDuration),
            this.m_options.timing)
          ) {
            case "linear":
              _ = function (_) {
                return _;
              };
              break;
            case "cubic-in-out":
              _ = function (_) {
                return _ < 0.5
                  ? 4 * _ * _ * _
                  : (_ - 1) * (2 * _ - 2) * (2 * _ - 2) + 1;
              };
              break;
            default:
              _ = function (_) {
                return 0.5 - Math.cos(_ * Math._) / 2;
              };
          }
          (this.m_bActive = !0),
            (this.m_fnBoundAnimationFunc = this.OnInterval.bind(this, _)),
            this.m_window.requestAnimationFrame(this.m_fnBoundAnimationFunc);
        }
        BIsActive() {
          return this.m_bActive;
        }
        End() {
          if (this.m_bActive) {
            try {
              this.Update(1);
            } catch {}
            this.ClearInterval(), this.FireOnComplete();
          }
        }
        FireOnComplete() {
          this.m_options.onComplete && this.m_options.onComplete();
        }
        Cancel() {
          this.m_bActive = !1;
        }
        OnInterval(_) {
          if (!this.m_bActive) return;
          let _ = performance.now() - this.m_msStart;
          if (_ >= this.m_options.msDuration) return void this.End();
          let _ = _ / this.m_options.msDuration;
          try {
            this.Update(_(_));
          } catch {}
          this.m_window.requestAnimationFrame(this.m_fnBoundAnimationFunc);
        }
        ClearInterval() {
          this.m_bActive = !1;
        }
      }
      class _ extends _ {
        m_fnCallback;
        constructor(_, _, _) {
          super(_, _), (this.m_fnCallback = _);
        }
        Update(_) {
          this.m_fnCallback(_);
        }
      }
      class _ extends _ {
        m_object;
        m_propTargets;
        m_props = {};
        constructor(_, _, _) {
          super("ownerDocument" in _ ? _(_) : _, _),
            (this.m_object = _),
            (this.m_propTargets = _);
        }
        Start() {
          this.m_props = {};
          for (let _ in this.m_propTargets) {
            let _ = parseFloat(this.m_object[_]) || 0,
              _ = this.m_propTargets[_];
            _ != _ &&
              (this.m_props[_] = {
                start: _,
                end: _,
              });
          }
          super.Start();
        }
        Update(_) {
          for (let _ in this.m_props) {
            let _ = this.m_props[_],
              _ = _.start + (_.end - _.start) * _;
            this.m_object[_] = _;
          }
        }
      }
      const _ = new _("ScrollSnap").Debug;
      let _ = !1;
      let _;
      function _(_) {
        if (!_)
          return {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
          };
        if (!("ownerDocument" in _))
          return {
            left: 0,
            right: _.innerWidth,
            top: 0,
            bottom: _.innerHeight,
          };
        let _ = 0,
          _ = 0,
          _ = _;
        for (; _; ) {
          if (((_ += _.offsetTop), (_ += _.offsetLeft), "ownerDocument" in _)) {
            if ("fixed" === window.getComputedStyle(_).position) break;
          }
          _ = _.offsetParent;
        }
        for (_ = _?.parentElement; _; ) {
          const { scrollTop: _, scrollLeft: _ } = _(_);
          if (((_ -= _), (_ -= _), "ownerDocument" in _)) {
            if ("fixed" === window.getComputedStyle(_).position) break;
          }
          _ = _.parentElement;
        }
        return {
          left: _,
          top: _,
          right: _ + _.offsetWidth,
          bottom: _ + _.offsetHeight,
        };
      }
      function _(_, _) {
        return "x" == _
          ? [_.left, _.right, _.right - _.left]
          : [_.top, _.bottom, _.bottom - _.top];
      }
      function _(_, _, _, _) {
        let [_, _, _] = _(_, _),
          [_, _, _] = _(_, _),
          [_, _] = _(_, _);
        if (_ < _ && _ > _) return 0;
        const _ = _ - _,
          _ = _ + _,
          _ = _ > _;
        return (_ < _ && !_) || (_ > _ && _)
          ? _ - _
          : (_ < _ && _) || (_ > _ && !_)
            ? _ - _
            : 0;
      }
      function _(_) {
        return "auto" == _
          ? 0
          : _.endsWith("px")
            ? parseInt(_)
            : (console.log("Unsupported length", _), 0);
      }
      function _(_) {
        if (!("ownerDocument" in _))
          return {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
          };
        const _ = _.ownerDocument.defaultView.getComputedStyle(_);
        return {
          left: _(_.scrollMarginLeft),
          right: _(_.scrollMarginRight),
          top: _(_.scrollMarginTop),
          bottom: _(_.scrollMarginBottom),
        };
      }
      function _(_, _) {
        let _ = (function (_) {
          let _;
          return (
            (_ =
              "ownerDocument" in _
                ? _.ownerDocument.defaultView.getComputedStyle(_)
                : _.document.defaultView.getComputedStyle(
                    window.document.documentElement,
                  )),
            {
              left: _(_.scrollPaddingLeft),
              right: _(_.scrollPaddingRight),
              top: _(_.scrollPaddingTop),
              bottom: _(_.scrollPaddingBottom),
            }
          );
        })(_);
        return {
          left: Math.max(0, _.left + _.left),
          right: Math.max(0, _.right - _.right),
          top: Math.max(0, _.top + _.top),
          bottom: Math.max(0, _.bottom - _.bottom),
        };
      }
      function _(_) {
        return _ > -1 && _ < 1;
      }
      function _(_, _, _, _, _) {
        _(
          "----------------------------------------------------------------------------------",
        ),
          _("Scrolling Into View:", _);
        let _ = [],
          _ = _,
          _ = _(_),
          _ = _ ?? Number.MAX_VALUE;
        for (; _; ) {
          let _ = _(_);
          _ || (_ = _(_));
          let _ = _(_),
            _ = _(_, _(_)),
            _ = _(_),
            _ = {
              element: _,
              left: 0,
              top: 0,
            };
          if (
            (_(
              "Checking scroll div",
              _,
              `scroll y:${_.scrollTop} of ${_.MaxScrollTop()}, x:${_.scrollLeft} of ${_.MaxScrollLeft()}, adjusted =>`,
              _,
              "target => ",
              _,
            ),
            (_ && "y" != _) ||
              !_(_, "y") ||
              ((_.top = _(_, _, _, "y")),
              (_.top = _._(
                _.top,
                -_.scrollTop,
                _.MaxScrollTop() - _.scrollTop,
              )),
              _ &&
                ((_.top = Math.min(_, Math.abs(_.top)) * (_.top < 0 ? -1 : 1)),
                (_ -= Math.abs(_.top))),
              _(`- checked y: ${_.top}`)),
            (_ && "x" != _) ||
              !_(_, "x") ||
              ((_.left = _(_, _, _, "x")),
              (_.left = _._(
                _.left,
                -_.scrollLeft,
                _.MaxScrollLeft() - _.scrollLeft,
              )),
              _ &&
                ((_.left =
                  Math.min(_, Math.abs(_.left)) * (_.left < 0 ? -1 : 1)),
                (_ -= Math.abs(_.left))),
              _(`- checked x: ${_.left}`)),
            _.push(_),
            _ && !_)
          )
            break;
          if (!("ownerDocument" in _)) break;
          const _ = window.getComputedStyle(_);
          if ("fixed" === _.position || "sticky" === _.position) break;
          (_ = _),
            (_ = {
              top: _.top - _.top,
              right: _.right - _.left,
              bottom: _.bottom - _.top,
              left: _.left - _.left,
            });
        }
        let _ = !1;
        for (let _ of _) {
          if (_(_.left) && _(_.top)) continue;
          let _ = _(_.element),
            _ = _.scrollTop + _.top,
            _ = _.scrollLeft + _.left;
          (_ = _._(_, 0, _.MaxScrollLeft())),
            (_ = _._(_, 0, _.MaxScrollTop())),
            (_(_.scrollLeft - _) && _(_.scrollTop - _)) ||
              (_.scrollTo({
                left: _,
                top: _,
                behavior: _,
              }),
              _ || (_("Scrolling:"), (_ = !0)),
              _(
                `- ${_.top},${_.left} => ${_}, ${_}, behavior: ${_}`,
                _.element,
              ));
        }
      }
      class _ {
        m_element;
        m_fnOriginalScrollTo;
        m_window;
        m_scrollTopTarget = void 0;
        m_scrollLeftTarget = void 0;
        m_animation = void 0;
        constructor(_) {
          "ownerDocument" in _
            ? ((this.m_element = _),
              (this.m_fnOriginalScrollTo = _.scrollTo),
              (this.m_element.scrollTo = (_, _) => {
                "number" == typeof _
                  ? this.scrollTo({
                      left: _,
                      top: _,
                    })
                  : this.scrollTo(_);
              }))
            : ((this.m_window = _),
              (this.m_element = _.document.documentElement));
        }
        ResetScrollState() {
          (this.m_scrollTopTarget = void 0),
            (this.m_scrollLeftTarget = void 0),
            this.m_window || (this.m_element.style.scrollSnapType = "");
        }
        scrollTo(_) {
          if ("smooth" != _?.behavior)
            this.m_animation &&
              (this.m_animation.Cancel(), (this.m_animation = void 0)),
              this.m_window
                ? this.m_window.scrollTo(_)
                : this.m_fnOriginalScrollTo?.apply(this.m_element, [_]),
              this.ResetScrollState();
          else {
            const _ = _.left ?? this.scrollLeft,
              _ = _.top ?? this.scrollTop;
            let _ = "sine";
            this.m_animation && (this.m_animation.Cancel(), (_ = "linear"));
            if (
              Math.max(
                Math.abs(this.currentScrollTop - _),
                Math.abs(this.currentScrollLeft - _),
              ) > 0
            ) {
              const _ = {
                msDuration: 200,
                timing: _,
                onComplete: this.ResetScrollState,
              };
              if (this.m_window) {
                const _ = this.currentScrollLeft,
                  _ = this.currentScrollTop;
                this.m_animation = new _(this.m_window, _, (_) => {
                  this.m_window?.scrollTo({
                    left: _ + (_ - _) * _,
                    top: _ + (_ - _) * _,
                    behavior: "auto",
                  });
                });
              } else
                (this.m_element.style.scrollSnapType = "initial"),
                  (this.m_animation = new _(
                    this.m_element,
                    {
                      scrollTop: _,
                      scrollLeft: _,
                    },
                    _,
                  ));
              (this.m_scrollLeftTarget = _),
                (this.m_scrollTopTarget = _),
                this.m_animation.Start();
            }
          }
        }
        get clientWidth() {
          return this.m_window
            ? this.m_window.innerWidth
            : this.m_element.clientWidth;
        }
        get clientHeight() {
          return this.m_window
            ? this.m_window.innerHeight
            : this.m_element.clientHeight;
        }
        get currentScrollLeft() {
          return this.m_window
            ? this.m_window.scrollX
            : this.m_element.scrollLeft;
        }
        get currentScrollTop() {
          return this.m_window
            ? this.m_window.scrollY
            : this.m_element.scrollTop;
        }
        get scrollLeft() {
          return this.m_scrollLeftTarget ?? this.currentScrollLeft;
        }
        get scrollTop() {
          return this.m_scrollTopTarget ?? this.currentScrollTop;
        }
        get scrollWidth() {
          return this.m_element.scrollWidth;
        }
        get scrollHeight() {
          return this.m_element.scrollHeight;
        }
        MaxScrollTop() {
          return this.scrollHeight - this.clientHeight;
        }
        MaxScrollLeft() {
          return this.scrollWidth - this.clientWidth;
        }
      }
      (0, _._)([_._], _.prototype, "ResetScrollState", null);
      const _ = new WeakMap();
      function _(_) {
        let _ = _.get(_);
        return _ || ((_ = new _(_)), _.set(_, _)), _;
      }
      function _(_) {
        const _ = _.get(_);
        return _
          ? {
              scrollLeft: _.scrollLeft,
              scrollTop: _.scrollTop,
            }
          : {
              scrollLeft: _.scrollLeft,
              scrollTop: _.scrollTop,
            };
      }
      const _ = new _("FocusNavigationMovement"),
        _ = _.Debug;
      var _, _, _, _;
      !(function (_) {
        (_[(_.NONE = 0)] = "NONE"),
          (_[(_.COLUMN = 1)] = "COLUMN"),
          (_[(_.ROW = 2)] = "ROW"),
          (_[(_.COLUMN_REVERSE = 3)] = "COLUMN_REVERSE"),
          (_[(_.ROW_REVERSE = 4)] = "ROW_REVERSE"),
          (_[(_.GRID = 5)] = "GRID"),
          (_[(_.GEOMETRIC = 6)] = "GEOMETRIC");
      })(_ || (_ = {})),
        (function (_) {
          (_[(_.FIRST = 0)] = "FIRST"),
            (_[(_.LAST = 1)] = "LAST"),
            (_[(_.MAINTAIN_X = 2)] = "MAINTAIN_X"),
            (_[(_.MAINTAIN_Y = 3)] = "MAINTAIN_Y"),
            (_[(_.PREFERRED_CHILD = 4)] = "PREFERRED_CHILD");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.Standard = 0)] = "Standard"),
            (_[(_.NoTransform = 1)] = "NoTransform"),
            (_[(_.NoTransformSparseContent = 2)] = "NoTransformSparseContent");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.INVALID = 0)] = "INVALID"),
            (_[(_.FORWARD = 1)] = "FORWARD"),
            (_[(_.BACKWARD = 2)] = "BACKWARD");
        })(_ || (_ = {}));
      class _ {
        m_Tree;
        m_Parent;
        m_rgChildren = [];
        m_ActiveChild;
        m_iLastActiveChildIndex = -1;
        m_Properties;
        m_element;
        m_FocusRing;
        m_bChildrenSorted = !1;
        m_bAutoFocusChild = !1;
        m_bMounted = !1;
        m_nDepth;
        m_Focused = (0, _._)(!1);
        m_FocusWithin = (0, _._)(!1);
        m_ActionDescriptionsChangedCallbackList = new _._();
        m_FocusableIfEmptyAncestor = null;
        m_rgNavigationHandlers = [];
        m_rgFocusHandlers = [];
        constructor(_, _, _) {
          (this.m_Tree = _),
            (this.m_Parent = _),
            (this.m_FocusRing = _),
            (this.m_nDepth = _ ? _.m_nDepth + 1 : 0);
        }
        CreateHandle() {
          return new _(this);
        }
        get Tree() {
          return this.m_Tree;
        }
        get NavKey() {
          return this.m_Properties?.navKey ? this.m_Properties.navKey : void 0;
        }
        get Element() {
          return this.m_element;
        }
        get Parent() {
          return this.m_Parent;
        }
        SetProperties(_) {
          const _ =
            ((__webpack_require__ = this.m_Properties?.actionDescriptionMap),
            (_ = _?.actionDescriptionMap),
            !(null == __webpack_require__ || null == _
              ? __webpack_require__ === _
              : "object" == typeof __webpack_require__ &&
                "object" == typeof _ &&
                Object.keys(__webpack_require__).length ===
                  Object.keys(_).length &&
                Object.keys(__webpack_require__).every(
                  (_) => _.hasOwnProperty(_) && __webpack_require__[_] === _[_],
                )));
          var _, _;
          const _ = this.m_Properties?.focusableIfEmpty,
            _ = this.m_Properties?.noFocusRing;
          (this.m_Properties = _ || {}),
            _ && this.m_ActionDescriptionsChangedCallbackList.Dispatch(),
            this.m_Properties.focusableIfEmpty && !_
              ? this.PropagateFocusableIfEmptyAncestorToDescendants(this)
              : !this.m_Properties.focusableIfEmpty &&
                _ &&
                this.PropagateFocusableIfEmptyAncestorToDescendants(
                  this.m_FocusableIfEmptyAncestor,
                ),
            this.m_Properties.noFocusRing && !_ && this.BHasFocus()
              ? this.m_FocusRing?.OnBlur(_.APPLICATION, this, this)
              : !this.m_Properties.noFocusRing &&
                _ &&
                this.BHasFocus() &&
                this.m_FocusRing?.OnFocus(_.APPLICATION, this, this),
            this.m_element && this.RegisterDOMEvents();
        }
        BWantsAutoFocus() {
          return this.m_Properties?.autoFocus || this.m_bAutoFocusChild;
        }
        BWantsPreferredFocus() {
          return this.m_Properties?.preferredFocus;
        }
        BWantsFocusRing() {
          return (
            !this.m_Properties?.noFocusRing ||
            this.m_Tree.Controller.GetShowDebugFocusRing().Value
          );
        }
        GetBoundingRect() {
          return this.m_element?.getBoundingClientRect();
        }
        SetHasFocus(_) {
          this.m_Focused.Set(_);
        }
        SetFocusWithin(_) {
          this.m_FocusWithin.Set(_) &&
            this.m_Properties?.onFocusWithin &&
            this.m_Properties.onFocusWithin(_);
        }
        get SubscribableHasFocus() {
          return this.m_Focused;
        }
        BHasFocus() {
          return this.m_Focused.Value;
        }
        get SubscribableFocusWithin() {
          return this.m_FocusWithin;
        }
        BFocusWithin() {
          return this.m_FocusWithin.Value;
        }
        ForceMeasureFocusRing() {
          this.m_FocusRing?.OnForceMeasureFocusRing();
        }
        get ActionDescriptionChangedCallbackList() {
          return this.m_ActionDescriptionsChangedCallbackList;
        }
        GetActiveActionDescriptions() {
          return this.BuildConsolidatedActionDescriptionMap({});
        }
        BuildConsolidatedActionDescriptionMap(_) {
          const _ = this.m_Properties?.actionDescriptionMap;
          if (_)
            for (const _ in _) {
              const _ = _;
              void 0 === _[_] && (_[_] = _[_]);
            }
          return this.m_Parent
            ? this.m_Parent.BuildConsolidatedActionDescriptionMap(_)
            : _;
        }
        AddChild(_) {
          this.m_rgChildren.push(_),
            (this.m_bChildrenSorted = !1),
            this.m_element && this.RegisterDOMEvents(),
            this.m_Properties?.focusableIfEmpty
              ? _.SetFocusableIfEmptyAncestor(this)
              : this.m_FocusableIfEmptyAncestor &&
                _.SetFocusableIfEmptyAncestor(this.m_FocusableIfEmptyAncestor),
            this.m_bMounted &&
              _.BFocusWithin() &&
              ((0, _._)(
                !this.m_ActiveChild && this.BFocusWithin(),
                "Invalid focus state in AddChild",
              ),
              this.SetActiveChild(this.m_rgChildren.length - 1));
        }
        OnMount(_) {
          (this.m_element = _),
            this.m_Parent
              ? this.m_Parent.AddChild(this)
              : (0, _._)(
                  this == this.m_Tree.Root,
                  "Only root should have no parent",
                ),
            (this.m_bMounted = !0),
            this.RegisterDOMEvents();
          const _ =
              this.m_FocusableIfEmptyAncestor &&
              this.m_FocusableIfEmptyAncestor.BHasFocus(),
            _ = this.m_Properties?.autoFocus || _;
          if (this.BWantsAutoFocus() || _) {
            let _ = -1;
            this.m_rgChildren.length &&
              (this.EnsureChildrenSorted(),
              (_ = this.m_rgChildren.findIndex((_) => _.BWantsAutoFocus()))),
              (this.m_Properties?.autoFocus || _ || -1 !== _) &&
                (this.SetActiveChild(_),
                !this.m_Parent || this.m_Parent.m_element
                  ? _
                    ? this.m_Tree.DeferredFocus.BHasQueuedFocusNode() ||
                      this.m_Tree.DeferredFocus.RequestFocus(
                        this.m_FocusableIfEmptyAncestor,
                        {
                          bFocusDescendant: !0,
                        },
                      )
                    : this.Tree.DeferredFocus.RequestFocus(this)
                  : (this.m_Parent.m_bAutoFocusChild = !0));
          } else if (this.m_rgChildren.length) {
            const _ = this.m_rgChildren.findIndex((_) => _.BFocusWithin());
            -1 != _ &&
              (this.SetActiveChild(_),
              (0, _._)(
                this.BFocusWithin(),
                "Child has focus, we should be m_bFocusWithin",
              ));
          }
        }
        DEV_SetDebugPropsOnElement() {}
        OnUnmount() {
          this.m_Properties?.focusableIfEmpty &&
            this.PropagateFocusableIfEmptyAncestorToDescendants(
              this.m_FocusableIfEmptyAncestor,
            ),
            (this.m_bMounted = !1);
          const _ = this.Tree.DeferredFocus.BIsQueuedFocusNode(this);
          (this.BHasFocus() || _) &&
            (_(
              `The focused node is unmounting, ${this.m_FocusableIfEmptyAncestor ? "will transfer to retain focus ancestor" : "will blur"}.`,
            ),
            _ && this.Tree.DeferredFocus.RequestFocus(null),
            this.m_FocusableIfEmptyAncestor
              ? this.m_FocusableIfEmptyAncestor.OnFocusedDecendantRemoved(this)
              : this.BHasFocus() &&
                this.m_Tree.TransferFocus(_.APPLICATION, null)),
            this.UnregisterDOMEvents(),
            this.m_Parent
              ? this.m_Parent.RemoveChild(this)
              : (0, _._)(
                  this == this.m_Tree.Root,
                  "Only root should have no parent",
                );
        }
        RegisterDOMEvents() {
          !this.m_rgNavigationHandlers.length &&
            this.m_element &&
            (this.m_rgChildren.length >= 2 ||
              this.m_Properties?.layout != _.NONE ||
              this.m_Properties.onMoveUp ||
              this.m_Properties.onMoveRight ||
              this.m_Properties.onMoveDown ||
              this.m_Properties.onMoveLeft) &&
            this.m_rgNavigationHandlers.push(
              _(this.m_element, this.OnNavigationEvent),
            ),
            (this.m_Properties?.focusable ||
              this.m_Properties?.focusableIfEmpty ||
              0 == this.m_rgChildren.length) &&
              (this.m_rgFocusHandlers.length ||
                (this.m_element?.addEventListener("focus", this.OnDOMFocus),
                this.m_element?.addEventListener("blur", this.OnDOMBlur),
                this.m_rgFocusHandlers.push(() => {
                  this.m_element?.removeEventListener("focus", this.OnDOMFocus),
                    this.m_element?.removeEventListener("blur", this.OnDOMBlur);
                })));
        }
        RemoveChild(_) {
          let _ = this.m_rgChildren.indexOf(_);
          (0, _._)(-1 !== _, "Child was not found to remove"),
            -1 !== _ &&
              (this.m_ActiveChild == _ && (this.m_ActiveChild = void 0),
              this.m_rgChildren.splice(_, 1));
        }
        UnregisterDOMEvents() {
          this.m_rgNavigationHandlers.forEach((_) => _()),
            (this.m_rgNavigationHandlers = []),
            this.m_rgFocusHandlers.forEach((_) => _()),
            (this.m_rgFocusHandlers = []);
        }
        GetActiveDescendant() {
          const _ = this.GetActiveChild();
          return _ ? _.GetActiveDescendant() : this;
        }
        IsValidChildIndex(_) {
          return _ >= 0 && _ < this.m_rgChildren.length;
        }
        GetActiveChild() {
          return this.m_ActiveChild
            ? this.m_ActiveChild
            : (this.EnsureChildrenSorted(),
              this.IsValidChildIndex(this.m_iLastActiveChildIndex)
                ? this.m_rgChildren[this.m_iLastActiveChildIndex]
                : null);
        }
        GetActiveChildIndex() {
          if (this.m_ActiveChild) {
            if (
              this.IsValidChildIndex(this.m_iLastActiveChildIndex) &&
              this.m_rgChildren[this.m_iLastActiveChildIndex] ==
                this.m_ActiveChild
            )
              return this.m_iLastActiveChildIndex;
            this.m_iLastActiveChildIndex = this.m_rgChildren.indexOf(
              this.m_ActiveChild,
            );
          }
          return this.m_iLastActiveChildIndex;
        }
        EnsureChildrenSorted(_ = !1) {
          (this.m_bChildrenSorted && !_) ||
            (this.m_rgChildren.sort((_, _) => {
              const _ = _.m_element,
                _ = _.m_element;
              if (!_) return _ ? 1 : 0;
              if (!_) return -1;
              const _ = __webpack_require__.compareDocumentPosition(_);
              return _ & Node.DOCUMENT_POSITION_PRECEDING
                ? 1
                : _ & Node.DOCUMENT_POSITION_FOLLOWING
                  ? -1
                  : 0;
            }),
            this.m_ActiveChild &&
              (this.m_iLastActiveChildIndex = this.m_rgChildren.indexOf(
                this.m_ActiveChild,
              )),
            (this.m_bChildrenSorted = !0));
        }
        GetLastFocusElement() {
          const _ = this.GetActiveChild();
          return _ ? _.GetLastFocusElement() : this.m_element;
        }
        OnDOMFocus(_) {
          if (!this.BHasFocus()) {
            if ("children" == this.GetFocusable()) {
              const _ = this.FindFocusableDescendant();
              if (_ && _ !== this)
                return (
                  _(
                    "Browser gave node focus but we are marked focusableIfEmpty, transfering focus to descendant.",
                    this.m_element,
                    _.m_element,
                  ),
                  void this.m_Tree.TransferFocus(_.BROWSER, _)
                );
            }
            this.m_Tree.TransferFocus(_.BROWSER, this);
          }
        }
        OnDOMBlur(_) {
          this.BHasFocus() &&
            this.m_element?.ownerDocument.hasFocus() &&
            this.m_Tree.TransferFocus(_.BROWSER, null);
        }
        UpdateParentActiveChild() {
          this.m_Parent &&
            (this.m_Parent.SetActiveChild(this),
            this.m_Parent.UpdateParentActiveChild());
        }
        GetFocusable() {
          const {
            focusable: _,
            focusableIfEmpty: _,
            childFocusDisabled: __webpack_require__,
            fnCanTakeFocus: _,
          } = this.m_Properties;
          return this.m_bMounted
            ? _ && !_(this)
              ? "none"
              : _ ||
                  (_ && (__webpack_require__ || 0 == this.m_rgChildren.length))
                ? "self"
                : !__webpack_require__ && this.m_rgChildren.length
                  ? "children"
                  : "none"
            : "none";
        }
        BTakeFocus(_, _) {
          const _ = this.FindFocusableNode(_);
          return this.InternalFocusDescendant(_, _, _);
        }
        FindFocusableNode(_, _) {
          switch (this.GetFocusable()) {
            case "none":
              return null;
            case "self":
              return this;
            case "children":
              return this.FindFocusableDescendant(_, _);
          }
        }
        BChildTakeFocus(_, _) {
          const _ = this.FindFocusableDescendant(_);
          return this.InternalFocusDescendant(_, _, _);
        }
        BFocusFirstChild(_) {
          const _ = this.FindNextFocusableChildInDirection(
            -1,
            _.FORWARD,
            _.INVALID,
          );
          return this.InternalFocusDescendant(_, _);
        }
        BFocusLastChild(_) {
          const _ = this.FindNextFocusableChildInDirection(
            this.m_rgChildren.length,
            _.BACKWARD,
            _.INVALID,
          );
          return this.InternalFocusDescendant(_, _);
        }
        FindFocusableDescendant(_, _) {
          const _ = _(_),
            { focusableIfEmpty: _, childFocusDisabled: _ } =
              this.m_Properties ?? {};
          if (_) return null;
          if (this.m_rgChildren.length) {
            this.EnsureChildrenSorted();
            const { navEntryPreferPosition: _, resetNavOnEntry: _ } =
              this.m_Properties ?? {};
            let _ = this.GetActiveChildIndex();
            _ && void 0 !== _ && (_ = -1);
            const _ = this.GetLayout();
            let _, _;
            if (
              (this.IsValidChildIndex(_) ||
                (_ =
                  _ >= this.m_rgChildren.length ||
                  _ == _.ROW_REVERSE ||
                  _ == _.COLUMN_REVERSE ||
                  _ == _.LAST
                    ? this.m_rgChildren.length - 1
                    : 0),
              _ == _.MAINTAIN_X
                ? (_ = "x")
                : _ == _.MAINTAIN_Y
                  ? (_ = "y")
                  : _ == _.GEOMETRIC && _ && (_ = _[_]),
              (_ || _) && _)
            ) {
              const _ = this.m_Tree.GetLastFocusedNode();
              if (_ || (_ && _ == _[_])) {
                const _ =
                  _ ||
                  this.AdjustRectForLastMovementOnTangentAxis(
                    _.GetBoundingRect(),
                    _,
                  );
                _(
                  `Taking focus while preserving ${_ && _[_]} preserved: ${_} movement: ${_}, node:`,
                  _,
                ),
                  (_ = this.FindClosestFocusableNodeToRect(_, _));
              } else if (_ != _[_]) {
                const _ = this.ComputeRelativeDirection(_, _.GRID),
                  _ = _ == _.BACKWARD ? this.m_rgChildren.length : -1;
                _ = this.FindNextFocusableChildInDirection(_, _, _);
              }
            } else if (_ == _.PREFERRED_CHILD) {
              for (const _ of this.m_rgChildren)
                if (
                  ((_ = _.BWantsPreferredFocus()
                    ? _.FindFocusableNode(_)
                    : void 0),
                  _)
                )
                  return _;
            } else
              _ == _.LAST &&
                (_ = this.FindNextFocusableChildInDirection(
                  _ + 1,
                  _.BACKWARD,
                  _,
                ));
            return (
              _ ||
                (_ = this.FindNextFocusableChildInDirection(
                  _ - 1,
                  _.FORWARD,
                  _,
                )),
              _ ||
                (_ = this.FindNextFocusableChildInDirection(_, _.BACKWARD, _)),
              _ || (_ ? this : null)
            );
          }
          return null;
        }
        BVisibleChildTakeFocus(_) {
          const _ = this.Element?.ownerDocument?.defaultView ?? window,
            _ = _(this, {
              top: 0,
              left: 0,
              right: _.innerWidth,
              bottom: _.innerHeight,
            });
          return (
            _(
              `Focusing visible child, best child match is ${_?.child?.Element?.className} - ${JSON.stringify(_?.visibility)}`,
            ),
            !!_ && _.child.BTakeFocus(_)
          );
        }
        GetLayout() {
          if (this.m_Properties?.layout) return this.m_Properties.layout;
          if (this.m_rgChildren.length < 2) return _.NONE;
          return (function (_) {
            if (!_) return _.NONE;
            const _ = _.ownerDocument.defaultView,
              _ = _.getComputedStyle(_);
            if ("flex" == _.display)
              switch (_.flexDirection) {
                case "row":
                  return "wrap" == _.flexWrap ? _.GRID : _.ROW;
                case "row-reverse":
                  return _.ROW_REVERSE;
                case "column":
                  return _.COLUMN;
                case "column-reverse":
                  return _.COLUMN_REVERSE;
              }
            else {
              if ("grid" == _.display)
                return "none" !== _.gridTemplateAreas ? _.GEOMETRIC : _.GRID;
              if (_.childElementCount > 0) {
                const _ = _.getComputedStyle(_.firstElementChild);
                if ("left" === _.float) return _.ROW;
                if ("right" === _.float) return _.ROW_REVERSE;
                if ("inline" === _.display || "inline-block" === _.display)
                  return _.GRID;
              }
            }
            return _.COLUMN;
          })(this.m_element);
        }
        OnNavigationEvent(_) {
          const _ = _.detail.button;
          if (this.BTryInternalNavigation(_, _.detail.is_repeat ?? !1))
            return !0;
          const {
            onMoveUp: __webpack_require__,
            onMoveRight: _,
            onMoveDown: _,
            onMoveLeft: _,
          } = this.m_Properties ?? {};
          let _ = !1;
          switch (_) {
            case _.DIR_UP:
              __webpack_require__ && (_ = __webpack_require__(_.detail, this));
              break;
            case _.DIR_RIGHT:
              _ && (_ = _(_.detail, this));
              break;
            case _.DIR_DOWN:
              _ && (_ = _(_.detail, this));
              break;
            case _.DIR_LEFT:
              _ && (_ = _(_.detail, this));
          }
          return _;
        }
        InternalFocusDescendant(_, _, _) {
          return !!_ && (this.m_Tree.TransferFocus(_, _, _(_)), !0);
        }
        BTryInternalNavigation(_, _) {
          const _ = this.GetLayout();
          let _,
            _ = this.ComputeRelativeDirection(_, _);
          if (
            (_(
              `Handling navigation event ${_[_]} - ${_[_]} - ${_[_]}`,
              this.m_element,
            ),
            _ == _.INVALID)
          )
            return !1;
          if (this.m_Properties?.focusable && this.BHasFocus())
            return _("Skipping navigation within focused element"), !1;
          if ((this.EnsureChildrenSorted(!0), _ == _.GRID))
            _ = this.FindNextFocusableChildInGrid(
              this.GetActiveChildIndex(),
              _,
              _,
            );
          else if (_ == _.GEOMETRIC)
            _ = this.FindNextFocusableChildGeometric(_, _);
          else {
            let _ = this.GetActiveChildIndex();
            this.IsValidChildIndex(_) ||
              (_ = _ == _.FORWARD ? -1 : this.m_rgChildren.length),
              (_ = this.FindNextFocusableChildInDirection(_, _, _));
          }
          if (_) {
            const _ = _(_);
            if (this.GetScrollIntoViewType() == _.NoTransformSparseContent) {
              const _ = _.Element?.ownerDocument.defaultView;
              if (_) {
                const _ =
                    ("y" == _ ? _.innerHeight : _.innerWidth) /
                    (_ ? 4.5 : 3.33),
                  _ = _(_.Element);
                let _ = !1;
                if (
                  ("y" == _
                    ? _ == _.FORWARD
                      ? (_ =
                          _.top > _.innerHeight && _.bottom > _.innerHeight + _)
                      : _ == _.BACKWARD && (_ = _.bottom < 0 && _.top < -_)
                    : "x" == _ &&
                      (_ == _.FORWARD
                        ? (_ =
                            _.left > _.innerWidth && _.right > _.innerWidth + _)
                        : _ == _.BACKWARD && (_ = _.right < 0 && _.left < -_)),
                  _)
                )
                  return (
                    _(`Element too far away, scrolling ${_} on ${_} axis `),
                    _(_.Element, _.Element, "smooth", _, _),
                    !0
                  );
              }
            }
            return this.m_Tree.TransferFocus(_.GAMEPAD, _, _), !0;
          }
          return !1;
        }
        GetScrollIntoViewType() {
          return this.m_Properties?.scrollIntoViewType
            ? this.m_Properties.scrollIntoViewType
            : this.m_Parent
              ? this.m_Parent.GetScrollIntoViewType()
              : _.Standard;
        }
        GetRelativeDirection(_) {
          return this.ComputeRelativeDirection(_, this.GetLayout());
        }
        ComputeRelativeDirection(_, _) {
          let _ = _ == _.ROW_REVERSE || _ == _.COLUMN_REVERSE;
          switch (_) {
            case _.ROW:
            case _.ROW_REVERSE:
              switch (_) {
                case _.DIR_LEFT:
                  return _ ? _.FORWARD : _.BACKWARD;
                case _.DIR_RIGHT:
                  return _ ? _.BACKWARD : _.FORWARD;
                default:
                  return _.INVALID;
              }
            case _.COLUMN:
            case _.COLUMN_REVERSE:
              switch (_) {
                case _.DIR_UP:
                  return _ ? _.FORWARD : _.BACKWARD;
                case _.DIR_DOWN:
                  return _ ? _.BACKWARD : _.FORWARD;
                default:
                  return _.INVALID;
              }
            case _.GRID:
            case _.GEOMETRIC:
              switch (_) {
                case _.DIR_LEFT:
                case _.DIR_UP:
                  return _ ? _.FORWARD : _.BACKWARD;
                case _.DIR_RIGHT:
                case _.DIR_DOWN:
                  return _ ? _.BACKWARD : _.FORWARD;
                default:
                  return _.INVALID;
              }
            default:
              return _.INVALID;
          }
        }
        AdvanceIndex(_, _) {
          return _ + (_ == _.FORWARD ? 1 : -1);
        }
        FindNextFocusableChildInDirection(_, _, _) {
          let _ = _ == _.FORWARD ? 1 : -1;
          for (let _ = _ + _; _ >= 0 && _ < this.m_rgChildren.length; _ += _) {
            const _ = this.m_rgChildren[_].FindFocusableNode(_);
            if (_) return _;
          }
          return null;
        }
        ScanChildren(_, _, _) {
          let _ = _ == _.FORWARD ? 1 : -1;
          for (let _ = _; _ >= 0 && _ < this.m_rgChildren.length; _ += _)
            if (__webpack_require__(this.m_rgChildren[_], _)) return _;
          return -1;
        }
        FindNextFocusableChildInGrid(_, _, _) {
          const _ = _ == _.DIR_UP || _ == _.DIR_DOWN,
            _ = this.GetLastFocusElement();
          if (!_ || _ == this.m_element)
            return (
              (0, _._)(
                !1,
                "No active child for grid navigation",
                this.m_iLastActiveChildIndex,
                this.m_rgChildren.length,
                _,
              ),
              this.FindFocusableDescendant(_)
            );
          let _ = this.GetActiveDescendant().GetBoundingRect();
          if (
            ((_ != _.DIR_UP && _ != _.DIR_DOWN) ||
              (_ = this.AdjustRectForLastMovementOnTangentAxis(_, "y")),
            _)
          ) {
            let _ = _;
            for (; -1 != _; ) {
              const _ = this.ScanChildren(
                this.AdvanceIndex(_, _),
                _,
                (_) => !_("y", _, _.GetBoundingRect()),
              );
              if (-1 != _) {
                const _ = this.m_rgChildren[_].GetBoundingRect(),
                  _ = this.FindClosestChildInNextAxiallyAlignedSet(
                    "x",
                    _,
                    _,
                    _,
                    _,
                    _,
                  );
                if (_) return _;
              }
              _ = _;
            }
          } else {
            let _ = _ == _.FORWARD ? 1 : -1;
            for (
              let _ = this.AdvanceIndex(_, _);
              _ >= 0 && _ < this.m_rgChildren.length;
              _ += _
            ) {
              const _ = this.m_rgChildren[_];
              if (!_("y", _, _.GetBoundingRect())) return null;
              let _ = _.FindFocusableNode(_);
              if (_) return _;
            }
          }
          return null;
        }
        FindNextFocusableChildGeometric(_, _) {
          const _ = this.GetLastFocusElement();
          if (!_ || _ == this.m_element)
            return (
              (0, _._)(
                !1,
                "No active child for geometric navigation",
                this.m_iLastActiveChildIndex,
                this.m_rgChildren.length,
                _,
              ),
              this.FindFocusableDescendant(_)
            );
          const _ = _(_);
          if (!_) return null;
          const _ = this.AdjustRectForLastMovementOnTangentAxis(
            this.GetActiveDescendant().GetBoundingRect(),
            _,
          );
          return this.FindClosetChildInDirection(_, _, _, _);
        }
        AdjustRectForLastMovementOnTangentAxis(_, _) {
          const _ = this.m_Tree.GetLastFocusedMovementRect(_[_]);
          return _
            ? "x" == _
              ? {
                  left: _.left,
                  right: _.right,
                  top: _.top,
                  bottom: _.bottom,
                }
              : {
                  left: _.left,
                  right: _.right,
                  top: _.top,
                  bottom: _.bottom,
                }
            : _;
        }
        FindClosestFocusableNodeToRect(_, _) {
          const _ = _(_),
            _ = _ && _[_],
            _ = [];
          for (const _ of this.m_rgChildren) {
            const _ = _.GetBoundingRect();
            if (_) {
              const _ = _(_, _),
                _ = _ ? _(_, _, _) : 0;
              _.push({
                child: _,
                overlap: _,
                dist: _,
              });
            }
          }
          _.sort((_, _) =>
            _.dist != _.dist ? _.dist - _.dist : _.overlap - _.overlap,
          );
          for (const { child: _ } of _) {
            const _ = __webpack_require__.FindFocusableNode(_, _);
            if (_) return _;
          }
          return null;
        }
        FindClosetChildInDirection(_, _, _, _) {
          _(
            `Find child closest to rect, rect is at left ${_.left} top ${_.top} right ${_.right} bottom ${_.bottom}`,
          );
          const _ = _(_, _),
            _ = [];
          for (const _ of this.m_rgChildren) {
            const _ = _.GetBoundingRect();
            if (_) {
              const _ = _(_, _);
              let _;
              (_ = _ == _.FORWARD ? _.min - _.max : _.min - _.max),
                _ >= 0 &&
                  _.push({
                    child: _,
                    overlap: _(_[_], _, _),
                    dist: _,
                  });
            }
          }
          if (
            (_.sort((_, _) => {
              if (_.overlap) {
                if (!_.overlap) return -1;
              } else if (_.overlap) return 1;
              const _ = _.dist - _.dist;
              return _ || _.overlap - _.overlap;
            }),
            _.IsDebugEnabled())
          ) {
            const _ = _.slice(0, 3).map(
              ({ dist: _, overlap: _, child: _ }) =>
                `[ node: ${_.m_element?.className} dist: ${_} overlap: ${_} ]`,
            );
            _(`Found nodes on axis, top 3 (of ${_.length}: ${_.join(", ")}`);
          }
          for (const { child: _ } of _) {
            const _ = _.FindFocusableNode(_, _);
            if (_) return _;
          }
          return null;
        }
        FindClosestChildInNextAxiallyAlignedSet(_, _, _, _, _, _) {
          (!_ || _ < 0) && (_ = 0);
          let _ = [];
          if (!_) return null;
          const _ = {
            _: (_ = _).left,
            _: _.top,
          };
          var _;
          this.ScanChildren(_, _, (_) => {
            const _ = _.GetBoundingRect();
            return (
              !!_ &&
              (!(!_ || _(_[_], _, _)) ||
                (_.push({
                  child: _,
                  overlap: _(_, _, _),
                  dist: _(_, _, _),
                }),
                !1))
            );
          }),
            _ == _.BACKWARD && _.reverse(),
            _.sort((_, _) => {
              const _ = _.overlap - _.overlap;
              return 0 != _ ? _ : _.dist - _.dist;
            });
          for (const { child: _ } of _) {
            const _ = _.FindFocusableNode(_, _);
            if (_) return _;
          }
          return null;
        }
        GetChildren() {
          return (
            this.EnsureChildrenSorted(),
            [this.m_rgChildren, this.m_iLastActiveChildIndex]
          );
        }
        SetActiveChild(_) {
          _ instanceof _
            ? (this.EnsureChildrenSorted(),
              (this.m_ActiveChild = _),
              (this.m_iLastActiveChildIndex = this.m_rgChildren.indexOf(_)))
            : (this.IsValidChildIndex(_) &&
                (this.m_ActiveChild = this.m_rgChildren[_]),
              (this.m_iLastActiveChildIndex = _));
        }
        GetDepth() {
          return this.m_nDepth;
        }
        SetFocusableIfEmptyAncestor(_) {
          (this.m_FocusableIfEmptyAncestor = _),
            this.m_Properties?.focusableIfEmpty ||
              this.PropagateFocusableIfEmptyAncestorToDescendants(_);
        }
        PropagateFocusableIfEmptyAncestorToDescendants(_) {
          for (let _ = 0; _ < this.m_rgChildren.length; _++)
            this.m_rgChildren[_].SetFocusableIfEmptyAncestor(_);
        }
        OnFocusedDecendantRemoved(_) {
          this.m_Tree.DeferredFocus.RequestFocus(this, {
            bFocusDescendant: !0,
          });
        }
        SetDOMFocusAndScroll(_, _) {
          this.UpdateParentActiveChild(),
            this.m_Tree.OnChildActivated(_),
            this.m_Tree.BIsActiveFocus()
              ? ((0, _._)(
                  !this.m_Tree.BUseVirtualFocus(),
                  "Virtual focus tree should not have browser focus",
                ),
                this.m_element?.focus({
                  preventScroll: !0,
                }))
              : this.m_Tree.BUseVirtualFocus() ||
                _(
                  `Didn't move focus to element as tree ${this.m_Tree._} is not active focus tree`,
                ),
            (function (_, _) {
              const _ = _.Element;
              if (!_) return;
              let _ = [
                {
                  node: _,
                  eScrollType: _.m_Properties?.scrollIntoViewType,
                },
              ];
              for (let _ = _.Parent; _; _ = _.Parent) {
                const _ = _.m_Properties?.scrollIntoViewWhenChildFocused,
                  _ = _.m_Properties?.scrollIntoViewType;
                if (_) {
                  const _ = {
                    node: _,
                    eScrollType: _,
                  };
                  "force" === _ ? (_ = [_]) : _.push(_);
                }
                if (void 0 !== _)
                  for (
                    let _ = _.length - 1;
                    _ >= 0 && void 0 === _[_].eScrollType;
                    _--
                  )
                    _[_].eScrollType = _;
              }
              for (; _.length; ) {
                let { node: _, eScrollType: _ } = _.pop(),
                  _ = 0 == _.length;
                if (
                  (void 0 === _ && (_ = _ ? _.NoTransform : _.Standard),
                  _?.m_Properties?.fnScrollIntoViewHandler &&
                    !1 !== _.m_Properties.fnScrollIntoViewHandler(_, _, _))
                )
                  continue;
                const _ = _.m_element,
                  _ =
                    _ == _.NoTransform || _ == _.NoTransformSparseContent || !_;
                if (_) {
                  const _ = _ ? _(_) : _.getBoundingClientRect();
                  let _ = !1;
                  const _ = Math.max(1.4 * (_.bottom - _.top), 40),
                    _ = _ && performance.now() - _ < 500;
                  (_ ||
                    _.bottom < -_ ||
                    _.top > _.ownerDocument.defaultView.innerHeight + _) &&
                    ((_ = !0),
                    _ ||
                      _(
                        `Disabling smooth scrolling, ${_.bottom} < ${-_}, ${_.top} > ${_.ownerDocument.defaultView.innerHeight} + ${_} `,
                      ));
                  let _ = _ ? "auto" : "smooth";
                  _ && (_ = performance.now()),
                    _.Tree.Controller.BIsRestoringHistory() && (_ = "auto"),
                    _
                      ? _(0, _, _)
                      : _.scrollIntoView({
                          behavior: _,
                          block: "nearest",
                        });
                } else
                  _("No previous element for scrolling, will jump"),
                    _
                      ? _(0, _, "auto")
                      : _?.scrollIntoView({
                          behavior: "auto",
                          block: "nearest",
                          inline: "nearest",
                        });
              }
            })(this, _);
        }
      }
      (0, _._)([_._], _.prototype, "OnDOMFocus", null),
        (0, _._)([_._], _.prototype, "OnDOMBlur", null),
        (0, _._)([_._], _.prototype, "OnNavigationEvent", null);
      class _ {
        m_node;
        m_History;
        m_StateHistory;
        constructor(_) {
          this.m_node = _;
        }
        TakeFocus(_) {
          return this.m_node.BTakeFocus(_ ? _.GAMEPAD : _.APPLICATION, _);
        }
        ParentTakeFocus(_) {
          this.m_node.Parent?.BTakeFocus(_ ? _.GAMEPAD : _.APPLICATION, _);
        }
        ChildTakeFocus(_) {
          return this.m_node.BChildTakeFocus(_ ? _.GAMEPAD : _.APPLICATION, _);
        }
        FocusVisibleChild(_) {
          return this.m_node.BVisibleChildTakeFocus(_);
        }
        BHasFocus() {
          return this.m_node.BHasFocus();
        }
        BFocusWithin() {
          return this.m_node.BFocusWithin();
        }
        get NavKey() {
          return this.m_node.NavKey;
        }
        PushState() {
          this.m_History || (this.m_History = new _(this.m_node)),
            this.m_History.PushState();
        }
        PopState(_ = 0) {
          this.m_History && this.m_History.PopState(_);
        }
        SaveState(_) {
          this.m_StateHistory || (this.m_StateHistory = new _(this.m_node)),
            this.m_StateHistory.SaveState(_);
        }
        RestoreState(_, _ = 0) {
          return (
            !!this.m_StateHistory && this.m_StateHistory.RestoreState(_, _)
          );
        }
        GetFocusSnapshot() {
          return (_ = this.m_node), _.SerializeNavState(_, !0, !1);
          var _;
        }
        RestoreFocusSnapshot(_, _ = 0) {
          return (function (_, _, __webpack_require__ = 0) {
            return _.RestoreSerializedNavState(_, _, __webpack_require__);
          })(this.m_node, _, _);
        }
        NavTree() {
          return this.m_node.Tree;
        }
        Node() {
          return this.m_node;
        }
      }
      function _(_, _, _, _ = 0.001) {
        return "x" == _
          ? _.right > _.left + _ && _.left + _ < _.right
          : "y" == _
            ? _.bottom > _.top + _ && _.top + _ < _.bottom
            : ((0, _._)(!1, `Invalid axis ${_}`), !1);
      }
      function _(_, _, _) {
        let _;
        return (
          "x" == _
            ? (_ = Math.min(_.right, _.right) - Math.max(_.left, _.left))
            : "y" == _
              ? (_ = Math.min(_.bottom, _.bottom) - Math.max(_.top, _.top))
              : ((0, _._)(!1, `Invalid axis ${_}`), (_ = 0)),
          _ < 0 ? 0 : _
        );
      }
      function _(_, _) {
        return "x" == _
          ? {
              min: _.left,
              max: _.right,
            }
          : {
              min: _.top,
              max: _.bottom,
            };
      }
      function _(_, _, _) {
        const _ = _[_],
          _ = _(_, _);
        return _ < _.min ? _.min - _ : _ > _.max ? _ - _.max : 0;
      }
      function _(_) {
        switch (_) {
          case _.DIR_UP:
          case _.DIR_DOWN:
            return "y";
          case _.DIR_LEFT:
          case _.DIR_RIGHT:
            return "x";
          default:
            return;
        }
      }
      function _(_) {
        if (!_) return _.NONE;
        switch (_) {
          case "column":
            return _.COLUMN;
          case "column-reverse":
            return _.COLUMN_REVERSE;
          case "row":
            return _.ROW;
          case "row-reverse":
            return _.ROW_REVERSE;
          case "grid":
            return _.GRID;
          case "geometric":
            return _.GEOMETRIC;
          default:
            return (0, _._)(_, `Unhandled flow-children: ${_}`), _.NONE;
        }
      }
      const _ = _.createContext(function (_) {
        return {
          ShowVirtualKeyboard: () => {},
          ShowModalKeyboard: () => {},
          SetAsCurrentVirtualKeyboardTarget: () => {},
          HideVirtualKeyboard: () => {},
          DelayHideVirtualKeyboard: () => {},
          BIsActive: () => !1,
          BIsElementValidForInput: () => !1,
        };
      });
      function _(_, _) {
        const { onTextEntered: __webpack_require__, ..._ } = _,
          _ = _.useRef(null),
          _ = _.useRef({});
        Object.assign(_.current, {
          ..._,
          BIsElementValidForInput: () =>
            _.current && document.activeElement == _.current,
        });
        const _ = (function (_) {
            const _ = _.useRef(void 0),
              _ = _.useContext(_);
            _.current || (_.current = __webpack_require__(_ || {}));
            return _.current;
          })(_.current),
          _ = _.useCallback(
            (_) => {
              (document.hasFocus() || document.activeElement != _.current) &&
                (_.currentTarget == _.current
                  ? (_.BIsActive() || _.bInVR) && _.DelayHideVirtualKeyboard()
                  : console.warn(
                      "keyboard got blur event, but it's not the active element",
                    ));
            },
            [_],
          ),
          _ = _(
            (_) => {
              _.current = _;
              const _ = [];
              return (
                _ &&
                  (_.addEventListener(
                    "focus",
                    _.SetAsCurrentVirtualKeyboardTarget,
                  ),
                  _.push(() =>
                    _.removeEventListener(
                      "focus",
                      _.SetAsCurrentVirtualKeyboardTarget,
                    ),
                  ),
                  _.addEventListener("click", _.ShowVirtualKeyboard),
                  _.push(() =>
                    _.removeEventListener("click", _.ShowVirtualKeyboard),
                  ),
                  _.push(_(_, _.ShowVirtualKeyboard)),
                  _.push(_(_, _))),
                () => _.forEach((_) => _())
              );
            },
            [_, _],
          );
        return (
          _.useLayoutEffect(
            () => (
              _(_, {
                TakeFocusAndShowKeyboard: () => {
                  const _ = _.current;
                  _ &&
                    (document.activeElement != _ && _.focus(),
                    _.ShowVirtualKeyboard());
                },
                HideVirtualKeyboard: () => {
                  _.HideVirtualKeyboard();
                },
              }),
              () => _(_, null)
            ),
            [_, _],
          ),
          _
        );
      }
      const _ = _.createContext(void 0);
      function _() {
        return _.useContext(_);
      }
      _.forwardRef(function (_, _) {
        const {
            navID: __webpack_require__,
            onActivated: _,
            onDeactivated: _,
            navTreeRef: _,
            enabled: _,
            modal: _,
            virtualFocus: _,
            parentEmbeddedNavTree: _,
            onGlobalButtonDown: _,
            disableFocusClasses: _,
            disabledRoot: _,
            "flow-children": _,
            ..._
          } = _,
          { elemProps: _, navOptions: _, gamepadEvents: _ } = _(_);
        return _()
          ? _.createElement(
              _,
              {
                navID: __webpack_require__,
                onActivated: _,
                onDeactivated: _,
                navTreeRef: _,
                enabled: _,
                modal: _,
                virtualFocus: _,
                parentEmbeddedNavTree: _,
                onGlobalButtonDown: _,
                disableFocusClasses: _,
                disabledRoot: _,
                "flow-children": _,
                ..._,
                ..._,
              },
              _.createElement("div", {
                ..._,
                ref: _,
              }),
            )
          : _.createElement("div", {
              ..._,
              ref: _,
            });
      });
      function _(_) {
        const {
            navID: _,
            onActivated: __webpack_require__,
            onDeactivated: _,
            navTreeRef: _,
            enabled: _ = !0,
            modal: _ = !1,
            virtualFocus: _ = !1,
            children: _,
            parentEmbeddedNavTree: _,
            onGlobalButtonDown: _,
            disableFocusClasses: _ = !1,
            disabledRoot: _ = !1,
            "flow-children": _,
            ..._
          } = _,
          { elemProps: _, navOptions: _, gamepadEvents: _ } = _(_),
          { refDiv: _, tree: _ } = (function (_) {
            const {
                navID: _,
                virtualFocus: __webpack_require__,
                parentEmbeddedNavTree: _,
                disabledRoot: _,
                enabled: _,
                modal: _,
                navTreeRef: _,
                onGlobalButtonDown: _,
              } = _,
              _ = _(),
              _ = _.useContext(_)?.focusNavWindow || _.GetDefaultContext(),
              _ = _.useContext(_),
              [_] = _.useState(() =>
                _.NewGamepadNavigationTree(_, _, _ ?? _?.Tree),
              );
            let _ = _.useRef(null);
            return (
              _.SetUseVirtualFocus(__webpack_require__),
              _.SetModal(_),
              _.SetIsEmbeddedInLegacyTree(!!_),
              _.SetOnGlobalButtonDown(_),
              _.useEffect(
                () => _.RegisterNavigationItem(_.Root, _.current),
                [_, _],
              ),
              _.useEffect(() => {
                _.SetIsEnabled(_);
              }, [_, _]),
              _.useEffect(() => {
                if (!_)
                  return _.RegisterGamepadNavigationTree(
                    _,
                    _.current.ownerDocument.defaultView,
                  );
              }, [_, _, _]),
              _.useEffect(() => (_(_, _), () => _(_, null)), [_, _]),
              {
                refDiv: _,
                tree: _,
              }
            );
          })({
            navID: _,
            virtualFocus: _,
            parentEmbeddedNavTree: _,
            disabledRoot: _,
            enabled: _,
            modal: _,
            onGlobalButtonDown: _,
            navTreeRef: _,
          });
        _(_.OnActivateCallbacks, __webpack_require__),
          _(_.OnDeactivateCallbacks, _),
          (function (_, _, _) {
            const { onButtonDown: _, ..._ } = _,
              _ = _.useCallback(
                (_) => {
                  _ && _(_),
                    _(
                      "Gamepad Event fired:",
                      _.detail.button,
                      ", handled:",
                      null != _,
                      ", propagation stopped:",
                      _.cancelBubble,
                    ),
                    _.cancelBubble || __webpack_require__.OnRootButtonDown(_);
                },
                [_, _],
              );
            _(_, _),
              _(
                {
                  onButtonDown: _,
                  onButtonUp: _,
                  onOKButton: _,
                  onCancelButton: _,
                  onSecondaryButton: _,
                  onOptionsButton: _,
                  onMenuButton: _,
                  onGamepadDirection: _,
                  onGamepadFocus: _,
                  onGamepadBlur: _,
                },
                _,
                [_],
              );
          })(_, _, _),
          _.useLayoutEffect(() => {
            const _ = _(_);
            _.Root.SetProperties({
              ..._,
              layout: _,
            });
          });
        const _ = _(_, _.props.ref);
        return _.createElement(
          _,
          {
            tree: _ ? null : _,
            disableFocusClasses: _ || _,
          },
          _.createElement(
            _.Provider,
            {
              value: _ ? null : _.Root,
            },
            _.cloneElement(_, {
              _: _,
              "data-react-nav-root": _,
              ref: _,
            }),
          ),
        );
      }
      const _ = _.createContext({
        bActiveTree: !1,
        bActiveTreeWithinContext: !1,
        bDisableFocusClasses: !1,
      });
      function _(_) {
        const {
            tree: _,
            disableFocusClasses: __webpack_require__ = !1,
            children: _,
          } = _,
          [_, _] = _.useState(_?.BIsActive() || !1),
          [_, _] = _.useState(_?.BIsActiveWithinContext() || !1);
        _.useEffect(
          () =>
            _
              ? (_(_.BIsActive()),
                _(_.BIsActiveWithinContext()),
                _.OnActiveStateChangedCallbacks.Register(() => {
                  _(_.BIsActive()), _(_.BIsActiveWithinContext());
                }).Unregister)
              : (_(!1), void _(!1)),
          [_],
        );
        const _ = _.useMemo(
          () => ({
            bActiveTree: _,
            bActiveTreeWithinContext: _,
            bDisableFocusClasses: __webpack_require__,
          }),
          [_, __webpack_require__, _],
        );
        return _.createElement(
          _.Provider,
          {
            value: _,
          },
          _,
        );
      }
      const _ = _.createContext(null),
        _ = _.createContext({
          OnBlur: () => {},
          OnFocus: () => {},
          OnFocusChange: () => {},
          OnForceMeasureFocusRing: () => {},
        });
      function _(_) {
        const { navRef: _, ...__webpack_require__ } = _,
          _ = _.useRef(null),
          _ = (0, _.useContext)(_),
          _ = (0, _.useContext)(_),
          _ = (function (_, _) {
            let _ = _.useRef(null);
            return (
              !_ ||
                (_.current && _.current.m_Parent == _) ||
                (_.current = _.Tree.CreateNode(_, _)),
              _.current
            );
          })(_, _);
        return (
          _.useLayoutEffect(() => {
            _ && _.SetProperties(__webpack_require__);
          }),
          _.useLayoutEffect(() => {
            if (!_) return;
            const _ = _.Tree.RegisterNavigationItem(_, _.current);
            return () => {
              _();
            };
          }, [_, _, _]),
          _.useLayoutEffect(() => {
            if (_ && _) return _(_, _.CreateHandle()), () => _(_, null);
          }, [_, _]),
          {
            ref: _,
            node: _,
          }
        );
      }
      function _(_) {
        const {
            onButtonDown: _,
            onButtonUp: __webpack_require__,
            onOKButton: _,
            onCancelButton: _,
            onSecondaryButton: _,
            onOptionsButton: _,
            onGamepadDirection: _,
            onGamepadFocus: _,
            onGamepadBlur: _,
            onMenuButton: _,
            onOKActionDescription: _,
            onCancelActionDescription: _,
            onSecondaryActionDescription: _,
            onOptionsActionDescription: _,
            onMenuActionDescription: _,
            actionDescriptionMap: _,
            ..._
          } = _,
          _ = {};
        void 0 !== _ && (_.onButtonDown = _),
          void 0 !== __webpack_require__ &&
            (_.onButtonUp = __webpack_require__),
          void 0 !== _ && (_.onOKButton = _),
          void 0 !== _ && (_.onCancelButton = _),
          void 0 !== _ && (_.onSecondaryButton = _),
          void 0 !== _ && (_.onOptionsButton = _),
          void 0 !== _ && (_.onMenuButton = _),
          void 0 !== _ && (_.onGamepadDirection = _),
          void 0 !== _ && (_.onGamepadFocus = _),
          void 0 !== _ && (_.onGamepadBlur = _);
        const _ = (function (_) {
          const {
              onOKActionDescription: _,
              onCancelActionDescription: __webpack_require__,
              onSecondaryActionDescription: _,
              onOptionsActionDescription: _,
              onMenuActionDescription: _,
              actionDescriptionMap: _,
            } = _,
            _ = {
              ..._,
            };
          return (
            void 0 !== _ && (_[_._] = _),
            void 0 !== __webpack_require__ &&
              (_[_.CANCEL] = __webpack_require__),
            void 0 !== _ && (_[_.SECONDARY] = _),
            void 0 !== _ && (_[_.OPTIONS] = _),
            void 0 !== _ && (_[_.START] = _),
            _
          );
        })({
          onOKActionDescription: _,
          onCancelActionDescription: _,
          onSecondaryActionDescription: _,
          onOptionsActionDescription: _,
          onMenuActionDescription: _,
          actionDescriptionMap: _,
        });
        return {
          gamepadEvents: _,
          actionDescriptions: _,
          props: _,
        };
      }
      function _(_) {
        const {
            autoFocus: _,
            preferredFocus: __webpack_require__,
            disableNavSounds: _,
            fnCanTakeFocus: _,
            childFocusDisabled: _,
            focusableIfEmpty: _,
            onFocusWithin: _,
            navKey: _,
            noFocusRing: _,
            focusable: _,
            navRef: _,
            actionDescriptionMap: _,
            onMoveUp: _,
            onMoveRight: _,
            onMoveDown: _,
            onMoveLeft: _,
            navEntryPreferPosition: _,
            scrollIntoViewWhenChildFocused: _,
            fnScrollIntoViewHandler: _,
            scrollIntoViewType: _,
            resetNavOnEntry: _,
            ..._
          } = _,
          { gamepadEvents: _, actionDescriptions: _, props: _ } = _(_);
        return {
          elemProps: _,
          navOptions: {
            autoFocus: _,
            preferredFocus: __webpack_require__,
            disableNavSounds: _,
            fnCanTakeFocus: _,
            childFocusDisabled: _,
            focusableIfEmpty: _,
            onFocusWithin: _,
            navKey: _,
            noFocusRing: _,
            focusable: _,
            navRef: _,
            onMoveUp: _,
            onMoveRight: _,
            onMoveDown: _,
            onMoveLeft: _,
            navEntryPreferPosition: _,
            scrollIntoViewWhenChildFocused: _,
            fnScrollIntoViewHandler: _,
            scrollIntoViewType: _,
            resetNavOnEntry: _,
            actionDescriptionMap: {
              ..._,
              ..._,
            },
          },
          gamepadEvents: _,
        };
      }
      function _(_) {
        return function (_) {
          const {
              focusClassName: __webpack_require__,
              focusWithinClassName: _,
              bFocusableByDefault: _,
              className: _,
              divRef: _,
              node: _,
              tabIndex: _,
              children: _,
              ..._
            } = _,
            _ = _(),
            _ = _(_.SubscribableHasFocus) && _,
            _ = _(_.SubscribableFocusWithin) && _,
            {
              bActiveTree: _,
              bActiveTreeWithinContext: _,
              bDisableFocusClasses: _,
            } = _.useContext(_),
            _ = _ && !_,
            _ = !_ && (void 0 !== _ || _);
          return _.createElement(
            _,
            {
              ..._,
              className: _()(_, _ && _ && __webpack_require__, _ && _ && _),
              tabIndex: _ ? -1 : _,
              ref: _,
            },
            _,
          );
        };
      }
      const _ = _("div");
      function _(_) {
        return (
          _.PlayNavSound(_.DefaultOk),
          _(_.currentTarget) && _.currentTarget.click(),
          !0
        );
      }
      const _ = _.createContext(void 0);
      _.Provider;
      function _(_, _, _, _, _) {
        const {
            elemProps: {
              focusClassName: _,
              children: _,
              "flow-children": _,
              ..._
            },
            navOptions: _,
            gamepadEvents: _,
          } = _(_),
          {
            bFocusableByDefault: _ = !0,
            bActivateByDefault: _ = !1,
            bDOMElementFocusByDefault: _ = _,
          } = _ || {};
        void 0 === _.focusable && !_.disabled && _ && (_.focusable = !0);
        const _ = _(_),
          { ref: _, node: _ } = _({
            layout: _,
            ..._,
          });
        _.onOKButton ||
          ((("onClick" in _ && _.onClick) || (_ && (!0 === _ || _(_)))) &&
            (_.onOKButton = _)),
          _.focusable && !_
            ? (_.tabIndex = _.tabIndex || 0)
            : !_.focusable && _ && (_.tabIndex = _.tabIndex ?? -1),
          _(_, _);
        const _ = _(_, _),
          _ = (0, _.useContext)(_)?.Component;
        let _ = {
          ..._,
        };
        return (
          "onClick" in _ && (_.role ??= "button"),
          _
            ? ((_ = {
                ..._,
                divRef: _,
                node: _,
                focusClassName: _()(_, "gpfocus"),
                focusWithinClassName: "gpfocuswithin",
                bFocusableByDefault: _,
                className: _()(_.className, "Focusable"),
              }),
              _.createElement(
                _.Provider,
                {
                  value: _,
                },
                _
                  ? _.createElement(
                      _,
                      {
                        ..._,
                        Component: _,
                      },
                      _,
                    )
                  : _.createElement(_, _, _),
              ))
            : _.createElement(
                _,
                {
                  ..._,
                  ref: _,
                  className: _()(_.className, "Focusable"),
                },
                _,
              )
        );
      }
      function _(_, _) {
        const _ = _(_);
        return _.forwardRef(function (_, _) {
          return _(_, _, _, _, _);
        });
      }
      function _(_) {
        const _ = _(_);
        return _.forwardRef(function (_, _) {
          const {
              virtualKeyboardProps: _,
              props: { refKeyboardHandle: _, ..._ },
            } = (function (_) {
              const {
                onEnterKeyPress: _,
                strEnterKeyLabel: _,
                onKeyboardNavOut: _,
                onKeyboardShow: _,
                onKeyboardFullyVisible: _,
                onTextEntered: _,
                BIsElementValidForInput: _,
                ..._
              } = _;
              return {
                virtualKeyboardProps: {
                  onEnterKeyPress: _,
                  strEnterKeyLabel: _,
                  onKeyboardNavOut: _,
                  onKeyboardShow: _,
                  onKeyboardFullyVisible: _,
                  onTextEntered: _,
                  BIsElementValidForInput: _,
                },
                props: _,
              };
            })(_),
            _ = _(_, _(_, _));
          return _(_, _, _, _);
        });
      }
      _("div", {
        bDOMElementFocusByDefault: !1,
      }),
        _("button", {
          bActivateByDefault: (_) => "submit" === _.type,
        });
      const _ = _("a", {
        bActivateByDefault: !0,
        bDOMElementFocusByDefault: !1,
      });
      _.forwardRef(function (_, _) {
        const { href: __webpack_require__ = "#", ..._ } = _;
        return _.createElement(_, {
          ref: _,
          href: __webpack_require__,
          ..._,
        });
      }),
        _("input"),
        _("textarea"),
        _("img", {
          bDOMElementFocusByDefault: !1,
        }),
        _("label", {
          bActivateByDefault: !0,
          bDOMElementFocusByDefault: !1,
        }),
        _("section", {
          bFocusableByDefault: !1,
        }),
        _("form", {
          bFocusableByDefault: !1,
        });
      const _ = _.createContext({
        Component: _,
      });
      function _(_) {
        const {
            "flow-children": _,
            onActivate: __webpack_require__,
            onCancel: _,
            focusClassName: _,
            focusWithinClassName: _,
            ..._
          } = _,
          { elemProps: _, navOptions: _, gamepadEvents: _ } = _(_);
        let _ = {};
        const _ = _(_);
        _ != _.NONE && (_.layout = _),
          __webpack_require__ &&
            ((_.onClick = _.onClick || __webpack_require__),
            (_.onOKButton = _.onOKButton || __webpack_require__)),
          _.onOKButton &&
            void 0 === _.focusable &&
            void 0 === _.focusableIfEmpty &&
            (_.focusable = !0),
          _ && (_.onCancelButton = _.onCancelButton || _);
        const { ref: _, node: _ } = _({
            ..._,
            ..._,
          }),
          _ = _();
        (_.className = _()(_.className, "Panel", _ && "Focusable")), _(_, _);
        const _ = _(_, _.ref);
        (!_.focusable && !_.focusableIfEmpty) ||
          (_ && _.Tree.BUseVirtualFocus()) ||
          (_.tabIndex = _.tabIndex || 0),
          _.focusable &&
            (__webpack_require__ || _.onOKButton) &&
            (_.role ??= "button");
        const _ = (0, _.useContext)(_).Component;
        return _.createElement(
          _.Provider,
          {
            value: _,
          },
          _
            ? _.createElement(_, {
                ..._,
                divRef: _,
                node: _,
                focusClassName: _()(_, "gpfocus"),
                focusWithinClassName: _()(_, "gpfocuswithin"),
              })
            : _.createElement("div", {
                ..._,
                ref: _,
              }),
        );
      }
      const _ = Object.seal({
        onMoveUp: _,
        onMoveDown: _,
      });
      Object.seal({
        onMoveRight: _,
        onMoveLeft: _,
      });
      function _(_, _) {
        if (_.is_repeat) return !1;
        const _ = _.GetRelativeDirection(_.button);
        return _ == _.FORWARD
          ? _.BFocusFirstChild(_.GAMEPAD)
          : _ == _.BACKWARD && _.BFocusLastChild(_.GAMEPAD);
      }
      function _(_, _) {
        return !!_ && "object" == typeof _.SteamClient && _ in _.SteamClient;
      }
      function _(_, _) {
        if (!_) return !1;
        const [__webpack_require__, _] = _.split(".", 2);
        return (
          __webpack_require__ &&
          _ &&
          _(_, __webpack_require__) &&
          _ in _.SteamClient[__webpack_require__]
        );
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__._(_);
      const _ = _.forwardRef((_, _) => {
        const {
          className: __webpack_require__,
          contextMenuStyles: _,
          disabled: _,
          ..._
        } = _;
        return _.createElement("div", {
          ..._,
          ref: _,
          className: (0, _._)(
            __webpack_require__,
            (_ || _()).contextMenuItem,
            "contextMenuItem",
            _ && "disabled",
          ),
        });
      });
      _.displayName = "MenuItem";
      __webpack_require__("chunkid");
      var _ = __webpack_require__("chunkid");
      function _(_) {
        return _.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_DownArrowContextMenu",
            "data-name": "Layer 1",
            viewBox: "0 0 128 128",
            _: "0px",
            _: "0px",
            ..._,
          },
          _.createElement("polygon", {
            points:
              "50 59.49 13.21 22.89 4.74 31.39 50 76.41 95.26 31.39 86.79 22.89 50 59.49",
          }),
        );
      }
      function _(_) {
        const { color: _ = "#FFFFFF", ...__webpack_require__ } = _;
        return _.createElement(
          "svg",
          {
            version: "1.1",
            _: "Layer_2",
            xmlns: "http://www.w3.org/2000/svg",
            className: (0, _._)(
              "SVGIcon_Button",
              "SVGIcon_X_Line",
              _.className,
            ),
            _: "0px",
            _: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
            ...__webpack_require__,
          },
          _.createElement("line", {
            fill: "none",
            stroke: _,
            strokeWidth: "45",
            strokeMiterlimit: "10",
            _: "212",
            _: "212",
            _: "44",
            _: "44",
          }),
          _.createElement("line", {
            fill: "none",
            stroke: _,
            strokeWidth: "45",
            strokeMiterlimit: "10",
            _: "44",
            _: "212",
            _: "212",
            _: "44",
          }),
        );
      }
      function _() {
        return _.createElement(
          "svg",
          {
            version: "1.1",
            _: "base",
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_Maximize",
            _: "0px",
            _: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
          },
          _.createElement("rect", {
            _: "24",
            _: "42.167",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "18",
            strokeMiterlimit: "10",
            width: "208",
            height: "171.667",
          }),
          _.createElement("line", {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "42",
            strokeMiterlimit: "10",
            _: "24",
            _: "54.01",
            _: "232",
            _: "54.01",
          }),
        );
      }
      function _() {
        return _.createElement(
          "svg",
          {
            version: "1.1",
            _: "base",
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_Minimize",
            _: "0px",
            _: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
          },
          _.createElement("line", {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "18",
            strokeMiterlimit: "10",
            _: "24",
            _: "209.01",
            _: "232",
            _: "209.01",
          }),
        );
      }
      function _() {
        return _.createElement(
          "svg",
          {
            version: "1.1",
            _: "Layer_2",
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_Restore",
            _: "0px",
            _: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
          },
          _.createElement("polyline", {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "12",
            strokeMiterlimit: "10",
            points: "83,90.861 83,42.167 232,42.167 232,165.14 173,165.14 ",
          }),
          _.createElement("rect", {
            _: "24",
            _: "90.861",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "18",
            strokeMiterlimit: "10",
            width: "149",
            height: "122.973",
          }),
        );
      }
      function _(_, _ = !0) {
        return function (_, _, _) {
          const _ = _.value;
          _.value = function (..._) {
            let _ = this[_ + "_DebounceProperties"];
            void 0 === _ &&
              (_ = this[_ + "_DebounceProperties"] =
                {
                  hTimer: void 0,
                  nPending: 0,
                }),
              void 0 === _.hTimer
                ? (_ ? _.apply(this, _) : (_.nPending += 1),
                  (_.hTimer = window.setInterval(() => {
                    _.nPending > 0
                      ? (_.apply(this, _), (_.nPending = 0))
                      : (window.clearInterval(_.hTimer), (_.hTimer = void 0));
                  }, _)))
                : (_.nPending += 1);
          };
        };
      }
      var _ = __webpack_require__("chunkid");
      const _ = _.createContext(null);
      let _ = class extends _.Component {
        static contextType = _;
        m_navRef = (function () {
          return _.createRef();
        })();
        get instance() {
          return this.context.instance;
        }
        componentDidMount() {
          this.instance.SetLabel(this.props.label),
            this.m_navRef.current?.TakeFocus(),
            _(this.props.refInstance, this.instance);
        }
        componentDidUpdate(_) {
          _.label !== this.props.label &&
            this.context &&
            this.instance.SetLabel(this.props.label);
        }
        HideIfSubmenu() {
          return !!this.instance.BIsSubMenu() && (this.instance.HideSelf(), !0);
        }
        HideMenu() {
          return (
            this.instance.BIsSubMenu()
              ? this.instance.HideSelf()
              : this.instance.Hide(),
            !0
          );
        }
        render() {
          let {
            children: _,
            className: _,
            label: __webpack_require__,
            onCancel: _,
            cancelText: _,
            refInstance: _,
            bForceDesktopPresentation: _,
            footer: _,
            role: _ = "menu",
            labelId: _,
            style: _ = {},
            refScrollable: _,
            ..._
          } = this.props;
          const _ = this.context.styles ?? _();
          let _ = _ ?? "#Button_Cancel";
          if (1 != this.context.presentation || _)
            return _.createElement(
              "div",
              {
                ref: _,
                style: _,
                ..._,
                className: (0, _._)(
                  {
                    [_.contextMenuContents]: !0,
                    [_.hasSubMenu]: this.instance.BIsSubMenuVisible(),
                    [_.ForceDesktop]: _,
                  },
                  _,
                ),
              },
              _,
            );
          {
            const _ = () => {
              _ && _(), this.instance.Hide();
            };
            return (
              (_.overflowY = this.instance.BIsSubMenuVisible()
                ? "hidden"
                : void 0),
              _.createElement(
                _,
                {
                  ..._,
                  className: (0, _._)(
                    _.contextMenuContents,
                    {
                      [_.hasSubMenu]: this.instance.BIsSubMenuVisible(),
                    },
                    _,
                  ),
                  "flow-children": "column",
                  onMoveLeft: this.HideIfSubmenu,
                  onCancel: this.instance.BIsSubMenu() ? this.HideMenu : _,
                  style: _,
                  navEntryPreferPosition: _.PREFERRED_CHILD,
                  navRef: this.m_navRef,
                  ref: _,
                  role: _,
                  "aria-labelledby": __webpack_require__ ? _ : void 0,
                  ..._,
                },
                _,
                __webpack_require__ &&
                  _.createElement(
                    "div",
                    {
                      _: _,
                      style: {
                        display: "none",
                      },
                    },
                    __webpack_require__,
                  ),
                !this.instance.BIsSubMenu() &&
                  _.createElement(
                    _.Fragment,
                    null,
                    _.createElement(_, null),
                    _.createElement(
                      _,
                      {
                        className: _.Cancel,
                        onSelected: _,
                      },
                      (0, _._)(_),
                    ),
                    _,
                  ),
                this.instance.BIsSubMenuVisible() &&
                  _.createElement("div", {
                    className: _.contextMenuFade,
                    onClick: () => this.instance.HideSubMenu(),
                  }),
              )
            );
          }
        }
      };
      function _(_) {
        const _ = _.useId();
        return _.createElement(_, {
          labelId: _,
          ..._,
        });
      }
      (0, _._)([_._], _.prototype, "HideIfSubmenu", null),
        (0, _._)([_._], _.prototype, "HideMenu", null),
        (_ = (0, _._)([_._], _));
      class _ extends _.PureComponent {
        static contextType = _;
        m_ref = _.createRef();
        m_refDiv = _.createRef();
        get element() {
          return this.m_refDiv.current;
        }
        get instance() {
          return this.context.instance;
        }
        OnClick(_) {
          this.props.disabled
            ? this.context.callbacks?.onDisabledItemSelected &&
              this.context.callbacks.onDisabledItemSelected()
            : (this.props.onClick && this.props.onClick(_),
              this.props.bInteractableItem ||
                (this.props.onSelected && this.props.onSelected(_),
                this.context && this.instance.ForceHide()));
        }
        OnOKButton(_) {
          this.m_refDiv.current?.click();
        }
        OnMouseEnter(_) {
          0 == this.context.presentation && this.instance.HideSubMenu();
        }
        Focus() {
          this.m_ref.current
            ? this.m_ref.current.TakeFocus()
            : this.m_refDiv.current && this.m_refDiv.current.focus();
        }
        render() {
          const {
              onSelected: _,
              bInteractableItem: _,
              onMoveRight: __webpack_require__,
              ..._
            } = this.props,
            _ = this.context?.styles ?? _();
          return 1 == this.context.presentation
            ? _.createElement(
                _,
                {
                  noFocusRing: !0,
                  preferredFocus: this.props.selected,
                  ref: this.m_refDiv,
                  navRef: this.m_ref,
                  onMouseEnter: this.OnMouseEnter,
                  ..._,
                  className: (0, _._)(
                    this.props.className,
                    _.contextMenuItem,
                    "contextMenuItem",
                    this.props.disabled && "disabled",
                    this.props.selected && _.Selected,
                    "positive" == this.props.tone && _.Positive,
                    "emphasis" == this.props.tone && _.Emphasis,
                    "destructive" == this.props.tone && _.Destructive,
                  ),
                  focusClassName: _.Focused,
                  onClick: this.props.disabled ? void 0 : this.OnClick,
                  focusable: !this.props.disabled,
                  onOKButton: this.OnOKButton,
                  onMoveRight: __webpack_require__,
                  unselectable: this.props.unselectable,
                  role: _.role ?? "menuitem",
                  "aria-selected": this.props.selected,
                },
                this.props.children,
              )
            : _.createElement(
                _,
                {
                  ref: this.m_refDiv,
                  onMouseEnter: this.OnMouseEnter,
                  ..._,
                  onClick: this.OnClick,
                  unselectable: this.props.unselectable,
                  className: this.props.className,
                  role: _.role ?? "menuitem",
                  "aria-selected": this.props.selected,
                },
                this.props.children,
              );
        }
      }
      (0, _._)([_._], _.prototype, "OnClick", null),
        (0, _._)([_._], _.prototype, "OnOKButton", null),
        (0, _._)([_._], _.prototype, "OnMouseEnter", null),
        (0, _._)([_._], _.prototype, "Focus", null);
      _.PureComponent;
      _.PureComponent;
      function _(_) {
        const _ = _.useContext(_).styles ?? _();
        return _.createElement("div", {
          className: _.ContextMenuSeparator,
          role: "separator",
        });
      }
      class _ extends _.PureComponent {
        static contextType = _;
        m_refItem = _.createRef();
        constructor(_) {
          super(_),
            (this.state = {
              bActive: !1,
            });
        }
        get instance() {
          return this.context.instance;
        }
        OnSubMenuMouseEnter() {
          this.instance.CancelHideSubMenuTimer();
        }
        OnSubMenuHidden() {
          this.setState({
            bActive: !1,
          }),
            this.props.bInGamepadUI &&
              1 == this.context.presentation &&
              this.m_refItem.current &&
              this.m_refItem.current.Focus();
        }
        ShowSubMenu(_) {
          const _ = _ || this.m_refItem.current.element;
          let _ = this.instance.ShowSubMenu(_, this.RenderSubMenu);
          return (
            !!_ &&
            (this.setState({
              bActive: !0,
            }),
            __webpack_require__.SetOnHideCallback(this.OnSubMenuHidden),
            !0)
          );
        }
        RenderSubMenu() {
          return _.createElement(
            _,
            {
              onMouseEnter: this.OnSubMenuMouseEnter,
              label: this.props.label,
            },
            this.props.children,
          );
        }
        OnMouseEnter(_) {
          0 == this.context.presentation && this.ShowSubMenu(_.currentTarget);
        }
        OnClick(_) {
          this.OnMouseEnter(_),
            this.props.onClick && this.props.onClick(_),
            this.props.bInGamepadUI &&
              1 == this.context.presentation &&
              this.ShowSubMenu(_.currentTarget);
        }
        render() {
          let {
            label: _,
            selectedWithin: _,
            children: __webpack_require__,
            className: _,
            bInGamepadUI: _,
            ..._
          } = this.props;
          const _ = this.context.styles ?? _();
          return _.createElement(
            _,
            {
              ..._,
              ref: this.m_refItem,
              onClick: this.OnClick,
              selected: _ && !this.state.bActive,
              className: (0, _._)(_, _.SubMenu, this.state.bActive && _.active),
              onMouseEnter: this.OnMouseEnter,
              bInteractableItem: !0,
              onMoveRight: () => this.ShowSubMenu(),
            },
            _.createElement(
              "div",
              {
                className: _.Label,
              },
              _,
            ),
            _.createElement(
              "div",
              {
                className: _.Arrow,
              },
              _.createElement(_, null),
            ),
          );
        }
      }
      (0, _._)([_._], _.prototype, "OnSubMenuMouseEnter", null),
        (0, _._)([_._], _.prototype, "OnSubMenuHidden", null),
        (0, _._)([_._], _.prototype, "ShowSubMenu", null),
        (0, _._)([_._], _.prototype, "RenderSubMenu", null),
        (0, _._)([_._], _.prototype, "OnMouseEnter", null),
        (0, _._)([_._], _.prototype, "OnClick", null);
      let _ = class extends _.Component {
        m_elMenu = void 0;
        m_cReenteranceGuard = 1;
        m_mutationObserver;
        constructor(_) {
          super(_),
            (this.state = {
              ready: !1,
              menuLeft: void 0,
              menuTop: void 0,
              menuRight: void 0,
              menuBottom: void 0,
              menuWidth: void 0,
              menuHeight: void 0,
              menuMinWidth: void 0,
            }),
            (this.m_mutationObserver = new MutationObserver(
              this.OnMenuMutation,
            ));
        }
        get parentWin() {
          return (
            this.props.element?.ownerDocument.defaultView ||
            this.props.parentWin
          );
        }
        BindMenuElement(_) {
          this.props.instance.SetElement(_),
            this.m_elMenu &&
              (this.m_mutationObserver.disconnect(),
              (this.props.popup && !this.props.options.bScreenCoordinates) ||
                this.m_elMenu.ownerDocument.defaultView?.removeEventListener(
                  "resize",
                  this.OnWindowResize,
                )),
            _ &&
              (this.m_mutationObserver.observe(_, {
                childList: !0,
                subtree: !0,
              }),
              (this.props.popup && !this.props.options.bScreenCoordinates) ||
                _.ownerDocument.defaultView?.addEventListener(
                  "resize",
                  this.OnWindowResize,
                )),
            (this.m_elMenu = _ || void 0),
            _._.IN_CLIENT && this.props.popup && this.m_elMenu
              ? this.m_elMenu.ownerDocument.fonts.ready.then(() => {
                  this.PositionMenu();
                })
              : this.PositionMenu(),
            this.state.ready ||
              (this.props.instance.SetTakeFocus(this.TakeFocus.bind(this)),
              this.setState(
                {
                  ready: !0,
                },
                () => {
                  this.props.options?.bSkipFocusWhenReady || this.TakeFocus();
                },
              ));
        }
        OnMenuMutation(_, _) {
          this.PositionMenu();
        }
        OnWindowResize() {
          this.PositionMenu();
        }
        OnBlur(_) {
          if (
            (!_.relatedTarget || !_(_.currentTarget, _.relatedTarget)) &&
            (!_.relatedTarget ||
              !this.props.instance.BIsElementInMenuHierarchy(
                _.relatedTarget,
              )) &&
            !this.props.instance.BIsSubMenuVisible() &&
            this.state.ready &&
            this.props.instance.visible
          ) {
            const _ = _() ? 150 : 0;
            this.props.instance.OnCancel(_);
          }
        }
        OnKeyDown(_) {
          27 == _.keyCode &&
            this.state.ready &&
            (this.props.instance.Hide(),
            _.preventDefault(),
            _.stopPropagation());
        }
        componentDidUpdate() {
          this.m_cReenteranceGuard-- > 0
            ? this.PositionMenu()
            : (this.m_cReenteranceGuard = 2);
        }
        TakeFocus() {
          if (
            this.m_elMenu &&
            this.state.ready &&
            this.props.instance.visible &&
            (this.props.popup ||
              !_(this.m_elMenu, this.m_elMenu.ownerDocument.activeElement))
          ) {
            let _ = this.m_elMenu.querySelector(".ContextMenuAutoFocus");
            _ && _.focus ? _.focus() : this.m_elMenu.focus();
          }
        }
        PositionMenu(_ = !1) {
          const _ = this.props.options;
          let _ = this.m_elMenu,
            _ = this.props.element;
          if (!_) return;
          let _ = null != this.props.popup,
            _ = this.parentWin;
          if (!_ || (_ && "none" === _.getComputedStyle(_).display)) return;
          let _ = this.props.clientX,
            _ = this.props.clientY,
            _ = 0,
            _ = 0,
            _ = _.innerWidth,
            _ = _.innerHeight,
            _ = _?.getBoundingClientRect();
          if (_)
            if (
              (_.bScreenCoordinates ||
                void 0 === _ ||
                void 0 === _ ||
                ((_ += _.screenLeft), (_ += _.screenTop)),
              _ && (_ = _(_, _)),
              _.targetMonitor)
            )
              (_ = _.targetMonitor.nScreenLeft),
                (_ = _.targetMonitor.nScreenTop),
                (_ = _.targetMonitor.nScreenWidth),
                (_ = _.targetMonitor.nScreenHeight);
            else {
              let _ = _.screen,
                _ = 0,
                _ = 0;
              _.availLeft && (_ = _.availLeft),
                _.availTop && (_ = _.availTop),
                (_ = _),
                (_ = _),
                (_ = _.availWidth),
                (_ = _.availHeight);
            }
          (_.bOverlapHorizontal || _.bOverlapVertical) && (_ = _ = void 0);
          const _ = __webpack_require__.getBoundingClientRect();
          let _ = {
              menuLeft: void 0,
              menuRight: void 0,
              menuTop: void 0,
              menuBottom: void 0,
              menuWidth: void 0,
              menuHeight: void 0,
              menuMinWidth: void 0,
            },
            _ = _ ?? _.left,
            _ = _ ?? _.right,
            _ = _.width;
          _.bMatchWidth && ((_ = _ - _), (_.menuWidth = _)),
            _.bGrowToElementWidth && (_.menuMinWidth = Math.max(_, _ - _));
          let _ = (_.bOverlapHorizontal ? _ : _) - _ - _,
            _ = _ > 0,
            _ = _ + _ - (_.bOverlapHorizontal ? _ : _) - _,
            _ = _ > 0,
            _ = _.bPreferPopLeft;
          _?.matches(":dir(rtl)") && (_ = !_);
          let _ = (_ || !_) && _;
          _ ||
            _ ||
            ((_ = _ > _),
            _.bFitToWindow && ((_ += (_ ? _ : _) - 8), (_.menuWidth = _))),
            _
              ? (_.menuRight = _ - (_.bOverlapHorizontal ? _ : _))
              : (_.menuLeft = _.bOverlapHorizontal ? _ : _);
          let _ = _ ?? _.top,
            _ = _ ?? _.bottom,
            _ = _.scrollHeight;
          _.bMatchHeight && ((_ = _ - _), (_.menuHeight = _));
          let _ = (_.bOverlapVertical ? _ : _) - _ - _,
            _ = _ > 0,
            _ = _ + _ - (_.bOverlapVertical ? _ : _) - _,
            _ = _ > 0,
            _ = (_.bPreferPopTop || !_) && _ && !_.bDisablePopTop;
          if (!_ && !_) {
            const _ =
              void 0 !== _.bShiftToFitWindow
                ? _.bShiftToFitWindow
                : !!_.bFitToWindow && !_.bOverlapHorizontal;
            (_ = _ > _ && !_.bDisablePopTop),
              _ && (_ ? (_.menuTop = 4) : (_.menuBottom = 4)),
              _.bFitToWindow &&
                (_ ? (_ = Math.min(_, _ - 8)) : (_ += _ ? _ : _),
                (_.menuHeight = _ - 8));
          }
          void 0 === _.menuBottom &&
            void 0 === _.menuTop &&
            (_
              ? (_.menuBottom = _ - (_.bOverlapVertical ? _ : _))
              : (_.menuTop = _.bOverlapVertical ? _ : _)),
            _
              ? (_.menuHeight || (_.menuHeight = _.height),
                _.menuWidth || (_.menuWidth = _.width),
                _.menuBottom &&
                  !_.menuTop &&
                  ((_.menuTop = _ - _.menuBottom - _.menuHeight),
                  (_.menuBottom = void 0)),
                _.menuRight &&
                  !_.menuLeft &&
                  ((_.menuLeft = _ - _.menuRight - _.menuWidth),
                  (_.menuRight = void 0)))
              : "fixed" != _.getComputedStyle(_).position &&
                (_.menuLeft && (_.menuLeft += _.scrollX),
                _.menuTop && (_.menuTop += _.scrollY),
                _.menuBottom &&
                  (_.menuBottom +=
                    _.document.body.clientHeight - _.scrollY - _.innerHeight),
                _.menuRight &&
                  (_.menuRight +=
                    _.document.body.clientWidth - _.scrollX - _.innerWidth)),
            (_ ||
              _.menuLeft !== this.state.menuLeft ||
              _.menuRight !== this.state.menuRight ||
              _.menuTop !== this.state.menuTop ||
              _.menuBottom !== this.state.menuBottom ||
              _.menuWidth !== this.state.menuWidth ||
              _.menuHeight !== this.state.menuHeight) &&
              this.setState(_);
        }
        PositionPopupWindow() {
          if (
            !(
              void 0 !== this.state.menuLeft &&
              void 0 !== this.state.menuTop &&
              void 0 !== this.state.menuWidth &&
              void 0 !== this.state.menuHeight
            )
          )
            return;
          const _ = this.props.popup?.window,
            _ = this.props.options;
          if (_.bScreenCoordinates) {
            const _ =
              _.targetMonitor?.flScaleToTargetMonitor ??
              this.parentWin?.devicePixelRatio;
            return (
              _?.SteamClient.Window.MoveTo(
                this.state.menuLeft,
                this.state.menuTop,
                _ ?? !0,
              ),
              void _?.SteamClient.Window.ResizeTo(
                this.state.menuWidth,
                this.state.menuHeight,
                _ ?? !0,
              )
            );
          }
          this.parentWin?.SteamClient.Window.GetWindowRestoreDetails().then(
            (_) => {
              const _ = this.state.menuLeft - this.parentWin.screenX,
                _ = this.state.menuTop - this.parentWin.screenY;
              try {
                _?.SteamClient.Window.PositionWindowRelative(
                  _,
                  _,
                  _,
                  this.state.menuWidth,
                  this.state.menuHeight,
                );
              } catch (_) {
                console.error(_);
              }
            },
          );
        }
        render() {
          let _ = {
            visibility: this.state.ready ? "visible" : "hidden",
          };
          this.props.options.flElementZoom &&
            this.props.options.flElementZoom > 0 &&
            (_.zoom = this.props.options.flElementZoom),
            this.props.popup
              ? (this.PositionPopupWindow(),
                void 0 !== this.state.menuMinWidth &&
                  (_.minWidth = Math.floor(this.state.menuMinWidth)))
              : (void 0 !== this.state.menuTop
                  ? (_.top = this.state.menuTop)
                  : void 0 !== this.state.menuBottom &&
                    (_.bottom = this.state.menuBottom),
                void 0 !== this.state.menuLeft
                  ? (_.left = this.state.menuLeft)
                  : void 0 !== this.state.menuRight &&
                    (_.right = this.state.menuRight),
                void 0 !== this.state.menuHeight &&
                  (_.height = this.state.menuHeight),
                void 0 !== this.state.menuWidth &&
                  (_.width = this.state.menuWidth),
                void 0 !== this.state.menuMinWidth &&
                  (_.minWidth = this.state.menuMinWidth));
          let _ = this.props.options.strClassName || _().contextMenu;
          return (
            (this.props.options.bCreateHidden ||
              (this.props.instance.visible && this.state.ready)) &&
              (_ += " visible"),
            this.props.instance.visible && this.state.ready && (_ += " ready"),
            (_ += " " + _().ContextMenuPosition),
            this.props.options.bStandalone && (_ += " " + _().Standalone),
            _.createElement(
              "div",
              {
                className: _,
                ref: this.BindMenuElement,
                style: _,
                onBlur: this.OnBlur,
                onKeyDown: this.OnKeyDown,
                tabIndex: 0,
              },
              this.props.children,
            )
          );
        }
      };
      function _(_) {
        return _.createElement("div", {
          className: _().ContextMenuMouseOverlay,
        });
      }
      function _(_) {
        let _ = [],
          _ = (function (_) {
            let _;
            return (
              _ &&
                _(_.currentTarget) &&
                (_ = _.currentTarget.ownerDocument.defaultView),
              _
            );
          })(_),
          _ = __webpack_require__.getSelection(),
          _ = _ && _.rangeCount > 0 && _.toString().length > 0,
          _ = _.target,
          _ = !1;
        const _ = _.clientY,
          _ = _.clientX;
        if (
          (_ &&
            "tagName" in _ &&
            (("INPUT" != _.tagName && "TEXTAREA" != _.tagName) || (_ = !0)),
          _._.IN_CLIENT && _ && _(_, "Browser.GetSpellingSuggestions"))
        ) {
          let [_, ..._] = _.SteamClient.Browser.GetSpellingSuggestions(),
            _ = _;
          if (
            (_ &&
              _.forEach((_, _) => {
                _.push(
                  _.createElement(
                    _,
                    {
                      key: `spelling_${_}_${_}`,
                      onSelected: () => {
                        _.setRangeText(_),
                          (function (_, _) {
                            let _ = _.createEvent("HTMLEvents");
                            __webpack_require__.initEvent("change", !0, !1),
                              _.dispatchEvent(_);
                          })(_, _.document),
                          _.setSelectionRange(_.selectionEnd, _.selectionEnd),
                          _.focus();
                      },
                      className: _().NoSeparation,
                    },
                    _,
                  ),
                );
              }),
            _ && _(_, "Browser.AddWordToDictionary"))
          ) {
            const _ = 30;
            (_ = _.trim()),
              _.push(
                _.createElement(
                  _,
                  {
                    key: `addtodictionary_${_}`,
                    onSelected: () =>
                      _.SteamClient.Browser.AddWordToDictionary(_),
                  },
                  (0, _._)(
                    "#ContextMenu_AddToDictionary",
                    _.length < _ ? _ : _.substring(0, _) + "...",
                  ),
                ),
              );
          }
        }
        if (
          ((_.document.queryCommandEnabled("cut") || (_ && _)) &&
            _.push(
              _.createElement(
                _,
                {
                  key: "cut",
                  onSelected: () => {
                    _.document.execCommand("cut");
                  },
                },
                (0, _._)("#ContextMenu_Cut"),
              ),
            ),
          (_.document.queryCommandEnabled("copy") || _) &&
            _.push(
              _.createElement(
                _,
                {
                  key: "copy",
                  onSelected: () => {
                    _.document.execCommand("copy");
                  },
                  className: _().NoSeparation,
                },
                (0, _._)("#ContextMenu_Copy"),
              ),
            ),
          _._.IN_CLIENT &&
            _ &&
            _(_, "Browser.Paste") &&
            _.push(
              _.createElement(
                _,
                {
                  key: "paste",
                  onSelected: () => {
                    _.focus(), _.SteamClient.Browser.Paste();
                  },
                  className: _().NoSeparation,
                },
                (0, _._)("#ContextMenu_Paste"),
              ),
            ),
          _._.IN_CLIENT && _._.DEV_MODE)
        ) {
          const _ = [];
          _(_, "Browser.OpenDevTools") &&
            _.push(
              _.createElement(
                _,
                {
                  key: "opendevtools",
                  onSelected: () => {
                    _.focus(), _.SteamClient.Browser.OpenDevTools();
                  },
                },
                "Open Dev Tools",
              ),
            ),
            _(_, "Browser.InspectElement") &&
              _.push(
                _.createElement(
                  _,
                  {
                    key: "inspectelement",
                    onSelected: () => {
                      _.focus(), _.SteamClient.Browser.InspectElement(_, _);
                    },
                    className: _().NoSeparation,
                  },
                  "Inspect Element",
                ),
              ),
            _.length > 0 &&
              (_.push(
                _.createElement(_, {
                  key: "devtools-separator",
                }),
              ),
              _.push(..._));
        }
        if (_.length)
          !(function (_, _, _) {
            let _,
              _,
              _,
              _ = _;
            if (_?.preventDefault && _?.stopPropagation) {
              if (_.shiftKey || (_.altKey && !_?.bRootContextMenu)) return null;
              _.preventDefault(),
                _.stopPropagation(),
                (_ = _.currentTarget),
                (_ = _.clientX),
                (_ = _.clientY);
            } else _ = _;
            const _ = _.GetContextMenuManagerFromWindow(_);
            let _ = _.CreateContextMenuInstance(_, _, _, _, _);
            _.Show(), _?.bCreateHidden && _.Hide();
          })(_.createElement(_, null, _), _, {
            bRootContextMenu: !0,
          });
        else {
          if (_.shiftKey) return;
          _.preventDefault(), _.stopPropagation();
        }
      }
      (0, _._)([_._], _.prototype, "BindMenuElement", null),
        (0, _._)([_._, _(100)], _.prototype, "OnMenuMutation", null),
        (0, _._)([_._], _.prototype, "OnWindowResize", null),
        (0, _._)([_._], _.prototype, "OnBlur", null),
        (0, _._)([_._], _.prototype, "OnKeyDown", null),
        (_ = (0, _._)([_._], _));
      const _ = "EnableContextMenuBlurDelay3";
      function _() {
        return (
          "true" === (window.localStorage && window.localStorage.getItem(_))
        );
      }
      var _ = __webpack_require__("chunkid");
      class _ {
        static s_nNextKeyValue = 1;
        m_nKey = null;
        m_ContextMenuManager;
        m_bVisible = !1;
        m_fnTakeFocus;
        m_element;
        m_rctElement;
        m_rctLabel = void 0;
        m_popupContextMenu;
        m_timerHideMenu = 0;
        m_options;
        m_position;
        m_submenu;
        m_parentInstance;
        m_elSubmenuItem = null;
        m_timerHideSubMenu = 0;
        m_fnOnHideCallback;
        constructor(_, _) {
          (0, _._)(this),
            (this.m_ContextMenuManager = _),
            (this.m_rctElement = _);
        }
        get Manager() {
          return this.m_ContextMenuManager;
        }
        get key() {
          return (
            null == this.m_nKey &&
              ((this.m_nKey = _.s_nNextKeyValue), _.s_nNextKeyValue++),
            this.m_nKey
          );
        }
        SetElement(_) {
          this.m_element = _;
        }
        SetPopup(_) {
          this.m_popupContextMenu = _;
        }
        get ReactElement() {
          return this.m_rctElement;
        }
        get label() {
          return this.m_rctLabel;
        }
        get submenu() {
          return this.m_submenu;
        }
        get visible() {
          return this.m_bVisible;
        }
        get options() {
          return this.m_options;
        }
        get position() {
          return this.m_position;
        }
        SetOnHideCallback(_) {
          this.m_fnOnHideCallback = _;
        }
        Show() {
          this.CancelHideMenuTimer(),
            (this.m_bVisible = !0),
            this.m_ContextMenuManager.ShowMenu(this);
        }
        OnCancel(_ = 0) {
          this.options?.onCancel && this.options.onCancel(), this.Hide(_);
        }
        Hide(_ = 0) {
          _ > 0
            ? (this.m_timerHideMenu = window.setTimeout(() => {
                (this.m_timerHideMenu = 0), this.InternalHide();
              }, _))
            : this.InternalHide();
        }
        CancelHideMenuTimer() {
          this.m_timerHideMenu > 0 &&
            (clearTimeout(this.m_timerHideMenu), (this.m_timerHideMenu = 0));
        }
        SetPosition(_, _, _) {
          (this.m_options = {
            ...this.m_options,
            ..._,
          }),
            (this.m_position.clientX = _),
            (this.m_position.clientY = _),
            (this.m_position.options = this.m_options);
        }
        ForceHide() {
          this.InternalHide();
        }
        HideIfNotInFocus() {
          this.BHasFocus() || this.BIsFocusInChildHierarchy() || this.Hide();
        }
        InternalHide() {
          this.CancelHideMenuTimer(),
            this.m_bVisible &&
              ((this.m_bVisible = !1),
              this.InternalHideSubMenu(),
              this.m_fnOnHideCallback && this.m_fnOnHideCallback(),
              this.m_ContextMenuManager.HideMenu(this));
        }
        SetTakeFocus(_) {
          this.m_fnTakeFocus = _;
        }
        ShowSubMenu(_, _) {
          return this.m_elSubmenuItem == _
            ? (this.CancelHideSubMenuTimer(), this.m_submenu?.TakeFocus(), null)
            : (this.InternalHideSubMenu(),
              (this.m_elSubmenuItem = _),
              (this.m_submenu = new _(
                this,
                _(),
                _,
                this.m_options.bForcePopup,
              )),
              this.m_submenu.Show(),
              this.m_submenu);
        }
        CancelHideSubMenuTimer() {
          this.m_timerHideSubMenu > 0 &&
            (clearTimeout(this.m_timerHideSubMenu),
            (this.m_timerHideSubMenu = 0));
        }
        HideSubMenu() {
          if (!this.m_submenu) return void this.CancelHideSubMenuTimer();
          if (this.m_timerHideSubMenu > 0) return;
          this.m_timerHideSubMenu = window.setTimeout(() => {
            this.InternalHideSubMenu(), (this.m_timerHideSubMenu = 0);
          }, 150);
        }
        OnSubMenuDismissed(_) {
          this.m_submenu == _ && this.InternalHideSubMenu();
        }
        HideSelf() {
          this.m_parentInstance
            ? this.m_parentInstance.OnSubMenuDismissed(this)
            : this.InternalHide();
        }
        InternalHideSubMenu() {
          this.CancelHideSubMenuTimer(),
            this.m_submenu &&
              (this.m_submenu.m_element &&
                this.BIsFocusInChildHierarchy() &&
                this.TakeFocus(_._.k_EWindowBringToFrontAndForceOS),
              (this.m_elSubmenuItem = null),
              this.m_submenu.InternalHide(),
              (this.m_submenu = void 0));
        }
        TakeFocus(_ = _._.k_EWindowBringToFrontAndForceOS) {
          this.m_popupContextMenu && this.m_popupContextMenu.Focus(_),
            this.m_fnTakeFocus && this.m_fnTakeFocus();
        }
        BInternalElementInParentHierarchy(_) {
          return (
            null != this.m_parentInstance &&
            (this.m_parentInstance.BIsChildElement(_) ||
              this.m_parentInstance.BInternalElementInParentHierarchy(_))
          );
        }
        BInternalElementInChildHierarchy(_) {
          return (
            null != this.m_submenu &&
            (this.m_submenu.BIsChildElement(_) ||
              this.m_submenu.BInternalElementInChildHierarchy(_))
          );
        }
        BIsChildElement(_) {
          return this.m_element
            ? _(this.m_element, _)
            : _(this.m_popupContextMenu?.root_element, _);
        }
        BHasFocus() {
          return this.m_popupContextMenu
            ? this.m_popupContextMenu.focused
            : _(this.m_element, this.m_element?.ownerDocument.activeElement);
        }
        BIsFocusInChildHierarchy() {
          return (
            null != this.m_submenu &&
            (this.m_submenu.BHasFocus() ||
              this.m_submenu.BIsFocusInChildHierarchy())
          );
        }
        BIsElementInMenuHierarchy(_) {
          return (
            this.BInternalElementInParentHierarchy(_) ||
            this.BInternalElementInChildHierarchy(_)
          );
        }
        BIsSubMenuVisible() {
          return !!this.m_submenu;
        }
        SetLabel(_) {
          this.m_rctLabel = _;
        }
      }
      (0, _._)([_._], _.prototype, "m_bVisible", void 0),
        (0, _._)([_._.ref], _.prototype, "m_rctLabel", void 0);
      class _ extends _ {
        constructor(_, _, _, _, _, _) {
          super(_, _),
            (this.m_options = _ || {}),
            (this.m_position = {
              element: _,
              clientX: _,
              clientY: _,
              instance: this,
              options: this.m_options,
              fnOnMenuItemSelected: () => {
                this.Hide();
              },
            });
        }
        Show() {
          super.Show();
        }
        Hide(_ = 0) {
          super.Hide(_);
        }
        ForceHide() {
          super.ForceHide();
        }
        BIsSubMenu() {
          return !1;
        }
      }
      class _ extends _ {
        constructor(_, _, _, _) {
          super(_.Manager, _),
            (this.m_parentInstance = _),
            (this.m_options = {
              bOverlapVertical: !0,
              strClassName: _.options.strClassName,
              bFitToWindow: _.options.bFitToWindow,
              bShiftToFitWindow: _.options.bShiftToFitWindow,
              bForcePopup: _,
            }),
            (this.m_position = {
              element: _,
              clientX: void 0,
              clientY: void 0,
              instance: this,
              options: this.m_options,
              fnOnMenuItemSelected: () => {
                this.Hide();
              },
              bSubmenu: !0,
            });
        }
        Hide() {
          this.m_popupContextMenu
            ? window.setTimeout(() => {
                this.m_parentInstance?.HideIfNotInFocus();
              }, 10)
            : this.m_parentInstance?.Hide();
        }
        ForceHide() {
          this.m_parentInstance?.ForceHide();
        }
        BIsSubMenu() {
          return !0;
        }
      }
      var _ = __webpack_require__("chunkid");
      class _ {
        m_callbacksMenusChanged = new _._();
        m_ActiveMenu;
        m_rgActiveSubmenus = [];
        m_setHiddenMenus = new Set();
        constructor() {}
        CreateContextMenuInstance(_, _, _, _, _) {
          const _ = new _(this, _, _, _, _, _);
          return (
            _?.bCreateHidden &&
              (this.m_setHiddenMenus.add(_),
              this.m_callbacksMenusChanged.Dispatch()),
            _
          );
        }
        get OnMenusChanged() {
          return this.m_callbacksMenusChanged;
        }
        HideActiveMenu() {
          this.m_ActiveMenu?.options.bRetainOnHide
            ? this.m_setHiddenMenus.add(this.m_ActiveMenu)
            : this.m_rgActiveSubmenus.length && (this.m_rgActiveSubmenus = []),
            (this.m_ActiveMenu = void 0);
        }
        get ActiveMenu() {
          return this.m_ActiveMenu;
        }
        GetVisibleMenus() {
          return this.m_ActiveMenu
            ? [this.m_ActiveMenu, ...this.m_rgActiveSubmenus]
            : [];
        }
        GetHiddenMenus() {
          return Array.from(this.m_setHiddenMenus);
        }
        GetAllMenus() {
          let _;
          return (
            (_ = this.m_ActiveMenu
              ? [
                  this.m_ActiveMenu,
                  ...this.m_rgActiveSubmenus,
                  ...Array.from(this.m_setHiddenMenus),
                ]
              : [
                  ...this.m_rgActiveSubmenus,
                  ...Array.from(this.m_setHiddenMenus),
                ]),
            _.sort((_, _) => _.key - _.key)
          );
        }
        BShouldRenderMouseOverlay() {
          return (
            this.m_ActiveMenu && !this.m_ActiveMenu.options.bDisableMouseOverlay
          );
        }
        ShowMenu(_) {
          if (_.BIsSubMenu()) this.m_rgActiveSubmenus.push(_);
          else {
            if (_ == this.m_ActiveMenu) return;
            this.m_ActiveMenu &&
              (this.m_ActiveMenu.options.bRetainOnHide &&
                this.m_setHiddenMenus.add(this.m_ActiveMenu),
              this.m_ActiveMenu.Hide()),
              (this.m_ActiveMenu = _),
              this.m_setHiddenMenus.delete(_);
          }
          this.m_callbacksMenusChanged.Dispatch();
        }
        HideMenu(_) {
          _.BIsSubMenu()
            ? _._(this.m_rgActiveSubmenus, _) &&
              this.m_callbacksMenusChanged.Dispatch()
            : ((0, _._)(_ == this.m_ActiveMenu, "Call to hide inactive menu"),
              _ == this.m_ActiveMenu &&
                (this.HideActiveMenu(),
                this.m_callbacksMenusChanged.Dispatch()));
        }
        ReleaseHiddenMenu(_) {
          this.m_setHiddenMenus.delete(_);
        }
      }
      const _ = new (class {
        m_mapManagers = new WeakMap();
        GetContextMenuManagerFromWindow(_) {
          let _ = _?.ownerDocument?.defaultView || window;
          return this.GetContextMenuManager(_);
        }
        GetContextMenuManager(_) {
          let _ = this.m_mapManagers.get(_);
          if (!_) {
            let _ = _;
            for (; !_ && _.opener; )
              (_ = _.opener), (_ = this.m_mapManagers.get(_));
          }
          return _ || ((_ = new _()), this.m_mapManagers.set(_, _)), _;
        }
        SetMenuManager(_, _) {
          (0, _._)(
            void 0 === this.m_mapManagers.get(_) || !_ || _ == window,
            `Stomping CContextMenuManager for ${_.document.title}!`,
          ),
            this.m_mapManagers.set(_, _);
        }
        RegisterChildWindow(_, _) {
          return (
            this.m_mapManagers.set(_, this.GetContextMenuManager(_)),
            () => this.m_mapManagers.delete(_)
          );
        }
      })();
      var _, _, _, _;
      !(function (_) {
        (_[(_.EBrowserType_OffScreen = 0)] = "EBrowserType_OffScreen"),
          (_[(_.EBrowserType_OpenVROverlay = 1)] =
            "EBrowserType_OpenVROverlay"),
          (_[(_.EBrowserType_OpenVROverlay_Dashboard = 2)] =
            "EBrowserType_OpenVROverlay_Dashboard"),
          (_[(_.EBrowserType_DirectHWND = 3)] = "EBrowserType_DirectHWND"),
          (_[(_.EBrowserType_DirectHWND_Borderless = 4)] =
            "EBrowserType_DirectHWND_Borderless"),
          (_[(_.EBrowserType_ChildHWNDNative = 6)] =
            "EBrowserType_ChildHWNDNative"),
          (_[(_.EBrowserType_Offscreen_SteamUI = 12)] =
            "EBrowserType_Offscreen_SteamUI"),
          (_[(_.EBrowserType_OpenVROverlay_Subview = 13)] =
            "EBrowserType_OpenVROverlay_Subview");
      })(_ || (_ = {})),
        (function (_) {
          (_[(_.SystemKey0 = 0)] = "SystemKey0"),
            (_[(_.SystemKey1 = 1)] = "SystemKey1");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.Hidden = 0)] = "Hidden"),
            (_[(_.Notification = 1)] = "Notification"),
            (_[(_.Overlay = 2)] = "Overlay"),
            (_[(_.Opaque = 3)] = "Opaque"),
            (_[(_.OverlayKeyboard = 4)] = "OverlayKeyboard");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.MainGamepadUI = 0)] = "MainGamepadUI"),
            (_[(_.OverlayGamepadUI = 1)] = "OverlayGamepadUI"),
            (_[(_.Keyboard = 2)] = "Keyboard"),
            (_[(_.ControllerConfigurator = 3)] = "ControllerConfigurator"),
            (_[(_._ = 4)] = "VR"),
            (_[(_.MainDesktopUI = 5)] = "MainDesktopUI"),
            (_[(_.DesktopLogin = 6)] = "DesktopLogin"),
            (_[(_.OverlayDesktopUI = 7)] = "OverlayDesktopUI"),
            (_[(_.SteamChinaReviewLauncher = 8)] = "SteamChinaReviewLauncher");
        })(_ || (_ = {}));
      const _ = {
        m_unPID: 0,
        m_nBrowserID: -1,
      };
      class _ {
        m_fnRender;
        m_rgLoadingLinks = [];
        constructor(_, _, _) {
          if (((this.m_rgLoadingLinks = []), _))
            for (let _ = 0; _ < _.length; _++) this.AddLink(_[_], !0);
          else if (_) {
            let _ = _.getElementsByTagName("link");
            for (let _ = 0; _ < _.length; _++) {
              let _ = _[_];
              this.AddLink(_, !1);
            }
          }
        }
        AddLink(_, _) {
          if (_) {
            let _ = !1;
            try {
              (_.sheet && _.sheet.cssRules && 0 != _.sheet.cssRules.length) ||
                (_ = !0);
            } catch (_) {}
            _ &&
              (_.addEventListener("load", this.OnLinkLoad),
              this.m_rgLoadingLinks.push(_));
          } else
            _.addEventListener("load", this.OnLinkLoad),
              this.m_rgLoadingLinks.push(_);
        }
        SetTarget(_) {
          (this.m_fnRender = _),
            0 == this.m_rgLoadingLinks.length &&
              (this.m_fnRender(), (this.m_fnRender = void 0));
        }
        OnLinkLoad(_) {
          _.currentTarget.removeEventListener("load", this.OnLinkLoad),
            _._(this.m_rgLoadingLinks, _.currentTarget),
            0 == this.m_rgLoadingLinks.length &&
              (this.m_fnRender?.(), (this.m_fnRender = void 0));
        }
      }
      (0, _._)([_._], _.prototype, "OnLinkLoad", null);
      new Set([
        "sc_schinese",
        "schinese",
        "tchinese",
        "japanese",
        "koreana",
        "thai",
        "arabic",
        "bulgarian",
        "czech",
        "danish",
        "german",
        "english",
        "spanish",
        "latam",
        "greek",
        "french",
        "italian",
        "indonesian",
        "hungarian",
        "dutch",
        "norwegian",
        "polish",
        "portuguese",
        "brazilian",
        "romanian",
        "russian",
        "finnish",
        "swedish",
        "turkish",
        "vietnamese",
        "ukrainian",
      ]);
      const _ = new Map([
        ["en", "english"],
        ["de", "german"],
        ["fr", "french"],
        ["it", "italian"],
        ["ko", "koreana"],
        ["es-419", "latam"],
        ["es", "spanish"],
        ["zh", "schinese"],
        ["zh-cn", "schinese"],
        ["zh-tw", "tchinese"],
        ["ru", "russian"],
        ["ar", "arabic"],
        ["th", "thai"],
        ["ja", "japanese"],
        ["pt-br", "brazilian"],
        ["pt", "portuguese"],
        ["pl", "polish"],
        ["da", "danish"],
        ["nl", "dutch"],
        ["fi", "finnish"],
        ["nb", "norwegian"],
        ["no", "norwegian"],
        ["sv", "swedish"],
        ["hu", "hungarian"],
        ["cs", "czech"],
        ["ro", "romanian"],
        ["tr", "turkish"],
        ["bg", "bulgarian"],
        ["el", "greek"],
        ["uk", "ukrainian"],
        ["vn", "vietnamese"],
        ["vi", "vietnamese"],
        ["id", "indonesian"],
      ]);
      const _ = new Map();
      for (const [module, module_exports] of _.entries())
        _.set(module_exports, module);
      var _, _;
      function _() {
        return (0, _._)() ? _.Composited : _.None;
      }
      function _(_) {
        let _ = _.None;
        switch (_) {
          case _.Overlay:
            return (
              (_ |= _.AlwaysOnTop),
              (_ |= _.NoTaskbarIcon),
              (_ |= _.NotFocusable),
              (_ |= _.TransparentParentWindow),
              _
            );
          case _.Notification:
            return (
              (_ |= _(_.Overlay)),
              (_ |= _.NoWindowShadow),
              (_ |= _.NoRoundedCorners),
              (_ |= _.OverrideRedirect),
              (_ |= _.ForceBrowserVisible),
              _
            );
          case _.Tooltip:
            return (
              (_ |= _(_.Overlay)),
              (_ |= _.NoRoundedCorners),
              (_ |= _.NoWindowShadow),
              (_ |= _.TooltipHint),
              (_ |= _()),
              _
            );
          case _.PopupContextMenu:
            return (
              (_ |= _.NoTaskbarIcon),
              (_ |= _.NoRoundedCorners),
              (_ |= _.NoWindowShadow),
              (_ |= _.PopUpMenuHint),
              (_ |= _.TransparentParentWindow),
              (_ |= _()),
              _
            );
          case _.StandaloneContextMenu:
            return (
              (_ = _.NoTaskbarIcon),
              (_ |= _.NoRoundedCorners),
              (_ |= _.NoWindowShadow),
              (_ |= _.OverrideRedirect),
              (_ |= _.TransparentParentWindow),
              (_ |= _()),
              _
            );
        }
      }
      _.set("sc_schinese", _.get("schinese")),
        _.set("korean", _.get("koreana")),
        (function (_) {
          (_[(_.None = 0)] = "None"),
            (_[(_.Minimized = 1)] = "Minimized"),
            (_[(_.Hidden = 2)] = "Hidden"),
            (_[(_.TooltipHint = 4)] = "TooltipHint"),
            (_[(_.NoTaskbarIcon = 8)] = "NoTaskbarIcon"),
            (_[(_.Resizable = 16)] = "Resizable"),
            (_[(_.ScalePosition = 32)] = "ScalePosition"),
            (_[(_.ScaleSize = 64)] = "ScaleSize"),
            (_[(_.Maximized = 128)] = "Maximized"),
            (_[(_.Composited = 256)] = "Composited"),
            (_[(_.NotFocusable = 512)] = "NotFocusable"),
            (_[(_.FullScreen = 1024)] = "FullScreen"),
            (_[(_.Fullscreen_Exclusive = 2048)] = "Fullscreen_Exclusive"),
            (_[(_.ApplyBrowserScaleToDimensions = 4096)] =
              "ApplyBrowserScaleToDimensions"),
            (_[(_.AlwaysOnTop = 8192)] = "AlwaysOnTop"),
            (_[(_.NoWindowShadow = 16384)] = "NoWindowShadow"),
            (_[(_.NoMinimize = 32768)] = "NoMinimize"),
            (_[(_.PopUpMenuHint = 65536)] = "PopUpMenuHint"),
            (_[(_.IgnoreSavedSize = 131072)] = "IgnoreSavedSize"),
            (_[(_.NoRoundedCorners = 262144)] = "NoRoundedCorners"),
            (_[(_.ForceRoundedCorners = 524288)] = "ForceRoundedCorners"),
            (_[(_.OverrideRedirect = 1048576)] = "OverrideRedirect"),
            (_[(_.IgnoreSteamDisplayScale = 2097152)] =
              "IgnoreSteamDisplayScale"),
            (_[(_.TransparentParentWindow = 4194304)] =
              "TransparentParentWindow"),
            (_[(_.DisableDPIScale = 8388608)] = "DisableDPIScale"),
            (_[(_.ForceBrowserVisible = 16777216)] = "ForceBrowserVisible");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.Overlay = 0)] = "Overlay"),
            (_[(_.Notification = 1)] = "Notification"),
            (_[(_.Tooltip = 2)] = "Tooltip"),
            (_[(_.PopupContextMenu = 3)] = "PopupContextMenu"),
            (_[(_.StandaloneContextMenu = 4)] = "StandaloneContextMenu");
        })(_ || (_ = {}));
      const _ = _.createContext({
          ownerWindow: window,
        }),
        _ = () => _.useContext(_);
      function _(_) {
        const { ownerWindow: _, children: __webpack_require__ } = _,
          _ = _.useMemo(
            () => ({
              ownerWindow: _,
            }),
            [_],
          );
        return _.createElement(
          _.Provider,
          {
            value: _,
          },
          __webpack_require__,
        );
      }
      class _ {
        m_strName;
        m_strTitle;
        m_rgParams;
        m_popup;
        m_element;
        m_renderWhenReady;
        m_bCreateHidden;
        m_bCreated = !1;
        m_onCreateRender = null;
        m_bFocused = !1;
        constructor(_, _) {
          (0, _._)(this),
            (0, _._)(
              _,
              "Name is required.  This is an internal name, different from title.",
            ),
            (this.m_strName = _);
          const { title: __webpack_require__, eCreationFlags: _, ..._ } = _;
          (this.m_rgParams = {
            ..._,
            eCreationFlags: _ ?? 0,
          }),
            this.m_rgParams.target_browser &&
              (this.m_strName +=
                "_uid" + this.m_rgParams.target_browser.m_unPID),
            (this.m_bCreateHidden = !!(
              this.m_rgParams.eCreationFlags & _.Hidden
            )),
            (this.m_strTitle = __webpack_require__);
        }
        UpdateParamsBeforeShow(_) {
          return _;
        }
        OnDrop(_) {
          console.log("Ignoring drop onto toplevel window", _),
            _.preventDefault(),
            _.stopPropagation();
        }
        OnDragOver(_) {
          _.preventDefault(),
            (_.dataTransfer.dropEffect = "none"),
            _.stopPropagation();
        }
        OnMessage(_) {
          "window_moved" === _.data && this.OnMove(),
            "window_resized" === _.data && this.OnResize(),
            "popup-created" === _.data && this.OnCreateInternal();
        }
        Show(_ = _._.k_EWindowBringToFrontAndForceOS) {
          let _;
          (_ =
            "boolean" == typeof _
              ? _
                ? _._.k_EWindowBringToFrontAndForceOS
                : _._.k_EWindowBringToFrontInvalid
              : _),
            window.SteamClient && (this.m_rgParams.eCreationFlags |= _.Hidden),
            this.m_rgParams.eCreationFlags & _.NotFocusable &&
              (_ = _._.k_EWindowBringToFrontInvalid),
            this.BIsValid() &&
              (this.BIsClosed()
                ? ((this.m_popup = void 0), (this.m_element = void 0))
                : _ != _._.k_EWindowBringToFrontInvalid && this.Focus(_));
          let _,
            _,
            _,
            _ = _.GetExistingPopup(this.m_strName);
          (_ && !this.m_rgParams.replace_existing_popup) ||
            ((this.m_rgParams = this.UpdateParamsBeforeShow(this.m_rgParams)),
            _
              ? ((_ = _.m_element),
                (_ = _.m_popup),
                (_ = _.m_renderWhenReady),
                _.RemoveTrackedPopup(_),
                _.ReleasePopup(),
                __webpack_require__?.removeEventListener(
                  "beforeunload",
                  _.OnBeforeUnloadEvent,
                ),
                __webpack_require__?.removeEventListener("unload", _.OnUnload),
                __webpack_require__?.removeEventListener(
                  "resize",
                  _.OnResizeEvent,
                ),
                __webpack_require__?.removeEventListener(
                  "focus",
                  this.OnFocusInternal,
                ),
                __webpack_require__?.removeEventListener(
                  "blur",
                  this.OnBlurInternal,
                ),
                __webpack_require__?.removeEventListener("drop", _.OnDrop),
                __webpack_require__?.removeEventListener(
                  "dragover",
                  _.OnDragOver,
                ),
                __webpack_require__?.removeEventListener(
                  "message",
                  this.OnMessage,
                ))
              : (({ popup: _, element: _ } = _.CreatePopup(this.m_strName, {
                  ...this.m_rgParams,
                  title: this.m_strTitle,
                })),
                (_ = new _(_?.document, _))),
            _ &&
              _ &&
              ((_.document.title = this.m_strTitle),
              __webpack_require__.addEventListener(
                "beforeunload",
                this.OnBeforeUnloadEvent,
              ),
              __webpack_require__.addEventListener("unload", this.OnUnload),
              __webpack_require__.addEventListener(
                "resize",
                this.OnResizeEvent,
              ),
              __webpack_require__.addEventListener(
                "focus",
                this.OnFocusInternal,
              ),
              __webpack_require__.addEventListener("blur", this.OnBlurInternal),
              __webpack_require__.addEventListener("drop", this.OnDrop),
              __webpack_require__.addEventListener("dragover", this.OnDragOver),
              __webpack_require__.addEventListener("message", this.OnMessage),
              _._.LANGUAGE &&
                (_.document.documentElement.setAttribute(
                  "lang",
                  (0, _._)() ?? "",
                ),
                "arabic" === _._.LANGUAGE &&
                  _.document.documentElement.setAttribute("dir", "rtl")),
              (this.m_popup = _),
              (this.m_element = _),
              (this.m_renderWhenReady = _),
              this.m_renderWhenReady?.SetTarget(() => {
                this.m_popup &&
                  this.m_element &&
                  this.RenderInternal(this.m_popup, this.m_element, _);
              })),
            _.AddTrackedPopup(this),
            _ &&
              (this.OnCreateInternal(),
              _ != _._.k_EWindowBringToFrontInvalid && this.Focus(_)));
        }
        RemoveEventListeners() {
          this.window?.removeEventListener(
            "beforeunload",
            this.OnBeforeUnloadEvent,
          ),
            this.window?.removeEventListener("unload", this.OnUnload),
            this.window?.removeEventListener("resize", this.OnResizeEvent),
            this.window?.removeEventListener("focus", this.OnFocusInternal),
            this.window?.removeEventListener("blur", this.OnBlurInternal),
            this.window?.removeEventListener("drop", this.OnDrop),
            this.window?.removeEventListener("dragover", this.OnDragOver),
            this.window?.removeEventListener("message", this.OnMessage);
        }
        RenderInternal(_, _, _) {
          var _;
          this.m_bCreated
            ? (this.browser_info &&
                ((_ = this.browser_info.m_eBrowserType) ==
                  _.EBrowserType_OpenVROverlay ||
                  _ == _.EBrowserType_OpenVROverlay_Dashboard ||
                  _ == _.EBrowserType_OpenVROverlay_Subview) &&
                (_.ownerDocument.body.className += " VR"),
              this.Render(_, _),
              this.OnLoad(),
              _?.SteamClient &&
                !this.m_bCreateHidden &&
                (_ != _._.k_EWindowBringToFrontInvalid
                  ? _.SteamClient.Window.BringToFront(_)
                  : _.SteamClient.Window.ShowWindow()))
            : (this.m_onCreateRender = () => this.RenderInternal(_, _, _));
        }
        OnCreateInternal() {
          this.m_bCreated ||
            ((this.m_bCreated = !0),
            this.OnCreate(),
            this.m_onCreateRender &&
              (this.m_onCreateRender(), (this.m_onCreateRender = null)));
        }
        OnCreate() {}
        OnResizeEvent() {
          this.OnResize();
        }
        OnBeforeUnloadEvent() {
          this.OnBeforeUnload();
        }
        OnUnload(_) {
          this.RemoveEventListeners(),
            _.RemoveTrackedPopup(this),
            this.OnClose(),
            (this.m_popup = void 0);
        }
        get browser_info() {
          return this.m_rgParams.target_browser;
        }
        get window() {
          return this.m_popup;
        }
        get root_element() {
          return this.m_element;
        }
        get title() {
          return this.m_strTitle;
        }
        set title(_) {
          (this.m_strTitle = _),
            this.m_popup && (this.m_popup.document.title = this.m_strTitle);
        }
        get params() {
          return this.m_rgParams;
        }
        Focus(_ = _._.k_EWindowBringToFrontAndForceOS) {
          _ != _._.k_EWindowBringToFrontInvalid &&
            (this.m_popup &&
            void 0 !== this.m_popup.SteamClient &&
            void 0 !== this.m_popup.SteamClient.Window
              ? this.m_popup.SteamClient.Window.BringToFront(_)
              : this.m_popup && this.m_popup.focus());
        }
        Close() {
          this.m_popup &&
            (_(this.m_popup.window, "Window.Close")
              ? this.m_popup.window.SteamClient.Window.Close()
              : this.m_popup.window.close());
        }
        GetName() {
          return this.m_strName;
        }
        BIsValid() {
          return !!this.m_popup;
        }
        BIsClosed() {
          return !this.m_popup || this.m_popup.closed;
        }
        BIsVisible() {
          return !(
            !this.m_popup ||
            this.m_popup.closed ||
            "visible" != this.m_popup.document.visibilityState
          );
        }
        BIsFocused() {
          return this.BIsVisible() && !!this.m_popup?.document.hasFocus();
        }
        OnFocusInternal() {
          this.m_popup &&
            this.m_popup.document.body.classList.add("WindowFocus"),
            (this.m_bFocused = !0),
            this.OnFocus();
        }
        OnBlurInternal() {
          this.m_popup &&
            this.m_popup.document.body.classList.remove("WindowFocus"),
            (this.m_bFocused = !1),
            this.OnBlur();
        }
        get focused() {
          return this.m_bFocused;
        }
        GetWindowRestoreDetails() {
          return _(this.m_popup, "Window.GetWindowRestoreDetails") &&
            !this.m_popup.closed
            ? this.m_popup.SteamClient.Window.GetWindowRestoreDetails()
            : Promise.resolve("");
        }
        IsMinimized() {
          return _(this.m_popup, "Window.IsWindowMinimized") &&
            !this.m_popup.closed
            ? this.m_popup.SteamClient.Window.IsWindowMinimized()
            : Promise.resolve(!1);
        }
        IsMaximized() {
          return _(this.m_popup, "Window.IsWindowMaximized") &&
            !this.m_popup.closed
            ? this.m_popup.SteamClient.Window.IsWindowMaximized()
            : Promise.resolve(!1);
        }
        ReleasePopup() {
          this.OnClose(), (this.m_popup = null);
        }
        OnMove() {}
        OnResize() {
          this.IsMaximized().then((_) => {
            _
              ? this.m_popup?.document.body.classList.add("Maximized")
              : this.m_popup?.document.body.classList.remove("Maximized");
          });
        }
        OnBeforeUnload() {}
        OnFocus() {}
        OnBlur() {}
      }
      (0, _._)([_._], _.prototype, "m_bFocused", void 0),
        (0, _._)([_._], _.prototype, "OnMessage", null),
        (0, _._)([_._], _.prototype, "RenderInternal", null),
        (0, _._)([_._], _.prototype, "OnCreateInternal", null),
        (0, _._)([_._], _.prototype, "OnResizeEvent", null),
        (0, _._)([_._], _.prototype, "OnBeforeUnloadEvent", null),
        (0, _._)([_._], _.prototype, "OnUnload", null),
        (0, _._)([_._], _.prototype, "OnFocusInternal", null),
        (0, _._)([_._], _.prototype, "OnBlurInternal", null);
      (0, _._)(
        [_._],
        class extends _ {
          m_strSavedDimensionsKey;
          m_strInitialSavedDimensionsKey;
          m_strInitialRestoreDetails;
          m_bExpires;
          constructor(_, _, _, _) {
            super(_, _), this.SetSavedDimensionsKey(_), (this.m_bExpires = _);
          }
          BIsInOverlay() {
            return (
              this.browser_info &&
              0 != this.browser_info.m_unPID &&
              -1 != this.browser_info.m_nBrowserID
            );
          }
          SetSavedDimensionsKey(_) {
            this.m_strSavedDimensionsKey = _;
          }
          UpdateParamsBeforeShow(_) {
            return (
              !this.m_strSavedDimensionsKey ||
              _.bIgnoreSavedDimensions ||
              _.strRestoreDetails
                ? _.strRestoreDetails &&
                  ((this.m_strInitialSavedDimensionsKey =
                    this.GetSavedDimensionsKey()),
                  _.SetRestoreDetails(
                    this.m_strInitialSavedDimensionsKey,
                    _.strRestoreDetails,
                    this.m_bExpires,
                  ))
                : ((this.m_strInitialSavedDimensionsKey =
                    this.GetSavedDimensionsKey()),
                  (_.strRestoreDetails = _.GetRestoreDetails(
                    this.m_strInitialSavedDimensionsKey,
                  ))),
              _
            );
          }
          OnLoad() {
            this.GetWindowRestoreDetails().then((_) => {
              (this.m_strInitialRestoreDetails = _), this.OnResizeComplete(_);
            });
          }
          OnMove() {
            super.OnMove(), this.QueryAndStoreWindowPosition();
          }
          OnResize() {
            super.OnResize(), this.QueryAndStoreWindowPosition();
          }
          OnResizeComplete(_) {}
          QueryAndStoreWindowPosition() {
            if (this.m_strInitialRestoreDetails) {
              let _ = this.GetSavedDimensionsKey();
              this.m_popup?.setTimeout(() => {
                this.GetWindowRestoreDetails().then((_) => {
                  let _ =
                    this.m_rgParams.strRestoreDetails == _ &&
                    _ == this.m_strInitialSavedDimensionsKey;
                  this.m_popup &&
                    this.m_strSavedDimensionsKey &&
                    _ &&
                    !_ &&
                    (_.SetRestoreDetails(_, _, this.m_bExpires),
                    (this.m_rgParams.strRestoreDetails = _),
                    (this.m_strInitialSavedDimensionsKey = _),
                    this.OnResizeComplete(_));
                });
              }, 30);
            }
          }
          OnBeforeUnload() {
            this.QueryAndStoreWindowPosition(), super.OnBeforeUnload();
          }
          OnClose() {}
          SaveWindowPosition(_) {
            _.SetRestoreDetails(this.GetSavedDimensionsKey(), _, !1),
              (this.m_rgParams.strRestoreDetails = _);
          }
        }.prototype,
        "QueryAndStoreWindowPosition",
        null,
      );
      class _ {
        m_bShuttingDown = !1;
        m_mapPopups = _._.map([], {
          deep: !1,
        });
        m_rgShutdownCallbacks = [];
        m_rgPopupCreatedCallbacks = new _._();
        m_rgPopupDestroyedCallbacks = new _._();
        m_unCurrentAccountID = 0;
        m_mapRestoreDetails = new Map();
        m_bSaveRequired = !1;
        m_DynamicCSSObserver;
        constructor() {
          if (
            !{
              NODE_ENV: "production",
              STEAM_BUILD: "buildbot",
            }.MOBILE_BUILD &&
            "addEventListener" in window
          ) {
            window.addEventListener("beforeunload", (_) => {
              this.m_bShuttingDown = !0;
              for (let _ of this.m_rgShutdownCallbacks) _();
              let _ = [];
              this.m_mapPopups.forEach((_) => {
                _.BIsValid() && !_.BIsClosed() && _.push(_);
              });
              for (let _ of _)
                _.window?.SteamClient.Browser
                  ?.SetShouldExitSteamOnBrowserClosed &&
                  _.window.SteamClient.Browser.SetShouldExitSteamOnBrowserClosed(
                    !1,
                  ),
                  _.window?.SteamClient.Window.SetHideOnClose &&
                    _.window?.SteamClient.Window.SetHideOnClose(!1),
                  _.Close();
              this.m_bSaveRequired && this.SaveSavedDimensionStore(),
                this.m_mapPopups.clear();
            });
            let _ = document.querySelector("head");
            (0, _._)(_, "Couldn't find head element"),
              _ &&
                ((this.m_DynamicCSSObserver = new MutationObserver(() => {
                  const _ = _();
                  this.m_mapPopups.forEach((_) => {
                    _(_.window.document, _, !1);
                  });
                })),
                this.m_DynamicCSSObserver.observe(_, {
                  childList: !0,
                }));
          }
        }
        BAnyPopupHasFocus() {
          for (const _ of this.m_mapPopups.values()) if (_.focused) return !0;
          return !1;
        }
        BAnyMenuHasFocus() {
          for (const _ of this.m_mapPopups.values())
            if (_.focused && (_.params.eCreationFlags ?? 0) & _.NoTaskbarIcon)
              return !0;
          return !1;
        }
        SetCurrentLoggedInAccountID(_) {
          this.m_unCurrentAccountID != _ &&
            ((this.m_unCurrentAccountID = _),
            _
              ? this.LoadSavedDimensionStore()
              : this.ClearSavedDimensionStore());
        }
        AddShutdownCallback(_) {
          this.m_rgShutdownCallbacks.push(_);
        }
        AddPopupCreatedCallback(_) {
          return this.m_rgPopupCreatedCallbacks.Register(_);
        }
        AddPopupDestroyedCallback(_) {
          return this.m_rgPopupDestroyedCallbacks.Register(_);
        }
        AddTrackedPopup(_) {
          this.m_mapPopups.set(_.GetName(), _),
            _.BIsValid() && this.m_rgPopupCreatedCallbacks.Dispatch(_);
        }
        RemoveTrackedPopup(_) {
          this.m_rgPopupDestroyedCallbacks.Dispatch(_),
            this.m_mapPopups.delete(_.GetName());
        }
        GetExistingPopup(_) {
          return this.m_mapPopups.get(_);
        }
        GetPopups() {
          return this.m_mapPopups.values();
        }
        GetPopupForWindow(_) {
          for (const _ of this.m_mapPopups.values())
            if (_.window === _) return _;
        }
        ClosePopupsOwnedByBrowser(_) {
          this.m_mapPopups.forEach((_) => {
            _.browser_info &&
              _.browser_info.m_nBrowserID == _.m_nBrowserID &&
              _.browser_info.m_unPID == _.m_unPID &&
              _.Close();
          });
        }
        static CreatePopup(_, _) {
          let _ = _.dimensions || {},
            _ = _.width || 300,
            _ = _.height || 300,
            _ = _.title,
            _ = "width=" + _ + ",height=" + _;
          void 0 !== _.left && (_ += ",left=" + _.left),
            void 0 !== _.top && (_ += ",top=" + _.top),
            (_ += ",resizeable,status=0,toolbar=0,menubar=0,location=0");
          let _ = "about:blank",
            _ = [];
          _.push("createflags=" + _.eCreationFlags),
            _.minWidth && _.push("minwidth=" + _.minWidth),
            _.minHeight && _.push("minheight=" + _.minHeight),
            _.maxWidth &&
              _.maxWidth != 1 / 0 &&
              _.push("maxwidth=" + _.maxWidth),
            _.maxHeight &&
              _.maxHeight != 1 / 0 &&
              _.push("maxheight=" + _.maxHeight),
            _.target_browser
              ? (_.push("pid=" + _.target_browser.m_unPID),
                _.push("browser=" + _.target_browser.m_nBrowserID),
                _.target_browser.m_eBrowserType
                  ? _.push("browserType=" + _.target_browser.m_eBrowserType)
                  : _.browserType && _.push("browserType=" + _.browserType),
                _.availscreenwidth &&
                  _.availscreenheight &&
                  (_.push("screenavailwidth=" + _.availscreenwidth),
                  _.push("screenavailheight=" + _.availscreenheight)))
              : _.browserType && _.push("browserType=" + _.browserType),
            _.strVROverlayKey && _.push("vrOverlayKey=" + _.strVROverlayKey),
            _.strRestoreDetails &&
              _.push("restoredetails=" + _.strRestoreDetails),
            _.window_opener_id && _.push("openerid=" + _.window_opener_id),
            _.parent_container_popup_id &&
              _.push("parentcontainerpopupid=" + _.parent_container_popup_id),
            _.center_on_window &&
              void 0 === _.left &&
              void 0 === _.top &&
              _.push(
                "centerOnBrowserID=" +
                  _.center_on_window.SteamClient.Browser.GetBrowserID(),
              ),
            _.strUserAgent && _.push("useragent=" + _.strUserAgent),
            _.hwndParent && _.push("hwndParent=" + _.hwndParent),
            _.bPinned && _.push("pinned=true"),
            _.bModal && _.push("modal=true"),
            _ && (_ += "?" + _.join("&"));
          let _ = (_.owner_window || window).open(_, _, _);
          if (!_)
            return (
              console.error(
                `Failed to create popup, browser/CEF may be blocking popups for "${window.location.origin}"`,
              ),
              {}
            );
          let _ = "";
          _.html_class && (_ = `class="${_.html_class}"`);
          let _ = "";
          _.body_class && (_ = `class="${_.body_class}"`);
          let _ = "";
          _.body_role && (_ = `role="${_.body_role}"`);
          let _ = "";
          _.popup_class && (_ = `class="${_.popup_class}"`);
          let _ = `<!DOCTYPE html><html ${_}><head><title></title></head><body ${_} ${_}><div id="popup_target" ${_}></div></body></html>`;
          var _, _;
          return (
            _.document.write(_),
            (_.document.title = _),
            _.document.close(),
            (_ = _),
            (_ = _()),
            _(_.document, _, !0),
            {
              popup: _,
              element: _.document.getElementById("popup_target"),
            }
          );
        }
        BShuttingDown() {
          return this.m_bShuttingDown;
        }
        GetLocalStorageKey() {
          return "PopupSavedDimensions_" + this.m_unCurrentAccountID;
        }
        LoadSavedDimensionStore() {
          if (!this.m_unCurrentAccountID) return;
          let _ = this.GetLocalStorageKey();
          this.m_mapRestoreDetails.clear();
          let _ = window.localStorage.getItem(_);
          if (_)
            try {
              let _ = JSON.parse(_);
              this.m_mapRestoreDetails = new Map(_);
            } catch (_) {}
        }
        SaveSavedDimensionStore() {
          if (!this.m_unCurrentAccountID || !this.m_bSaveRequired) return;
          let _ = this.GetLocalStorageKey(),
            _ = JSON.stringify(Array.from(this.m_mapRestoreDetails));
          try {
            window.localStorage.setItem(_, _), (this.m_bSaveRequired = !1);
          } catch (_) {
            if ("name" in _ && "QuotaExceededError" == _.name) {
              console.log("Quota exceeded");
              for (let _ of Object.keys(window.localStorage))
                _.startsWith("PopupSavedDimensions_") &&
                  _ != _ &&
                  window.localStorage.removeItem(_);
              window.localStorage.setItem(_, _), (this.m_bSaveRequired = !1);
            }
          }
        }
        DebouncedSaveSavedDimensionStore() {
          this.SaveSavedDimensionStore();
        }
        ClearSavedDimensionStore() {
          this.m_mapRestoreDetails?.clear(), (this.m_bSaveRequired = !1);
        }
        GetRestoreDetails(_) {
          if (!this.m_mapRestoreDetails?.has(_)) return "";
          let _ = this.m_mapRestoreDetails.get(_);
          return (
            (_.last_used = Date.now()),
            (this.m_bSaveRequired = !0),
            _.strRestoreDetails
          );
        }
        SetRestoreDetails(_, _, _) {
          if (_) {
            if (_) {
              if (this.m_mapRestoreDetails.size > 50) {
                let _ = null,
                  _ = Date.now();
                for (let _ of Array.from(this.m_mapRestoreDetails.keys())) {
                  let _ = this.m_mapRestoreDetails.get(_);
                  _.last_used < _ && _.bExpires && ((_ = _.last_used), (_ = _));
                }
                _ && this.m_mapRestoreDetails.delete(_);
              }
              let _ = {
                strRestoreDetails: _,
                last_used: Date.now(),
                bExpires: _,
              };
              this.m_mapRestoreDetails.set(_, _);
            } else this.m_mapRestoreDetails.delete(_);
            (this.m_bSaveRequired = !0),
              this.m_bShuttingDown
                ? this.SaveSavedDimensionStore()
                : this.DebouncedSaveSavedDimensionStore();
          }
        }
      }
      (0, _._)(
        [_._, _(100)],
        _.prototype,
        "DebouncedSaveSavedDimensionStore",
        null,
      );
      const _ = new _();
      window.g_PopupManager = _;
      const _ = _.createContext(null);
      function _(_) {
        const {
            refContextMenuManager: _,
            bRegisterMenuManager: __webpack_require__ = !0,
            children: _,
          } = _,
          _ = _(),
          _ = _?.ownerWindow || window,
          _ = _.useRef(void 0);
        return (
          _.current || (_.current = new _()),
          _.useLayoutEffect(() => {
            if (__webpack_require__)
              return (
                _.SetMenuManager(_, _.current),
                () => _.SetMenuManager(_, void 0)
              );
          }, [_, __webpack_require__]),
          _.useLayoutEffect(() => (_(_, _.current), () => _(_, void 0)), [_]),
          _.createElement(
            _.Provider,
            {
              value: _.current,
            },
            _,
          )
        );
      }
      const _ = _.createContext({
        body_class: "",
      });
      function _() {
        return _.useContext(_);
      }
      var _;
      !(function (_) {
        (_[(_.k_EAccountFlagNormalUser = 0)] = "k_EAccountFlagNormalUser"),
          (_[(_.k_EAccountFlagPersonaNameSet = 1)] =
            "k_EAccountFlagPersonaNameSet"),
          (_[(_.k_EAccountFlagUnbannable = 2)] = "k_EAccountFlagUnbannable"),
          (_[(_.k_EAccountFlagPasswordSet = 4)] = "k_EAccountFlagPasswordSet"),
          (_[(_.k_EAccountFlagSupport = 8)] = "k_EAccountFlagSupport"),
          (_[(_.k_EAccountFlagAdmin = 16)] = "k_EAccountFlagAdmin"),
          (_[(_.k_EAccountFlagSupervisor = 32)] = "k_EAccountFlagSupervisor"),
          (_[(_.k_EAccountFlagAppEditor = 64)] = "k_EAccountFlagAppEditor"),
          (_[(_.k_EAccountFlagHWIDSet = 128)] = "k_EAccountFlagHWIDSet"),
          (_[(_.k_EAccountFlagVacBeta = 512)] = "k_EAccountFlagVacBeta"),
          (_[(_.k_EAccountFlagDebug = 1024)] = "k_EAccountFlagDebug"),
          (_[(_.k_EAccountFlagDisabled = 2048)] = "k_EAccountFlagDisabled"),
          (_[(_.k_EAccountFlagLimitedUser = 4096)] =
            "k_EAccountFlagLimitedUser"),
          (_[(_.k_EAccountFlagLimitedUserForce = 8192)] =
            "k_EAccountFlagLimitedUserForce"),
          (_[(_.k_EAccountFlagEmailValidated = 16384)] =
            "k_EAccountFlagEmailValidated"),
          (_[(_.k_EAccountFlagValveEmail = 32768)] =
            "k_EAccountFlagValveEmail"),
          (_[(_.k_EAccountFlagForcePasswordChange = 131072)] =
            "k_EAccountFlagForcePasswordChange"),
          (_[(_.k_EAccountFlagLogonExtraSecurity = 524288)] =
            "k_EAccountFlagLogonExtraSecurity"),
          (_[(_.k_EAccountFlagLogonExtraSecurityDisabled = 1048576)] =
            "k_EAccountFlagLogonExtraSecurityDisabled"),
          (_[(_.k_EAccountFlagSteam2MigrationComplete = 2097152)] =
            "k_EAccountFlagSteam2MigrationComplete"),
          (_[(_.k_EAccountFlagNeedLogs = 4194304)] = "k_EAccountFlagNeedLogs"),
          (_[(_.k_EAccountFlagLockdown = 8388608)] = "k_EAccountFlagLockdown"),
          (_[(_.k_EAccountFlagMasterAppEditor = 16777216)] =
            "k_EAccountFlagMasterAppEditor"),
          (_[(_.k_EAccountFlagBannedFromWebAPI = 33554432)] =
            "k_EAccountFlagBannedFromWebAPI"),
          (_[(_.k_EAccountFlagPartnerMember = 67108864)] =
            "k_EAccountFlagPartnerMember"),
          (_[(_.k_EAccountFlagGlobalModerator = 134217728)] =
            "k_EAccountFlagGlobalModerator"),
          (_[(_.k_EAccountFlagParentalSettings = 268435456)] =
            "k_EAccountFlagParentalSettings"),
          (_[(_.k_EAccountFlagThirdPartySupport = 536870912)] =
            "k_EAccountFlagThirdPartySupport"),
          (_[(_.k_EAccountFlagNeedsSSANextSteamLogon = 1073741824)] =
            "k_EAccountFlagNeedsSSANextSteamLogon");
      })(_ || (_ = {}));
      _.k_EAccountFlagAdmin,
        _.k_EAccountFlagSupervisor,
        _.k_EAccountFlagSupport,
        _.k_EAccountFlagAdmin,
        _.k_EAccountFlagSupervisor;
      __webpack_require__("chunkid");
      function _(_, _, _) {
        const _ = _.useRef(void 0),
          [_, _] = _.useState(void 0),
          _ = _();
        return (
          _.current ||
            (_.current = new _(
              _,
              (function (_, _) {
                return {
                  ..._,
                  body_class: (0, _._)(_.body_class, _.body_class),
                };
              })(_, _),
              _,
            )),
          (_.current.m_callbacks = _),
          _.useEffect(() => {
            if (!_.current?.params.bNoInitialShow) {
              let _ = _.current?.params.bNoFocusOnShow
                ? _._.k_EWindowBringToFrontWithoutForcingOS
                : _._.k_EWindowBringToFrontAndForceOS;
              _.current?.Show(_);
            }
            return () => {
              (_.current.m_callbacks = void 0),
                _.current.window?.SteamClient.Window.SetHideOnClose &&
                  _.current.window?.SteamClient.Window.SetHideOnClose(!1),
                _.current.Close();
            };
          }, []),
          _.useEffect(() => {
            _.current.window?.SteamClient.Window.SetHideOnClose &&
              _.current.window?.SteamClient.Window.SetHideOnClose(
                !!_.bHideOnClose,
              );
          }, [_.bHideOnClose]),
          {
            popup: _.current.window,
            element: _,
            popupObj: _.current,
          }
        );
      }
      class _ extends _ {
        m_callbacks;
        m_fnReadyToRender;
        constructor(_, _, _) {
          super(_, _), (this.m_fnReadyToRender = _);
        }
        DoCallback(_) {
          this.m_callbacks?.[_]?.(this.m_popup, this.m_element);
        }
        UpdateParamsBeforeShow(_) {
          return this.m_callbacks?.updateParamsBeforeShow
            ? this.m_callbacks.updateParamsBeforeShow(_)
            : _;
        }
        OnCreate() {
          this.m_callbacks?.onCreate &&
            this.m_callbacks.onCreate(this.m_popup, this.m_element);
        }
        OnBlur() {
          this.DoCallback("onBlur");
        }
        OnFocus() {
          this.DoCallback("onFocus");
        }
        OnLoad() {
          this.DoCallback("onLoad");
        }
        OnMove() {
          this.DoCallback("onMove");
        }
        OnResize() {
          this.DoCallback("onResize");
        }
        OnClose() {
          this.DoCallback("onClose");
        }
        Render(_, _) {
          this.m_fnReadyToRender(_);
        }
      }
      class _ extends _.Component {
        state = {};
        constructor(_) {
          super(_), (this.state.lastErrorKey = _.errorKey);
        }
        static sm_ErrorReportingStore;
        static InstallErrorReportingStore(_) {
          this.sm_ErrorReportingStore = _;
        }
        componentDidCatch(_, _) {
          const _ = _.sm_ErrorReportingStore;
          _
            ? __webpack_require__
                .ReportError(_, {
                  strComponentStack: _.componentStack || void 0,
                })
                .then(
                  (_) =>
                    _ &&
                    this.setState({
                      identifierHash: _.identifierHash,
                    }),
                )
            : console.warn(
                "No ErrorReportingStore - use ErrorReportingStore().Init() to configure error reporting to server",
              ),
            this.setState({
              error: {
                error: _,
                info: _,
              },
              lastErrorKey: this.props.errorKey,
            });
        }
        Reset() {
          this.setState({
            error: void 0,
          });
        }
        render() {
          const {
              children: _,
              fallback: _,
              errorKey: __webpack_require__,
            } = this.props,
            { error: _, identifierHash: _, lastErrorKey: _ } = this.state;
          return _ && __webpack_require__ == _
            ? void 0 !== _
              ? "function" == typeof _
                ? _(_.error)
                : _
              : _.sm_ErrorReportingStore &&
                  _.sm_ErrorReportingStore.reporting_enabled
                ? _.createElement(_, {
                    error: _,
                    identifierHash: _,
                    store: _.sm_ErrorReportingStore,
                    onRefresh: this.Reset,
                  })
                : _.createElement(_, {
                    error: _,
                    onDismiss: this.Reset,
                  })
            : _ || null;
        }
      }
      (0, _._)([_._], _.prototype, "Reset", null);
      const _ = ({ error: _, onDismiss: _ }) => {
          let _ = _.error ? _.error.stack : "Stack missing",
            _ = _.info ? _.info.componentStack : "",
            _ = (_.error && _.error.message) || "unknown error";
          return _.createElement(
            _,
            null,
            _.createElement(_, null, 'Error: "', _, '"'),
            "",
            _.createElement(
              "span",
              {
                style: {
                  textDecoration: "underline",
                  cursor: "pointer",
                },
                onClick: _,
              },
              "(x) Dismiss",
            ),
            _.createElement("br", null),
            _.createElement(_, null, _),
            _.createElement(_, null, "The error occurred while rendering:", _),
          );
        },
        _ = (_) => {
          const {
              error: _,
              onRefresh: __webpack_require__,
              identifierHash: _,
              store: _,
            } = _,
            _ = (_.error && _.error.message) || "unknown error",
            _ = `${_.product}_${_.version}_${_}`;
          return _.createElement(
            _,
            null,
            _.createElement(
              _,
              null,
              "Something went wrong while displaying this content. ",
              _.createElement(
                "span",
                {
                  style: {
                    textDecoration: "underline",
                    cursor: "pointer",
                  },
                  onClick: __webpack_require__,
                },
                "Refresh",
              ),
            ),
            _.createElement(_, null, "Error Reference: ", _),
            _.createElement(_, null, _),
          );
        },
        _ = ({ children: _ }) =>
          _.createElement(
            "div",
            {
              style: {
                overflow: "auto",
                marginLeft: "15px",
                color: "white",
                fontSize: "16px",
                userSelect: "auto",
                backgroundColor: "black",
              },
              className: "ErrorBoundary",
            },
            _,
          ),
        _ = ({ children: _ }) =>
          _.createElement(
            "h1",
            {
              style: {
                fontSize: "20px",
                display: "inline-block",
                marginTop: "15px",
                userSelect: "auto",
              },
            },
            _,
          ),
        _ = ({ children: _ }) =>
          _.createElement(
            "pre",
            {
              style: {
                marginTop: "15px",
                opacity: 0.7,
                userSelect: "auto",
              },
            },
            _,
          );
      function _(_) {
        const {
            managerOverride: _,
            bSuppressMouseOverlay: __webpack_require__,
          } = _,
          _ = _(),
          _ = (function () {
            const { ownerWindow: _ } = _(),
              _ = _.GetPopupForWindow(_);
            return _?.browser_info || _;
          })(),
          _ = _.useContext(_),
          _ = _ ?? _;
        _(_.OnMenusChanged, _);
        const _ = !__webpack_require__ && _.BShouldRenderMouseOverlay(),
          _ = _.GetAllMenus();
        return _.createElement(
          _.Fragment,
          null,
          _ && _.createElement(_, null),
          _.map((_) =>
            _.createElement(
              _,
              {
                key: _.key,
              },
              _.createElement(_, {
                instance: _,
                browserInfo: _,
              }),
            ),
          ),
        );
      }
      function _(_) {
        const {
            instance: _,
            browserInfo: __webpack_require__,
            children: _,
          } = _,
          _ = _(),
          _ = _().ownerWindow,
          _ = _.useRef(void 0);
        void 0 === _.current &&
          (_.current =
            (_.options.bForcePopup || _.innerWidth < 400 || _?.BOnlyPopups()) &&
            !!_.SteamClient?.Window);
        const _ = _.useMemo(
            () => ({
              instance: _,
              styles: _(),
              presentation: 0,
            }),
            [_],
          ),
          _ = _ || _.ReactElement;
        return _.createElement(
          _.Provider,
          {
            value: _,
          },
          _.current
            ? _.createElement(_, {
                instance: _,
                browserInfo: __webpack_require__,
                children: _,
              })
            : _.createElement(_, {
                instance: _,
                children: _,
              }),
        );
      }
      function _(_) {
        const { instance: _, children: __webpack_require__ } = _;
        return _.createElement(
          _,
          {
            ..._.position,
          },
          __webpack_require__,
        );
      }
      function _(_) {
        const {
            instance: _,
            browserInfo: __webpack_require__,
            children: _,
          } = _,
          _ = _.useRef(null),
          _ = _().ownerWindow,
          _ = _.SteamClient.Browser.GetBrowserID(),
          _ = _.useCallback(
            (_) => {
              const { options: __webpack_require__, position: _ } = _,
                _ = _.element;
              if (__webpack_require__.bScreenCoordinates)
                _.dimensions = {
                  left: _.clientX,
                  top: _.clientY,
                  width: 2,
                  height: 1,
                };
              else {
                let _ = _(_, _.getBoundingClientRect());
                (_.dimensions = {
                  left: _.right,
                  top: _.top,
                  width: 2,
                  height: 1,
                }),
                  (_.availscreenwidth = _.screen.availWidth),
                  (_.availscreenheight = _.screen.availHeight);
              }
              return _;
            },
            [_, _],
          );
        let _ = _.options.bStandalone
          ? _(_.StandaloneContextMenu)
          : _(_.PopupContextMenu);
        _.options.bCreateHidden && (_ |= _.Hidden),
          _.options.bAlwaysOnTop && (_ |= _.AlwaysOnTop);
        const { popupObj: _, element: _ } = _(
          "contextmenu_" + _.key,
          {
            title: _.options.title || "Menu",
            html_class: (0, _._)(
              _().ContextMenuPopup,
              "client_chat_frame",
              _.options.bStandalone && _().Standalone,
            ),
            popup_class: _().PopupTarget,
            body_class: (0, _._)(
              _().ContextMenuPopupBody,
              "ContextMenuPopupBody",
            ),
            replace_existing_popup: !1,
            target_browser: __webpack_require__,
            window_opener_id: _,
            bHideOnClose: !0,
            eCreationFlags: _,
          },
          {
            updateParamsBeforeShow: _,
          },
        );
        return (
          (0, _.useEffect)(() => {
            if (_)
              if (_.visible) {
                _.current && _.current.PositionMenu(),
                  _.current && _.current.PositionPopupWindow();
                let _ = _.options.bNoFocusWhenShown
                  ? _._.k_EWindowBringToFrontWithoutForcingOS
                  : _._.k_EWindowBringToFrontAndForceOS;
                _.TakeFocus(_);
              } else
                _.options.bRetainOnHide &&
                  window.setTimeout(() => {
                    _.window?.SteamClient.Window.HideWindow();
                  }, 30);
          }, [_, _, _.visible]),
          (function (_) {
            const _ = _();
            _.useEffect(() => {
              if (_) return _.RegisterModalManager(_, _);
            }, [_, _]);
          })(_.window),
          _.useEffect(() => {
            _.SetPopup(_);
          }, [_, _]),
          _
            ? _.createPortal(
                _.createElement(
                  _,
                  {
                    ref: _,
                    ..._.position,
                    parentWin: _,
                    popup: _,
                  },
                  _,
                ),
                _,
              )
            : null
        );
      }
      function _(_) {
        const [_, __webpack_require__] = (0, _.useState)(!0);
        return (
          (0, _.useEffect)(() => {
            (0, _.startTransition)(() => {
              __webpack_require__(!0);
            });
          }, []),
          _ ? _.children : (_.fallback ?? null)
        );
      }
      function _(_) {
        const [_, __webpack_require__] = _.useState(!1),
          _ = _.useCallback(() => {
            _(_, "Window.IsWindowMaximized")
              ? _.SteamClient.Window.IsWindowMaximized().then((_) => {
                  __webpack_require__(_);
                })
              : _?.screen &&
                __webpack_require__(
                  _.screen.availWidth == _.innerWidth &&
                    _.screen.availHeight == _.innerHeight,
                );
          }, [_]);
        return (
          _.useEffect(_, [_, _]),
          _(_, "resize", _),
          (function (_, _, _, _) {
            _(
              _,
              "message",
              function (_) {
                _.includes(_.data) && __webpack_require__(this, _);
              },
              _,
            );
          })(_, ["window_resized"], _),
          _
        );
      }
      function _(_) {
        const { popup: _, onMaximize: __webpack_require__, bOSX: _ } = _,
          _ = _(_),
          _ = _.useCallback(() => {
            __webpack_require__
              ? __webpack_require__()
              : _(_, "Window.ToggleMaximize") &&
                _.SteamClient.Window.ToggleMaximize();
          }, [_, __webpack_require__]);
        return _.createElement(
          _,
          {
            className: (0, _._)(
              _ ? "restoreButton" : "maximizeButton",
              "windowControlButton",
            ),
            onClick: _,
          },
          !_ && (_ ? _.createElement(_, null) : _.createElement(_, null)),
        );
      }
      function _(_) {
        const { popup: _, onMinimize: __webpack_require__, bOSX: _ } = _,
          _ = _.useCallback(() => {
            _.SteamClient.Window.Minimize();
          }, [_]);
        return _.createElement(
          _,
          {
            className: "minimizeButton windowControlButton",
            onClick: __webpack_require__ ?? _,
          },
          !_ && _.createElement(_, null),
        );
      }
      function _(_) {
        const { popup: _, onClose: __webpack_require__, bOSX: _ } = _,
          _ = _.useCallback(() => {
            _ &&
              (_(_, "Window.Close") ? _.SteamClient.Window.Close() : _.close());
          }, [_]);
        return _.createElement(
          _,
          {
            className: "closeButton windowControlButton",
            onClick: __webpack_require__ ?? _,
          },
          !_ && _.createElement(_, null),
        );
      }
      function _(_) {
        const { className: _, onClick: __webpack_require__, children: _ } = _,
          _ = _.useCallback(
            (_) => {
              __webpack_require__ &&
                (_.stopPropagation(), __webpack_require__(_));
            },
            [__webpack_require__],
          );
        return _.createElement(
          "div",
          {
            className: (0, _._)("title-area-icon", _),
            onClick: _,
          },
          _.createElement(
            "div",
            {
              className: "title-area-icon-inner",
            },
            _,
          ),
        );
      }
      function _(_) {
        const {
            className: _,
            style: __webpack_require__,
            hideActions: _,
            hideClose: _,
            hideMin: _,
            hideMax: _,
            bOSX: _ = (0, _._)(),
            bForceWindowFocused: _,
            onMinimize: _,
            onMaximize: _,
            onClose: _,
            extraActions: _,
            popup: _,
            children: _,
          } = _,
          _ = (function (_, _ = 100) {
            const [__webpack_require__, _] = _.useState(!1),
              _ = _.useCallback(() => _(!0), [_]),
              _ = _.useCallback(() => _(!1), [_]);
            return (
              _.useEffect(
                () =>
                  _
                    ? (_.addEventListener("focus", _),
                      _.addEventListener("blur", _),
                      () => {
                        _.removeEventListener("focus", _),
                          _.removeEventListener("blur", _);
                      })
                    : void 0,
                [_, _, _],
              ),
              _(__webpack_require__, _)
            );
          })(_);
        return _.createElement(
          "div",
          {
            className: (0, _._)(
              "TitleBar",
              "title-area",
              _ && "OSX",
              (_ || _) && "WindowFocus",
              _,
            ),
            style: __webpack_require__,
          },
          _.createElement("div", {
            className: "title-area-highlight",
          }),
          _.createElement(
            "div",
            {
              className: "title-area-children",
            },
            _,
          ),
          !_ &&
            _.createElement(
              _.Fragment,
              null,
              _ &&
                _.createElement(
                  "div",
                  {
                    className: "title-bar-actions extra-actions",
                  },
                  _,
                ),
              _.createElement(
                "div",
                {
                  className: "title-bar-actions window-controls",
                },
                !_ &&
                  _.createElement(_, {
                    popup: _,
                    onClose: _,
                    bOSX: _,
                  }),
                !_ &&
                  _.createElement(_, {
                    popup: _,
                    onMaximize: _,
                    bOSX: _,
                  }),
                !_ &&
                  _.createElement(_, {
                    popup: _,
                    onMinimize: _,
                    bOSX: _,
                  }),
              ),
            ),
        );
      }
      function _(_) {
        const { Modal: _ } = _,
          { name: __webpack_require__, modalProps: _, options: _ } = _,
          _ = _().ownerWindow,
          { popup: _, element: _ } = _(
            __webpack_require__,
            {
              title: _.strTitle,
              html_class:
                "client_chat_frame fullheight ModalDialogPopup LegacyPopup " +
                (_.className || ""),
              body_class: "fullheight ModalDialogBody",
              popup_class: "fullheight popup_chat_frame",
              owner_window: void 0,
              replace_existing_popup: !0,
              target_browser: _.browserContext,
              availscreenwidth: _.screen.availWidth,
              availscreenheight: _.screen.availHeight,
              bModal: _.bHideMainWindowForPopouts,
            },
            {
              updateParamsBeforeShow: (_) =>
                (function (_, _, _, _) {
                  let _,
                    _,
                    _,
                    _ = _.popupWidth || 500,
                    _ = _.popupHeight || 400;
                  if (_._.IN_CLIENT && _?.SteamClient?.Browser?.GetBrowserID)
                    _ = _.SteamClient.Browser.GetBrowserID();
                  else {
                    let _ = _.screen;
                    (_ = (_.availWidth - _) / 2), (_ = (_.availHeight - _) / 2);
                    let _ = _;
                    void 0 !== _.availLeft &&
                      void 0 !== _.availTop &&
                      ((_ += _.availLeft), (_ += _.availTop));
                  }
                  return {
                    ..._,
                    dimensions: {
                      width: _,
                      height: _,
                      left: _,
                      top: _,
                    },
                    center_on_window: _.bCenterOnWindow ? _ : void 0,
                    window_opener_id: _,
                  };
                })(_, _, _, _),
              onClose: () => _.fnOnClose && _.fnOnClose(),
            },
          ),
          _ = _.useCallback(() => {
            _.bHideMainWindowForPopouts && _?.SteamClient.Window.BringToFront();
          }, [_.bHideMainWindowForPopouts, _]);
        _(_, "click", _);
        const _ = _?.bHideActions,
          _ =
            "number" == typeof _?.nDragAreaHeight
              ? {
                  height: _.nDragAreaHeight,
                }
              : void 0;
        return _
          ? _.createPortal(
              _.createElement(
                _,
                {
                  ownerWindow: _,
                },
                _.createElement(
                  "div",
                  {
                    className: "PopupFullWindow",
                    onContextMenu: _,
                  },
                  _.createElement(_, {
                    hideMin: !0,
                    hideMax: !0,
                    popup: _,
                    hideActions: _,
                    style: _,
                  }),
                  _.createElement(
                    _,
                    {
                      browserInfo: _.browserContext,
                      bCenterPopupsOnWindow: _.bCenterOnWindow,
                    },
                    _.element,
                  ),
                ),
              ),
              _,
            )
          : null;
      }
      function _(_) {
        const { ModalManager: _ } = _,
          [__webpack_require__, _] = _.useState(void 0),
          [_, _] = _.useState(!0),
          _ = _.useRef(0),
          _ = _.useCallback(() => {
            _.startTransition(() => {
              _(!0);
            });
          }, []);
        _.useEffect(() => _.RegisterMeasureModalCallback(_).Unregister, [_, _]),
          _.useLayoutEffect(() => {
            __webpack_require__ ||
              _.startTransition(() => {
                _(_.TakeMeasureModalRequest()), _(!1);
              });
          }, [_, __webpack_require__, _]);
        const _ = _.useCallback((_) => {
          _.current++,
            _.startTransition(() => {
              _((_) => (_ === _ ? void 0 : _));
            });
        }, []);
        return __webpack_require__
          ? _.createElement(_, {
              key: _.current,
              onMeasureComplete: _,
              request: __webpack_require__,
            })
          : null;
      }
      function _(_) {
        const [_, __webpack_require__] = _.useState(),
          _ = _().ownerWindow;
        return (
          _.useLayoutEffect(() => {
            const _ = _.document.body,
              _ = _.document.createElement("div");
            return (
              (_.style.position = "absolute"),
              (_.style.visibility = "hidden"),
              _.appendChild(_),
              __webpack_require__(_),
              () => {
                _.removeChild(_);
              }
            );
          }, [_]),
          _
            ? _.createPortal(
                _.createElement(_, {
                  ..._,
                  elContainer: _,
                }),
                _,
              )
            : null
        );
      }
      function _(_) {
        const {
          elContainer: _,
          onMeasureComplete: __webpack_require__,
          request: _,
        } = _;
        return (
          _.useEffect(() => {
            let _ = !1;
            const _ = (_) => {
              _ || (_.fnResults(_), __webpack_require__(_), (_ = !0));
            };
            return (
              (async function (_, _) {
                _ && (await _);
                let _ = document;
                _._.IN_STEAMUI && _.fonts && (await _.fonts.ready);
                const _ = _.getBoundingClientRect(),
                  _ = Math.ceil(_.height),
                  _ = Math.ceil(_.width);
                return {
                  height: _,
                  width: _,
                };
              })(_, _.promiseContentReady).then(_),
              () => _(void 0)
            );
          }, [_, __webpack_require__, _]),
          _.createElement(_, null, _.rctToMeasure)
        );
      }
      class _ {
        key;
        static sm_lastKey = 0;
        ModalClosedCallback = new _._();
        constructor() {
          this.key = "Modal_" + _.sm_lastKey++;
        }
      }
      class _ extends _ {
        element;
        ModalUpdatedCallback = new _._();
        constructor(_) {
          super(), (this.element = _);
        }
        UpdateModal(_) {
          (this.element = _), this.ModalUpdatedCallback.Dispatch();
        }
      }
      class _ extends _ {
        m_OnElementReadyCallbacks = new _._();
        m_OnActiveModalCallbacks = new _._();
        constructor() {
          super();
        }
        get OnElementReadyCallbacks() {
          return this.m_OnElementReadyCallbacks;
        }
        get OnModalActiveCallbacks() {
          return this.m_OnActiveModalCallbacks;
        }
        RefModalElement(_) {
          _ && this.m_OnElementReadyCallbacks.Dispatch(_);
        }
        SetActive(_) {
          this.m_OnActiveModalCallbacks.Dispatch(_);
        }
      }
      (0, _._)([_._], _.prototype, "RefModalElement", null);
      class _ extends _ {
        m_strName;
        m_modalProps;
        m_options;
        constructor(_, _, _, _) {
          super(_),
            (this.m_strName = _),
            (this.m_modalProps = _),
            (this.m_options = _);
        }
        get name() {
          return this.m_strName;
        }
        get modalProps() {
          return this.m_modalProps;
        }
        get options() {
          return this.m_options;
        }
      }
      class _ {
        m_bUsePopups = !0;
        m_bOnlyPopups = !1;
        m_bCenterPopupsOnWindow = !1;
        m_rgModals = [];
        m_OnModalCountChangedCallbacks = new _._();
        m_OnModalShownCallbacks = new _._();
        m_OnModalHiddenCallbacks = new _._();
        m_cMountedOverlays = 0;
        m_rgMeasureModalRequests = [];
        m_OnMeasureModal = new _._();
        m_rgLegacyPopupModals = [];
        m_OnLegacyPopupModalCountChanged = new _._();
        m_browserInfo;
        get ModalCountChangedCallbacks() {
          return this.m_OnModalCountChangedCallbacks;
        }
        get LegacyPopupModalCountChangedCallbacks() {
          return this.m_OnLegacyPopupModalCountChanged;
        }
        RegisterOnModalShownCallback(_) {
          return this.m_OnModalShownCallbacks.Register(_);
        }
        RegisterOnModalHiddenCallback(_) {
          return this.m_OnModalHiddenCallbacks.Register(_);
        }
        RegisterMeasureModalCallback(_) {
          return this.m_OnMeasureModal.Register(_);
        }
        TakeMeasureModalRequest() {
          return this.m_rgMeasureModalRequests.length
            ? this.m_rgMeasureModalRequests.shift()
            : void 0;
        }
        RegisterOverlay(_) {
          (0, _._)(
            0 == this.m_cMountedOverlays,
            "Duplicate modal DialogOverlay; modals will appear in both",
          ),
            this.m_cMountedOverlays++;
          const _ = this.m_OnModalCountChangedCallbacks.Register(_);
          return () => {
            this.m_cMountedOverlays--, _.Unregister();
          };
        }
        OnModalCountChanged(_) {
          "show" == _ &&
            0 == this.m_cMountedOverlays &&
            window.setTimeout(() => {
              (0, _._)(
                this.m_cMountedOverlays > 0,
                "Modal was shown but ModalManager has no associated DialogOverlay",
              );
            }, 50),
            this.m_OnModalCountChangedCallbacks.Dispatch(
              this.m_rgModals.length,
            ),
            "show" == _
              ? this.m_OnModalShownCallbacks.Dispatch(this.m_rgModals.length)
              : "hide" == _ &&
                this.m_OnModalHiddenCallbacks.Dispatch(this.m_rgModals.length);
        }
        get modals() {
          return this.m_rgModals;
        }
        get active_modal() {
          return this.m_rgModals.length
            ? this.m_rgModals[this.m_rgModals.length - 1]
            : void 0;
        }
        ShowModal(_) {
          return this.ShowModalInternal(_);
        }
        RemoveModal(_) {
          let _ = this.m_rgModals.indexOf(_);
          -1 != _ && this.m_rgModals.splice(_, 1),
            _.ModalClosedCallback.Dispatch(),
            this.OnModalCountChanged("hide");
        }
        ShowModalInternal(_) {
          (0, _._)(
            !this.m_bOnlyPopups,
            "Attempting to show modal in popup-only modal manager; will not display.",
          );
          const _ = new _(_);
          this.m_rgModals.push(_);
          const _ = {
            Close: () => {
              this.RemoveModal(_);
            },
            Update: (_) => {
              _.UpdateModal(_);
            },
            ClosedPromise: new Promise((_) => {
              const _ = _.ModalClosedCallback.Register(() => {
                _(), __webpack_require__.Unregister();
              });
            }),
          };
          return this.OnModalCountChanged("show"), _;
        }
        ShowPortalModal() {
          (0, _._)(
            !this.m_bOnlyPopups,
            "Attempting to show modal in popup-only modal manager; will not display.",
          );
          const _ = new _();
          return (
            this.m_rgModals.push(_),
            this.OnModalCountChanged("show"),
            {
              key: _.key,
              Close: () => {
                this.RemoveModal(_);
              },
              OnElementReadyCallbacks: _.OnElementReadyCallbacks,
              OnModalActiveCallbacks: _.OnModalActiveCallbacks,
            }
          );
        }
        SetUsePopups(_) {
          this.m_bUsePopups = _;
        }
        BUsePopups() {
          return this.m_bUsePopups || this.m_bOnlyPopups;
        }
        SetOnlyPopups(_) {
          this.m_bOnlyPopups = _;
        }
        BOnlyPopups() {
          return this.m_bOnlyPopups;
        }
        SetBrowserInfo(_) {
          this.m_browserInfo = _;
        }
        GetBrowserInfo() {
          return this.m_browserInfo;
        }
        SetCenterPopupsOnWindow(_) {
          this.m_bCenterPopupsOnWindow = _;
        }
        BCenterPopupsOnWindow() {
          return this.m_bCenterPopupsOnWindow;
        }
        RequestModalMeasure(_, _, _) {
          this.m_rgMeasureModalRequests.push({
            rctToMeasure: _,
            fnResults: _,
            promiseContentReady: _,
          }),
            this.m_OnMeasureModal.Dispatch();
        }
        get legacy_popup_modals() {
          return this.m_rgLegacyPopupModals;
        }
        ShowLegacyPopupModal(_, _, _, _) {
          const _ = () => {
              let _ = this.m_rgLegacyPopupModals.indexOf(_);
              -1 != _ && this.m_rgLegacyPopupModals.splice(_, 1),
                this.m_OnLegacyPopupModalCountChanged.Dispatch(
                  this.m_rgLegacyPopupModals.length,
                ),
                _.ModalClosedCallback.Dispatch(),
                _.fnOnClose && __webpack_require__.fnOnClose();
            },
            _ = new _(
              _,
              _,
              {
                ..._,
                fnOnClose: _,
              },
              {
                bCenterOnWindow: this.m_bCenterPopupsOnWindow,
                ..._,
              },
            );
          return (
            this.m_rgLegacyPopupModals.push(_),
            this.m_OnLegacyPopupModalCountChanged.Dispatch(
              this.m_rgLegacyPopupModals.length,
            ),
            {
              Close: _,
              Update: (_) => {
                _.UpdateModal(_);
              },
              ClosedPromise: new Promise((_) => {
                const _ = _.ModalClosedCallback.Register(() => {
                  _(), _.Unregister();
                });
              }),
            }
          );
        }
      }
      const _ = new (class {
        m_mapModalManager = new WeakMap();
        GetModalManager(_) {
          let _ = this.m_mapModalManager.get(_);
          return (
            _ ||
              (console.assert(
                !1,
                `Early access to modal manager, creating one for ${_.document.title}`,
              ),
              (_ = new _()),
              this.m_mapModalManager.set(_, _)),
            _
          );
        }
        RegisterModalManager(_, _) {
          (0, _._)(
            !this.m_mapModalManager.has(_) || _ == window,
            `Stomping CModalManager for ${_.document.title}!`,
          );
          const _ = this.m_mapModalManager.get(_);
          return (
            this.m_mapModalManager.set(_, _),
            () => {
              _
                ? this.m_mapModalManager.set(_, _)
                : this.m_mapModalManager.delete(_);
            }
          );
        }
        UnregisterModalManager(_) {
          this.m_mapModalManager.delete(_);
        }
      })();
      var _ = __webpack_require__("chunkid");
      __webpack_require__("chunkid");
      __webpack_require__("chunkid");
      const _ = _.createContext({});
      function _(_) {
        const [_, __webpack_require__] = _.useState(null),
          _ = _.useMemo(
            () => ({
              targetElement: _,
            }),
            [_],
          );
        return _.createElement(
          _.Provider,
          {
            value: _,
          },
          _.createElement("div", {
            ref: __webpack_require__,
          }),
          _.children,
        );
      }
      function _(_) {
        _.useEffect(() => {
          if (_)
            return (
              document.body.classList.add(_.BodyNoScrollDialog),
              () => document.body.classList.remove(_.BodyNoScrollDialog)
            );
        }, [_]);
      }
      function _(_) {
        let {
          ModalManager: _,
          bRegisterModalManager: __webpack_require__ = !0,
          DialogWrapper: _,
          rctActiveContextMenus: _,
          bUseDialogElement: _ = !0,
          style: _,
          ..._
        } = _;
        const _ = _.modals,
          _ = _ && !!_.length,
          _ = _.active_modal;
        _(_),
          (function (_) {
            const _ = _().ownerWindow,
              _ = _(),
              _ = _.useCallback(() => {
                _?.SteamClient?.Window && _.SteamClient.Window.BringToFront();
              }, [_]);
            _.useEffect(() => _.RegisterOverlay(_), [_, _]),
              _.useEffect(
                () => _.RegisterOnModalShownCallback(_).Unregister,
                [_, _],
              );
          })(_);
        const _ = (function (_, _) {
          return _(
            (_) => {
              if (!_ || !_) return;
              const _ = _.ownerDocument.defaultView;
              return _.RegisterModalManager(_, _);
            },
            [_],
          );
        })(_, __webpack_require__);
        let _ = null,
          _ = !_;
        return (
          _ && _.length
            ? (_ = _.map((_) => {
                const _ = _ == _,
                  _ = {
                    key: _.key,
                    active: _,
                    rctActiveContextMenus: _ && _ ? _ : void 0,
                  };
                return _ instanceof _
                  ? _.createElement(_, {
                      ..._,
                      key: _.key,
                      modal: _,
                      Component: _ ?? _,
                    })
                  : _ instanceof _
                    ? _.createElement(_, {
                        ..._,
                        key: _.key,
                        modal: _,
                        bUseDialogElement: _,
                      })
                    : void 0;
              }))
            : ((_ = !0),
              (_ = {
                ..._,
                display: "none",
              })),
          _.createElement(
            _.Fragment,
            null,
            _.createElement(
              _,
              null,
              _.createElement(
                "div",
                {
                  ..._,
                  style: _,
                  ref: _,
                  className: (0, _._)(_.className, "FullModalOverlay"),
                },
                _.createElement("div", {
                  className: "ModalOverlayContent ModalOverlayBackground",
                }),
                _,
              ),
              _ && _,
            ),
            _.createElement(_, {
              ModalManager: _,
            }),
            _.createElement(_, {
              ModalManager: _,
            }),
          )
        );
      }
      function _(_) {
        const {
          modal: _,
          rctActiveContextMenus: __webpack_require__,
          active: _,
          bUseDialogElement: _,
        } = _;
        _.useEffect(() => {
          if (_)
            return (
              _.SetActive(_),
              () => {
                _.SetActive(!1);
              }
            );
        }, [_, _]);
        const _ = _.createElement(
          _,
          null,
          _.createElement("div", {
            className: (0, _._)(
              "ModalOverlayContent",
              _ ? "active" : "inactive",
            ),
            ref: _.RefModalElement,
          }),
          __webpack_require__,
        );
        return _
          ? _.createElement(
              _,
              {
                active: _,
              },
              _,
            )
          : _;
      }
      function _(_) {
        const {
            modal: _,
            active: __webpack_require__,
            rctActiveContextMenus: _,
            Component: _,
          } = _,
          _ = _();
        return (
          _(_.ModalUpdatedCallback, _),
          _.createElement(
            _,
            null,
            _.createElement(
              _,
              {
                className: (0, _._)(
                  "ModalOverlayContent",
                  __webpack_require__ ? "active" : "inactive",
                ),
                active: __webpack_require__,
                modalKey: _.key,
              },
              _,
              _.element,
            ),
          )
        );
      }
      function _(_) {
        const { className: _, active: __webpack_require__, children: _ } = _;
        return _.createElement(
          _,
          {
            active: __webpack_require__,
          },
          _.createElement(
            _,
            null,
            _.createElement(
              "div",
              {
                className: _,
                tabIndex: -1,
              },
              _,
            ),
          ),
        );
      }
      function _(_) {
        const { active: _, children: __webpack_require__ } = _,
          _ = _.useRef(null),
          [_, _] = _.useState(!1);
        return (
          _.useLayoutEffect(() => {
            _ && !_ ? _(!0) : !_ && _ && _.current?.close();
          }, [_, _]),
          _.useLayoutEffect(() => {
            _ && _.current.showModal();
          }, [_]),
          _.createElement(
            "dialog",
            {
              ref: _,
              className: _.ModalDialog,
              onClose: () => _(!1),
              onCancel: (_) => _.preventDefault(),
            },
            __webpack_require__,
          )
        );
      }
      function _(_) {
        const { ModalManager: _ } = _,
          _ = _();
        return (
          _(_.LegacyPopupModalCountChangedCallbacks, _),
          _.createElement(
            _.Fragment,
            null,
            _.legacy_popup_modals.map((_) =>
              _.createElement(_, {
                key: _.key,
                Modal: _,
              }),
            ),
          )
        );
      }
      const _ = _.createContext({}),
        _ = _.memo(function (_) {
          const {
              children: _,
              bRenderOverlayAtRoot: __webpack_require__,
              refModalManager: _,
              DialogWrapper: _,
              bUseDialogElement: _ = !0,
              ContextMenuComponent: _ = _,
              refContextMenuManager: _,
              browserInfo: _,
              bUsePopups: _,
              bOnlyPopups: _,
              bCenterPopupsOnWindow: _,
              bRegisterManagersWithWindow: _ = !0,
              ..._
            } = _,
            _ = _.useRef(void 0);
          _.current || (_.current = new _());
          let _ = _.createElement(_, {
            ..._,
            DialogWrapper: _,
            ModalManager: _.current,
            bUseDialogElement: _,
            bRegisterModalManager: _,
            rctActiveContextMenus: _.createElement(_, null),
          });
          _.bRenderOverlayAtRoot &&
            "undefined" != typeof document &&
            "body" in document &&
            (_ = _.createPortal(_, document.body)),
            (function (_, _) {
              const _ = _.useRef(!1);
              _.useLayoutEffect(
                () => () => {
                  _.current && _(_, void 0);
                },
                [_],
              ),
                _.useLayoutEffect(() => {
                  (_ || _.current) && (_(_, _), (_.current = !!_));
                }, [_, _]);
            })(_, _.current),
            void 0 !== _ && _.current?.SetUsePopups(_),
            void 0 !== _ && _.current?.SetCenterPopupsOnWindow(_),
            void 0 !== _ && _.current?.SetOnlyPopups(_),
            _.current.SetBrowserInfo(_);
          const _ = _.useMemo(
            () => ({
              ModalManager: _.current,
              DialogWrapper: _,
            }),
            [_],
          );
          return _.createElement(
            _.Provider,
            {
              value: _,
            },
            _.createElement(
              _,
              {
                refContextMenuManager: _,
                bRegisterMenuManager: _,
              },
              _.createElement(_, null, _),
              _.children,
            ),
          );
        });
      function _() {
        return _.useContext(_).ModalManager;
      }
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      const _ = _.createContext(void 0),
        _ = _.Provider;
      function _(_) {
        const { useStorage: _, children: __webpack_require__ } = _;
        let _, _;
        if ("useActiveCMInterface" in _) _ = _ = _.useActiveCMInterface;
        else {
          if (!("useActiveSteamInterface" in _))
            return (
              (0, _._)(
                _,
                "neither useActiveCMInterface nor useActiveSteamInterface were provided",
              ),
              __webpack_require__
            );
          _ = _.useActiveSteamInterface;
        }
        const _ = _.useMemo(
          () => ({
            useActiveSteamInterface: _,
            useActiveCMInterface: _,
            useStorage: _,
          }),
          [_, _, _],
        );
        return _.createElement(
          _,
          {
            value: _,
          },
          __webpack_require__,
        );
      }
      let _ = _.lazy(() =>
        __webpack_require__
          ._("chunkid")
          .then(__webpack_require__.bind(__webpack_require__, "chunkid")),
      );
      const _ = new _._({
          defaultOptions: {
            queries: {
              gcTime: 864e5,
              staleTime: 1 / 0,
            },
          },
        }),
        _ = (0, _._)({
          storage: window.localStorage,
        });
      let _ = class extends _.Component {
        render() {
          return _.createElement(
            _._,
            null,
            _.createElement(
              _._,
              {
                client: _,
                persistOptions: {
                  persister: _,
                  buster: "v1",
                  maxAge: 6e4,
                  dehydrateOptions: {
                    shouldDehydrateQuery: (_) => _.meta?.persist,
                  },
                },
              },
              _.createElement(
                _,
                {
                  useActiveSteamInterface: () => {},
                  useStorage: () => {},
                },
                _.createElement(
                  _,
                  null,
                  _.createElement(
                    _._,
                    {
                      basename: _(),
                    },
                    _.createElement(
                      _.Suspense,
                      {
                        fallback: null,
                      },
                      _.createElement(
                        _._,
                        null,
                        _.createElement(_._, {
                          path: _(),
                          component: _,
                        }),
                        _.createElement(_._, {
                          path: _(":page"),
                          render: () =>
                            _.createElement(_._, {
                              _: _(),
                            }),
                        }),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          );
        }
      };
      _ = (0, _._)([_._], _);
      const _ = _;
      var _ = __webpack_require__("chunkid");
      __webpack_require__("chunkid"), __webpack_require__("chunkid");
      new Map();
      __webpack_require__("chunkid");
      let _ = new (class {
        Init() {
          _.createRoot(document.getElementById("react_root")).render(
            _.createElement(_, {
              app: this,
            }),
          );
        }
      })();
      const _ = ["main", "oldgods"];
      document.addEventListener("DOMContentLoaded", async function () {
        (0, _._)("application_config"),
          (0, _._)(),
          await (async function (_) {
            const _ = await Promise.all([
              __webpack_require__("chunkid")(`./shared_${_}.json`),
              ..._.map((_) =>
                __webpack_require__("chunkid")(`./${_}_${_}.json`),
              ),
            ]);
            let _ = {};
            for (const _ of _)
              _ = {
                ..._,
                ..._,
              };
            const _ = _._.GetLanguageFallback(_);
            if (_ !== _) {
              const _ = await Promise.all([
                __webpack_require__("chunkid")(`./shared_${_}.json`),
                ..._.map((_) =>
                  __webpack_require__("chunkid")(`./${_}_${_}.json`),
                ),
              ]);
              let _ = {};
              for (const _ of _)
                _ = {
                  ..._,
                  ..._,
                };
              _._.InitFromObjects(_, _, _[0].default, _[0].default);
            } else _._.InitFromObjects(_, null, _[0].default, null);
          })(_._.LANGUAGE),
          _.Init();
      });
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
      });
      function _(_, _ = 0) {
        switch (_) {
          case "english":
            return 0;
          case "german":
            return 1;
          case "french":
            return 2;
          case "italian":
            return 3;
          case "korean":
          case "koreana":
            return 4;
          case "spanish":
            return 5;
          case "schinese":
            return 6;
          case "tchinese":
            return 7;
          case "russian":
            return 8;
          case "thai":
            return 9;
          case "japanese":
            return 10;
          case "portuguese":
            return 11;
          case "polish":
            return 12;
          case "danish":
            return 13;
          case "dutch":
            return 14;
          case "finnish":
            return 15;
          case "norwegian":
            return 16;
          case "swedish":
            return 17;
          case "hungarian":
            return 18;
          case "czech":
            return 19;
          case "romanian":
            return 20;
          case "turkish":
            return 21;
          case "arabic":
            return 25;
          case "brazilian":
            return 22;
          case "bulgarian":
            return 23;
          case "greek":
            return 24;
          case "ukrainian":
            return 26;
          case "latam":
            return 27;
          case "vietnamese":
            return 28;
          case "sc_schinese":
            return 29;
          case "indonesian":
            return 30;
          default:
            return _;
        }
      }
      var _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _;
      !(function (_) {
        (_[(_.k_EConnectivityTestResult_Unknown = 0)] =
          "k_EConnectivityTestResult_Unknown"),
          (_[(_.k_EConnectivityTestResult_Connected = 1)] =
            "k_EConnectivityTestResult_Connected"),
          (_[(_.k_EConnectivityTestResult_CaptivePortal = 2)] =
            "k_EConnectivityTestResult_CaptivePortal"),
          (_[(_.k_EConnectivityTestResult_TimedOut = 3)] =
            "k_EConnectivityTestResult_TimedOut"),
          (_[(_.k_EConnectivityTestResult_Failed = 4)] =
            "k_EConnectivityTestResult_Failed"),
          (_[(_.k_EConnectivityTestResult_WifiDisabled = 5)] =
            "k_EConnectivityTestResult_WifiDisabled"),
          (_[(_.k_EConnectivityTestResult_NoLAN = 6)] =
            "k_EConnectivityTestResult_NoLAN");
      })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_ENetFakeLocalSystemState_Normal = 0)] =
            "k_ENetFakeLocalSystemState_Normal"),
            (_[(_.k_ENetFakeLocalSystemState_NoLAN = 1)] =
              "k_ENetFakeLocalSystemState_NoLAN"),
            (_[(_.k_ENetFakeLocalSystemState_CaptivePortal_Redirected = 2)] =
              "k_ENetFakeLocalSystemState_CaptivePortal_Redirected"),
            (_[(_.k_ENetFakeLocalSystemState_CaptivePortal_InPlace = 3)] =
              "k_ENetFakeLocalSystemState_CaptivePortal_InPlace"),
            (_[(_.k_ENetFakeLocalSystemState_NoInternet = 4)] =
              "k_ENetFakeLocalSystemState_NoInternet"),
            (_[(_.k_ENetFakeLocalSystemState_NoSteam = 5)] =
              "k_ENetFakeLocalSystemState_NoSteam");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_ESuspendResumeProgressState_Invalid = 0)] =
            "k_ESuspendResumeProgressState_Invalid"),
            (_[(_.k_ESuspendResumeProgressState_Complete = 1)] =
              "k_ESuspendResumeProgressState_Complete"),
            (_[(_.k_ESuspendResumeProgressState_CloudSync = 2)] =
              "k_ESuspendResumeProgressState_CloudSync"),
            (_[(_.k_ESuspendResumeProgressState_LoggingIn = 3)] =
              "k_ESuspendResumeProgressState_LoggingIn"),
            (_[(_.k_ESuspendResumeProgressState_WaitingForApp = 4)] =
              "k_ESuspendResumeProgressState_WaitingForApp"),
            (_[(_.k_ESuspendResumeProgressState_Working = 5)] =
              "k_ESuspendResumeProgressState_Working");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EFloatingGamepadTextInputModeModeSingleLine = 0)] =
            "k_EFloatingGamepadTextInputModeModeSingleLine"),
            (_[(_.k_EFloatingGamepadTextInputModeModeMultipleLines = 1)] =
              "k_EFloatingGamepadTextInputModeModeMultipleLines"),
            (_[(_.k_EFloatingGamepadTextInputModeModeEmail = 2)] =
              "k_EFloatingGamepadTextInputModeModeEmail"),
            (_[(_.k_EFloatingGamepadTextInputModeModeNumeric = 3)] =
              "k_EFloatingGamepadTextInputModeModeNumeric");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EAppUpdateContentType_Content = 0)] =
            "k_EAppUpdateContentType_Content"),
            (_[(_.k_EAppUpdateContentType_Workshop = 1)] =
              "k_EAppUpdateContentType_Workshop"),
            (_[(_.k_EAppUpdateContentType_Shader = 2)] =
              "k_EAppUpdateContentType_Shader"),
            (_[(_.k_EAppUpdateContentType_Max = 3)] =
              "k_EAppUpdateContentType_Max");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EAppUpdateProgress_VerifyingInstalledFiles = 0)] =
            "k_EAppUpdateProgress_VerifyingInstalledFiles"),
            (_[(_.k_EAppUpdateProgress_Preallocating = 1)] =
              "k_EAppUpdateProgress_Preallocating"),
            (_[(_.k_EAppUpdateProgress_Download = 2)] =
              "k_EAppUpdateProgress_Download"),
            (_[(_.k_EAppUpdateProgress_Staging = 3)] =
              "k_EAppUpdateProgress_Staging"),
            (_[(_.k_EAppUpdateProgress_VerifyingStagedFiles = 4)] =
              "k_EAppUpdateProgress_VerifyingStagedFiles"),
            (_[(_.k_EAppUpdateProgress_Copying = 5)] =
              "k_EAppUpdateProgress_Copying"),
            (_[(_.k_EAppUpdateProgress_Committing = 6)] =
              "k_EAppUpdateProgress_Committing"),
            (_[(_.k_EAppUpdateProgress_Max = 7)] = "k_EAppUpdateProgress_Max");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EOverlayToStoreFlag_None = 0)] =
            "k_EOverlayToStoreFlag_None"),
            (_[(_.k_EOverlayToStoreFlag_AddToCart = 1)] =
              "k_EOverlayToStoreFlag_AddToCart"),
            (_[(_.k_EOverlayToStoreFlag_AddToCartAndShow = 2)] =
              "k_EOverlayToStoreFlag_AddToCartAndShow");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EActivateGameOverlayToWebPageMode_Default = 0)] =
            "k_EActivateGameOverlayToWebPageMode_Default"),
            (_[(_.k_EActivateGameOverlayToWebPageMode_Modal = 1)] =
              "k_EActivateGameOverlayToWebPageMode_Modal");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_ELoginUIStyleOld = 0)] = "k_ELoginUIStyleOld"),
            (_[(_.k_ELoginUIStyleNewWithoutQRCode = 1)] =
              "k_ELoginUIStyleNewWithoutQRCode"),
            (_[(_.k_ELoginUIStyleNew = 2)] = "k_ELoginUIStyleNew");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_ECommunityProfileItemProperty_ImageSmall = 0)] =
            "k_ECommunityProfileItemProperty_ImageSmall"),
            (_[(_.k_ECommunityProfileItemProperty_ImageLarge = 1)] =
              "k_ECommunityProfileItemProperty_ImageLarge"),
            (_[(_.k_ECommunityProfileItemProperty_InternalName = 2)] =
              "k_ECommunityProfileItemProperty_InternalName"),
            (_[(_.k_ECommunityProfileItemProperty_Title = 3)] =
              "k_ECommunityProfileItemProperty_Title"),
            (_[(_.k_ECommunityProfileItemProperty_Description = 4)] =
              "k_ECommunityProfileItemProperty_Description"),
            (_[(_.k_ECommunityProfileItemProperty_AppID = 5)] =
              "k_ECommunityProfileItemProperty_AppID"),
            (_[(_.k_ECommunityProfileItemProperty_TypeID = 6)] =
              "k_ECommunityProfileItemProperty_TypeID"),
            (_[(_.k_ECommunityProfileItemProperty_Class = 7)] =
              "k_ECommunityProfileItemProperty_Class"),
            (_[(_.k_ECommunityProfileItemProperty_MovieWebM = 8)] =
              "k_ECommunityProfileItemProperty_MovieWebM"),
            (_[(_.k_ECommunityProfileItemProperty_MovieMP4 = 9)] =
              "k_ECommunityProfileItemProperty_MovieMP4"),
            (_[(_.k_ECommunityProfileItemProperty_MovieWebMSmall = 10)] =
              "k_ECommunityProfileItemProperty_MovieWebMSmall"),
            (_[(_.k_ECommunityProfileItemProperty_MovieMP4Small = 11)] =
              "k_ECommunityProfileItemProperty_MovieMP4Small");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_ERaiseGameWindowResult_NotRunning = 1)] =
            "k_ERaiseGameWindowResult_NotRunning"),
            (_[(_.k_ERaiseGameWindowResult_Success = 2)] =
              "k_ERaiseGameWindowResult_Success"),
            (_[(_.k_ERaiseGameWindowResult_Failure = 3)] =
              "k_ERaiseGameWindowResult_Failure");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EPositionInvalid = -1)] = "k_EPositionInvalid"),
            (_[(_.k_EPositionTopLeft = 0)] = "k_EPositionTopLeft"),
            (_[(_.k_EPositionTopRight = 1)] = "k_EPositionTopRight"),
            (_[(_.k_EPositionBottomLeft = 2)] = "k_EPositionBottomLeft"),
            (_[(_.k_EPositionBottomRight = 3)] = "k_EPositionBottomRight");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EAppReleaseState_Unknown = 0)] =
            "k_EAppReleaseState_Unknown"),
            (_[(_.k_EAppReleaseState_Unavailable = 1)] =
              "k_EAppReleaseState_Unavailable"),
            (_[(_.k_EAppReleaseState_Prerelease = 2)] =
              "k_EAppReleaseState_Prerelease"),
            (_[(_.k_EAppReleaseState_PreloadOnly = 3)] =
              "k_EAppReleaseState_PreloadOnly"),
            (_[(_.k_EAppReleaseState_Released = 4)] =
              "k_EAppReleaseState_Released"),
            (_[(_.k_EAppReleaseState_Disabled = 5)] =
              "k_EAppReleaseState_Disabled");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EGameIDTypeApp = 0)] = "k_EGameIDTypeApp"),
            (_[(_.k_EGameIDTypeGameMod = 1)] = "k_EGameIDTypeGameMod"),
            (_[(_.k_EGameIDTypeShortcut = 2)] = "k_EGameIDTypeShortcut"),
            (_[(_.k_EGameIDTypeP2P = 3)] = "k_EGameIDTypeP2P");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EInstallMgrStateNone = 0)] = "k_EInstallMgrStateNone"),
            (_[(_.k_EInstallMgrStateSetup = 1)] = "k_EInstallMgrStateSetup"),
            (_[(_.k_EInstallMgrStateWaitLicense = 2)] =
              "k_EInstallMgrStateWaitLicense"),
            (_[(_.k_EInstallMgrStateFreeLicense = 3)] =
              "k_EInstallMgrStateFreeLicense"),
            (_[(_.k_EInstallMgrStateShowCDKey = 4)] =
              "k_EInstallMgrStateShowCDKey"),
            (_[(_.k_EInstallMgrStateWaitAppInfo = 5)] =
              "k_EInstallMgrStateWaitAppInfo"),
            (_[(_.k_EInstallMgrStateShowPassword = 6)] =
              "k_EInstallMgrStateShowPassword"),
            (_[(_.k_EInstallMgrStateShowConfig = 7)] =
              "k_EInstallMgrStateShowConfig"),
            (_[(_.k_EInstallMgrStateShowEULAs = 8)] =
              "k_EInstallMgrStateShowEULAs"),
            (_[(_.k_EInstallMgrStateCreateApps = 9)] =
              "k_EInstallMgrStateCreateApps"),
            (_[(_.k_EInstallMgrStateReadFromMedia = 10)] =
              "k_EInstallMgrStateReadFromMedia"),
            (_[(_.k_EInstallMgrStateShowChangeMedia = 11)] =
              "k_EInstallMgrStateShowChangeMedia"),
            (_[(_.k_EInstallMgrStateWaitLegacyCDKeys = 12)] =
              "k_EInstallMgrStateWaitLegacyCDKeys"),
            (_[(_.k_EInstallMgrStateShowSignup = 13)] =
              "k_EInstallMgrStateShowSignup"),
            (_[(_.k_EInstallMgrStateComplete = 14)] =
              "k_EInstallMgrStateComplete"),
            (_[(_.k_EInstallMgrStateFailed = 15)] = "k_EInstallMgrStateFailed"),
            (_[(_.k_EInstallMgrStateCanceled = 16)] =
              "k_EInstallMgrStateCanceled");
        })(_ || (_ = {})),
        (function (_) {
          (_[(_.k_EWindowBringToFrontInvalid = 0)] =
            "k_EWindowBringToFrontInvalid"),
            (_[(_.k_EWindowBringToFrontAndForceOS = 1)] =
              "k_EWindowBringToFrontAndForceOS"),
            (_[(_.k_EWindowBringToFrontWithoutForcingOS = 2)] =
              "k_EWindowBringToFrontWithoutForcingOS");
        })(_ || (_ = {}));
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      function _(_, _) {
        return (function (_, _) {
          const _ = _.findIndex(_);
          return _ >= 0 && (_.splice(_, 1), !0);
        })(_, (_) => _ == _);
      }
      __webpack_require__._(module_exports, {
        _: () => _,
      });
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      function _(_, _, ...__webpack_require__) {
        console.assert
          ? 0 == __webpack_require__.length
            ? console.assert(!!_, _)
            : console.assert(!!_, _, ...__webpack_require__)
          : _ || console.warn(_, ...__webpack_require__);
      }
      function _(_, _, ...__webpack_require__) {
        _(!1, _, ...__webpack_require__);
      }
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
      });
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      function _(_, _, _) {
        return {
          get() {
            let _ = _.value.bind(this);
            return (
              Object.prototype.hasOwnProperty.call(this, _) ||
                Object.defineProperty(this, _, {
                  value: _,
                }),
              _
            );
          },
        };
      }
      __webpack_require__._(module_exports, {
        _: () => _,
      });
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      __webpack_require__._(module_exports, {
        _: () => _,
      });
      var _ = __webpack_require__("chunkid");
      class _ {
        m_vecCallbacks = [];
        Register(_) {
          this.m_vecCallbacks.push(_);
          return {
            Unregister: () => {
              _._(this.m_vecCallbacks, _);
            },
          };
        }
        Dispatch(..._) {
          for (const _ of Array.from(this.m_vecCallbacks)) _(..._);
        }
        ClearAllCallbacks() {
          this.m_vecCallbacks = [];
        }
        CountRegistered() {
          return this.m_vecCallbacks.length;
        }
        static PromiseFromAny(_) {
          return new Promise((_) => {
            let _ = [];
            const _ = () => {
              __webpack_require__.forEach((_) => _.Unregister()), _();
            };
            for (const _ of _) __webpack_require__.push(_.Register(_));
          });
        }
      }
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      function _(_, _) {
        return (
          (_ = Math.ceil(_)),
          (_ = Math.floor(_)),
          Math.floor(Math.random() * (_ - _ + 1)) + _
        );
      }
      function _(_, _, _) {
        return null == _ || isNaN(_) ? _ : Math.max(_, Math.min(_, _));
      }
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
      });
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _._,
      });
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      class _ {
        SyncStore(_) {
          return this.Subscribe(_).Unsubscribe;
        }
        GetValue() {
          return this.Value;
        }
      }
      (0, _._)([_._], _.prototype, "SyncStore", null),
        (0, _._)([_._], _.prototype, "GetValue", null);
      class _ extends _ {}
      class _ extends _ {
        m_callbacks;
        m_currentValue;
        m_fnEquals;
        constructor(_, _) {
          super(),
            (this.m_callbacks = new _._()),
            (this.m_currentValue = _),
            (this.m_fnEquals = _);
        }
        Set(_) {
          if (this.m_fnEquals) {
            if (this.m_fnEquals(this.m_currentValue, _)) return !1;
          } else if (this.m_currentValue === _) return !1;
          return (this.m_currentValue = _), this.m_callbacks.Dispatch(_), !0;
        }
        get Value() {
          return this.m_currentValue;
        }
        Subscribe(_) {
          return {
            Unsubscribe: this.m_callbacks.Register(_).Unregister,
          };
        }
        get SubscriberCount() {
          return this.m_callbacks.CountRegistered();
        }
      }
      function _(_, _) {
        return new _(_, _);
      }
      (0, _._)(
        [_._],
        class {
          m_schTimer;
          m_fnCallback;
          m_fnOnCancel;
          Schedule(_, _) {
            this.IsScheduled() && this.Cancel(),
              (this.m_fnCallback = _),
              (this.m_schTimer = window.setTimeout(this.ScheduledInternal, _));
          }
          AsyncSchedule(_, _) {
            return new Promise((_, _) => {
              this.Schedule(_, () => {
                _(), __webpack_require__();
              }),
                (this.m_fnOnCancel = _);
            });
          }
          IsScheduled() {
            return void 0 !== this.m_schTimer;
          }
          Cancel() {
            if (this.m_schTimer) {
              const _ = this.m_fnOnCancel;
              clearTimeout(this.m_schTimer), this.Reset(), _ && _();
            }
          }
          Reset() {
            (this.m_schTimer = void 0),
              (this.m_fnCallback = void 0),
              (this.m_fnOnCancel = void 0);
          }
          ScheduledInternal() {
            const _ = this.m_fnCallback;
            this.Reset(), _?.();
          }
        }.prototype,
        "ScheduledInternal",
        null,
      );
      (0, _._)(
        [_._],
        class {
          m_vecCallbacks = [];
          Push(_) {
            this.m_vecCallbacks.push(_);
          }
          PushArrayRemove(_, _) {
            this.m_vecCallbacks.push(() => _._(_, _));
          }
          Unregister() {
            for (const _ of this.m_vecCallbacks) _();
            this.m_vecCallbacks = [];
          }
          GetUnregisterFunc() {
            return this.Unregister;
          }
        }.prototype,
        "Unregister",
        null,
      );
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      function _(..._) {
        return _.reduce(
          (_, _) =>
            _
              ? "string" == typeof _
                ? _
                  ? `${_} ${_}`
                  : _
                : "object" == typeof _
                  ? _
                    ? `${_} ${_(_)}`
                    : _(_)
                  : _
              : _,
          "",
        );
      }
      function _(_) {
        return Object.keys(_).reduce(
          (_, _) => (_[_] ? (_ ? `${_} ${_}` : _) : _),
          "",
        );
      }
      __webpack_require__._(module_exports, {
        _: () => _,
      });
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
      });
      __webpack_require__("chunkid");
      var _,
        _ = __webpack_require__("chunkid");
      !(function (_) {
        (_[(_.k_ESteamRealmUnknown = 0)] = "k_ESteamRealmUnknown"),
          (_[(_.k_ESteamRealmGlobal = 1)] = "k_ESteamRealmGlobal"),
          (_[(_.k_ESteamRealmChina = 2)] = "k_ESteamRealmChina");
      })(_ || (_ = {}));
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      var _;
      !(function (_) {
        (_[(_.None = 0)] = "None"),
          (_[(_.Ago = 1)] = "Ago"),
          (_[(_.Remaining = 2)] = "Remaining");
      })(_ || (_ = {}));
      new Map();
      new Map();
      new Map(), new Map(), new Map(), new Map(), new Map(), new Map();
      class _ {
        m_mapTokens = new Map();
        m_mapFallbackTokens = new Map();
        m_cbkTokensChanged = new _._();
        m_rgLocalesToUse;
        m_bReportIndividualMissingTokens = !0;
        static sm_ErrorReportingStore;
        static InstallErrorReportingStore(_) {
          this.sm_ErrorReportingStore = _;
        }
        static GetLanguageFallback(_) {
          return "sc_schinese" === _ ? "schinese" : "english";
        }
        static GetELanguageFallback(_) {
          return 29 === _ ? 6 : 0;
        }
        static IsELanguageValidInRealm(_, _) {
          return (
            _ === (29 === _ ? _.k_ESteamRealmChina : _.k_ESteamRealmGlobal)
          );
        }
        static GetLanguageListForRealms(_) {
          const _ = new Array();
          for (let _ = 0; _ < 31; _++)
            for (const _ of _)
              if (this.IsELanguageValidInRealm(_, _)) {
                _.push(_);
                break;
              }
          return _;
        }
        InitFromObjects(_, _, _, _, _, _) {
          _ && (this.m_bReportIndividualMissingTokens = !1),
            _ || this.m_mapTokens.clear();
          const _ = {
              ...(_ || {}),
              ..._,
            },
            _ = {
              ...(_ || {}),
              ...(_ || {}),
            };
          this.AddTokens(_, _), this.m_cbkTokensChanged.Dispatch();
        }
        InitDirect(_, _) {
          this.m_mapTokens.clear(),
            this.m_mapFallbackTokens.clear(),
            this.AddTokens(_, _),
            this.m_cbkTokensChanged.Dispatch();
        }
        AddTokens(_, _) {
          Object.keys(_).forEach((_) => {
            this.m_mapTokens.set(_, _[_]);
          }),
            _ &&
              Object.keys(_).forEach((_) => {
                this.m_mapTokens.has(_) || this.m_mapTokens.set(_, _[_]),
                  this.m_mapFallbackTokens.set(_, _[_]);
              });
        }
        GetTokensChangedCallbackList() {
          return this.m_cbkTokensChanged;
        }
        GetPreferredLocales() {
          return this.m_rgLocalesToUse
            ? this.m_rgLocalesToUse
            : navigator && navigator.languages
              ? navigator.languages
              : ["en-US"];
        }
        GetELanguageFallbackOrder(_ = null) {
          let _ = new Array();
          if (
            (_.push((0, _._)(_._.LANGUAGE)),
            (_._.SUPPORTED_LANGUAGES || []).forEach((_) => {
              _.value != _._.LANGUAGE && _.push((0, _._)(_.value));
            }),
            _)
          ) {
            _.GetLanguageListForRealms(_).forEach((_) => {
              -1 == _.indexOf(_) && _.push(_);
            });
          }
          return _;
        }
        SetPreferredLocales(_) {
          this.m_rgLocalesToUse = _;
        }
        BLooksLikeToken(_) {
          return !!_ && _.length > 0 && "#" == _.charAt(0);
        }
        LocalizeIfToken(_, _) {
          return this.BLooksLikeToken(_) ? this.LocalizeString(_, _) : _;
        }
        LocalizeString(_, _) {
          const _ = 0 == this.m_mapTokens.size;
          if (
            ((0, _._)(
              !_,
              `Attempting to localize token '${_}' with no tokens in our map.`,
            ),
            !this.BLooksLikeToken(_))
          )
            return;
          let _ = this.m_mapTokens.get(_.substring(1));
          if (void 0 !== _) return _;
          !_ &&
            _.sm_ErrorReportingStore &&
            !_ &&
            this.m_bReportIndividualMissingTokens &&
            _.sm_ErrorReportingStore.ReportError(
              new Error(
                `Unable to find localization token '${_}' for language '${_._.LANGUAGE}', ${this.m_mapTokens.size} tokens in map`,
              ),
              {
                bIncludeMessageInIdentifier: !0,
              },
            );
        }
        LocalizeStringFromFallback(_) {
          if (!_ || 0 == _.length || "#" != _.charAt(0)) return;
          let _ = this.m_mapFallbackTokens.get(_.substring(1));
          return void 0 !== _ ? _ : void 0;
        }
        static GetTokenWithFallback(_) {
          if (!_) return "";
          const _ = (0, _._)(_._.LANGUAGE),
            _ = _.find((_) => _.language == _);
          if (_) return _.localized_string;
          const _ = _.GetELanguageFallback(_),
            _ = _.find((_) => _.language == _);
          return _?.localized_string ?? "";
        }
        static BHasTokenLanguage(_, _) {
          return Boolean(_.find((_) => _.language == _));
        }
      }
      function _(_) {
        return null != _.LocalizeString(_, !0);
      }
      function _(_, ..._) {
        let _ = _.LocalizeString(_);
        return void 0 === _ ? _ : _(_, ..._);
      }
      function _(_, ..._) {
        return 0 == _.length
          ? _
          : (_ = _.replace(/%(?:(\d+)\$)?s/g, function (_, _) {
              if (_ <= _.length && _ >= 1) {
                let _ = _[_ - 1];
                return String(null == _ ? "" : _);
              }
              return _;
            }));
      }
      const _ = {
        english: "en",
        german: "de",
        french: "fr",
        italian: "it",
        korean: "ko",
        latam: "es-419",
        spanish: "es",
        schinese: "zh-cn",
        tchinese: "zh-tw",
        russian: "ru",
        thai: "th",
        japanese: "ja",
        brazilian: "pt-br",
        portuguese: "pt",
        polish: "pl",
        danish: "da",
        dutch: "nl",
        finnish: "fi",
        norwegian: "no",
        swedish: "sv",
        hungarian: "hu",
        czech: "cs",
        romanian: "ro",
        turkish: "tr",
        arabic: "ar",
        bulgarian: "bg",
        greek: "el",
        ukrainian: "uk",
        vietnamese: "vi",
        indonesian: "id",
        sc_schinese: "zh-cn",
        koreana: "ko",
      };
      function _() {
        return _[_._.LANGUAGE] || null;
      }
      const _ = new _();
      window.LocalizationManager = _;
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      __webpack_require__._(module_exports, {
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
        _: () => _,
      });
      var _ = __webpack_require__("chunkid"),
        _ = __webpack_require__("chunkid");
      function _(_) {
        if (!_() || !window.document.cookie) return null;
        const _ = document.cookie.match("(^|; )" + _ + "=([^;]*)");
        return _ && _[2] ? decodeURIComponent(_[2]) : null;
      }
      function _() {
        return !!window.document;
      }
      const _ = "webui_config";
      let _;
      function _() {
        const _ = (function () {
          let _ = "";
          for (let _ = 0; _ < 24; _++) _ += (0, _._)(0, 35).toString(36);
          return _;
        })();
        return (
          (function (_, _, _, _) {
            if (!_()) return;
            _ || (_ = "/");
            let _ = "";
            if (void 0 !== _ && _) {
              const _ = new Date();
              _.setTime(_.getTime() + 864e5 * _),
                (_ = "; expires=" + _.toUTCString());
            }
            document.cookie =
              encodeURIComponent(_) +
              "=" +
              encodeURIComponent(_) +
              _ +
              ";path=" +
              _;
          })("sessionid", _, 0),
          _
        );
      }
      function _(_ = _) {
        const _ = {},
          _ = _("config", _);
        _ && (delete _.SESSIONID, Object.assign(_, _), (_.config = !0));
        const _ = _("userinfo", _);
        _ &&
          (Object.assign(_, _),
          (_.userConfig = !0),
          _.is_support &&
            (function () {
              let _ = null;
              _() && (_ = _(_));
              return Boolean(_ && 1 === Number.parseInt(_));
            })() &&
            (_.is_support = !1));
        const _ = _("broadcast", _);
        _ && (Object.assign(_, _), (_.broadcastConfig = !0));
        const _ = _("community", _);
        _ && (Object.assign(_, _), (_.communityConfig = !0));
        const _ = _("event", _);
        return (
          _ && (Object.assign(_, _), (_.eventConfig = !0)),
          (_ = !0),
          _.forEach((_) => _()),
          _
        );
      }
      let _ = new Set(),
        _ = !1;
      function _(_, _ = _) {
        return _(_, _, !0);
      }
      function _(_, _ = _, _) {
        let _;
        if (
          ((_ =
            "string" == typeof _
              ? {
                  NODE_ENV: "production",
                  STEAM_BUILD: "buildbot",
                }.MOBILE_BUILD
                ? null
                : document.getElementById(_)
              : _),
          _)
        )
          try {
            if (_.hasAttribute("data-" + _)) {
              return JSON.parse(_.getAttribute("data-" + _));
            }
            return null;
          } catch (_) {
            console.error(
              "Failed to parse config for " +
                _.steamid +
                " (" +
                window.location.href +
                ")",
              _,
            );
          }
        else _ && console.error("Missing config element #", _);
      }
      const _ = "presentation_mode";
      const _ = {
          EUNIVERSE: 0,
          WEB_UNIVERSE: "",
          LANGUAGE: "english",
          SUPPORTED_LANGUAGES: [],
          COUNTRY: "",
          AVATAR_BASE_URL: "",
          MEDIA_CDN_COMMUNITY_URL: "",
          MEDIA_CDN_URL: "",
          CLAN_CDN_ASSET_URL: "",
          COMMUNITY_ASSETS_BASE_URL: "",
          VIDEO_CDN_URL: "",
          COMMUNITY_CDN_URL: "",
          COMMUNITY_CDN_ASSET_URL: "",
          BASE_URL_SHARED_CDN: "",
          STORE_CDN_URL: "",
          PUBLIC_SHARED_URL: "",
          COMMUNITY_BASE_URL: "",
          CHAT_BASE_URL: "",
          STORE_BASE_URL: "",
          STORE_CHECKOUT_BASE_URL: "",
          LOGIN_BASE_URL: "",
          SUPPORT_BASE_URL: "",
          STORE_ICON_BASE_URL: "",
          STORE_ITEM_BASE_URL: "",
          IMG_URL: "",
          STEAMTV_BASE_URL: "",
          HELP_BASE_URL: "",
          PARTNER_BASE_URL: "",
          STATS_BASE_URL: "",
          INTERNAL_STATS_BASE_URL: "",
          BASE_URL_STORE_CDN_ASSETS: "",
          IN_CLIENT: !1,
          USE_POPUPS: !1,
          IN_MOBILE: !1,
          IN_MOBILE_WEBVIEW: !1,
          IN_TENFOOT: !1,
          PLATFORM: "",
          SNR: "",
          LAUNCHER_TYPE: 0,
          EREALM: 0,
          IN_CHROMEOS: !1,
          TESLA: !1,
          LOCAL_HOSTNAME: "",
          WEBAPI_BASE_URL: "",
          TOKEN_URL: "",
          BUILD_TIMESTAMP: 0,
          PAGE_TIMESTAMP: 0,
          FROM_WEB: !1,
          WEBSITE_ID: "Unknown",
          get SESSIONID() {
            return (function () {
              if (!_()) return _ || (_ = _()), _;
              let _ = _("sessionid");
              return _ || (_ = _()), _;
            })();
          },
          FRIENDSUI_BETA: !1,
          STEAM_TV: !1,
          DEV_MODE: !1,
          IN_STEAMUI: !1,
          IN_GAMEPADUI: !1,
          IN_STEAMUI_SHARED_CONTEXT: !1,
          FORCED_DISPLAY_MODE: void 0,
          ON_DECK: !1,
          ON_FRAME: !1,
          ON_STEAMOS: !1,
          IN_GAMESCOPE: !1,
          IN_LOGIN: !1,
          IN_LOGIN_REFRESH: !1,
          USE_LONGEST_LOC_STRING: !1,
          SILENT_STARTUP: !1,
          CLIENT_SESSION: 0,
        },
        _ = {
          logged_in: !1,
          steamid: "",
          accountid: 0,
          account_name: "",
          token: void 0,
          token_use_id: void 0,
          webapi_token: "",
          authwgtoken: "",
          is_support: !1,
          is_limited: !1,
          is_partner_member: !1,
          is_valve_email: !1,
          short_url: "",
          country_code: "",
          excluded_content_descriptors: [3, 4, 1],
        },
        _ = {
          steamid: "",
          clanid: 0,
          listid: 0,
        },
        _ = {
          CLANSTEAMID: "",
          CLANACCOUNTID: 0,
          APPID: 0,
          VANITY_ID: "",
          IS_CREATOR_HOME: !1,
          IS_CURATOR: !1,
          IS_OGG: !1,
          CAN_UPLOAD_IMAGES: !1,
          IS_VALVE_GROUP: !1,
          IS_ALLOWED_SC: !1,
        },
        _ = {
          ANNOUNCEMENT_GID: "",
          TAKEOVER_ANNOUNCEMENT_GID: "",
        };
      _.createContext({});
      function _() {
        return "windows" == _.PLATFORM;
      }
      function _() {
        return "macos" == _.PLATFORM;
      }
    },
    chunkid: (module, module_exports, __webpack_require__) => {
      "use strict";
      "VALVE_PUBLIC_PATH" in window
        ? (__webpack_require__._ = window.VALVE_PUBLIC_PATH)
        : console.error(
            "VALVE_PUBLIC_PATH not defined; check for a call to CHTMLHelpers::WebpackConfigScriptlet",
          ),
        123 !== Array.from(new Set([123]))[0] &&
          console.error("Should not include prototypejs.");
    },
  },
  (_) => {
    _._(0, [997], () => {
      return (_ = 587), _((_._ = _));
      var _;
    });
    _._();
  },
]);
