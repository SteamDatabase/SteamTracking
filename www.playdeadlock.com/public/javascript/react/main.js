/**** (c) Valve Corporation. Use is governed by the terms of the Steam Subscriber Agreement http://store.steampowered.com/subscriber_agreement/.
 ****/
(self.webpackChunkdeadlock_react = self.webpackChunkdeadlock_react || []).push([
  [792],
  {
    9483: (e, t, n) => {
      var o = {
        "./main_english.json": [7519, 519],
        "./oldgods_english.json": [9322, 322],
      };
      function i(e) {
        if (!n.o(o, e))
          return Promise.resolve().then(() => {
            var t = new Error("Cannot find module '" + e + "'");
            throw ((t.code = "MODULE_NOT_FOUND"), t);
          });
        var t = o[e],
          i = t[0];
        return n.e(t[1]).then(() => n.t(i, 19));
      }
      (i.keys = () => Object.keys(o)), (i.id = 9483), (e.exports = i);
    },
    7739: (e) => {
      e.exports = {
        HoverPosition: "_3vg1vYU7iTWqONciv9cuJN",
        Ready: "_1Ye_0niF2UqB8uQTbm8B6B",
        NoSpace: "pxVZHRCaftc2xXduMp7bg",
        EnablePointerEvents: "_2b9OEIbeIFhvcy770kO_TB",
        HoverAboveModal: "EQqOxt3B11pzZRCd8kmXj",
        HoverPositionOuter: "_2_lmTz0tA4NOSle5WaO1PZ",
      };
    },
    650: (e) => {
      e.exports = {
        "duration-app-launch": "800ms",
        ContextMenuMouseOverlay: "_3Knd7Am6tTwTTu605YN4IX",
        ContextMenuPosition: "_2yAm5LY_eu-Vg_52l0HFlM",
        contextMenu: "PP7LM0Ow1K5qkR8WElLpt",
        ContextMenuPopup: "_14wqdluDeDnnEcg3OSLEmd",
        contextMenuContents: "_2EstNjFIIZm_WUSKm5Wt7n",
        contextMenuItem: "_1n7Wloe5jZ6fSuvV18NNWI",
        active: "_18z-3vkWndCBO5WJgFldRK",
        MenuSectionHeader: "_2Bb4JC5n6anf32WgmTfeMP",
        ContextMenuSeparator: "WUOrULWKkGLl3ZUQdDXg8",
        NoSeparation: "_3hRb6_cI8QWlZX-eZmRbXc",
        UpperCase: "uz1XmeUiC1KBA7Y9nOwtn",
        SubMenu: "_2RlEO6dx1vo3OB7EFJnzDi",
        Label: "_2qdHlYPUfe_wwwtyPIu7m3",
        Arrow: "_114nFoGF7tZ4PpremDP2w0",
        IconContainer: "_38-c8Lb-zCJc8GmvTzoyL1",
        ContextMenuHRSeparator: "IjIBR_wDDi2N77Oz4KAT4",
        ForceDesktop: "_3qIuY9S_vXm3IQS-uE9SRS",
        PopoutSubMenu: "Baq37ml_4RsqEDikF0aIo",
        PopoutSubMenuItems: "_2fZ_eG4hoUgJoNBzVAW8wq",
      };
    },
    8843: (e) => {
      e.exports = {
        BodyNoScroll: "_1Xs5dtPK2K37sd1U9BLX3S",
        BodyNoScrollDialog: "_3jhMIr8hczcBK_fOVtEVOK",
        OverlayModal: "_24YFXIVY7CC2quNzCN7015",
        GamepadOnlyModalWrapper: "_1GlTsstfPZWsQc4umFIvrX",
        GamepadOnlyPanelWrapper: "_1aY-rmUi48QSw7U1ZWa5DZ",
        ModalDialog: "_32QRvPPBL733SpNR9x0Gp3",
      };
    },
    7866: (e) => {
      e.exports = {
        "duration-app-launch": "800ms",
        HasHorizontalDirection: "vnlCrJZjobtJHaugGSLqP",
        EmoticonBow: "_2LlztGU9T4SNsTD6znahfe",
        EmoticonBow_st0: "Fw2WGmXjh2zUxYfuy3xDn",
        EmoticonBow_st1: "luj0tT8JHriKkK3r7pzqP",
        SteamDeckCompatInfo: "_3VPnvw_CDKU-PQKK1pSDlN",
        SteamDeckCompatLogo: "_1dzQL1mVR8GTmmSi_kpDgr",
        SteamDeckCompatIcon: "_3hAj0iMJsfhKwnm2mfE098",
        SteamDeckCompatVerified: "kEODDe6M5cuHWuPlcQexX",
        SteamDeckCompatPlayable: "mPD42Bwx3VAs0qw9wubf2",
        SteamDeckCompatUnsupported: "_2LAaxz6RtHXrJJj9NzCNL4",
        SteamDeckCompatUnknown: "xBqU_GerRwzHIs8N9ratU",
        SteamOSCompatInformation: "_1Gr-Q9sFTdr7XhK5-j_qux",
        SteamOSCompatCompatible: "_1IeRz_QzfsACNiXS4gXHIT",
        SteamTVIcon: "_15p32SPTbcOsOrlb8o1MdF",
        SteamTVLogo: "fX8M83YDC9--4QLgVAEir",
        SteamTVSteam: "_1GjVGP2qdwSOEBKimtRG0k",
        SteamTVTV: "_12AVA1wr7SWXg9INaLfBzD",
        FlipInRTL: "AMU5Zvf1pJLZGVqbpGcUC",
      };
    },
    7077: (e) => {
      e.exports = {
        TextToolTip: "_2FxbHJzYoH024ko7zqcJOf",
        ToolTipCustom: "_3XGRklQrZMakU2xaYB0cLD",
        ToolTipTitle: "_1LhVfNukndDa_XWzq0vdg1",
        Center: "_2ZDqET0UaJoW_KYhO0WdTz",
        ToolTipInsetContent: "i4LuYcvtfPgYKx3qqvKUq",
      };
    },
    4919: (e, t, n) => {
      var o = {
        "./shared_arabic.json": [8476, 710],
        "./shared_brazilian.json": [9574, 562],
        "./shared_bulgarian.json": [3789, 449],
        "./shared_czech.json": [815, 591],
        "./shared_danish.json": [4289, 523],
        "./shared_dutch.json": [4978, 110],
        "./shared_english.json": [3800, 256],
        "./shared_finnish.json": [3907, 31],
        "./shared_french.json": [5040, 18],
        "./shared_german.json": [4750, 208],
        "./shared_greek.json": [9668, 712],
        "./shared_hungarian.json": [5233, 165],
        "./shared_indonesian.json": [200, 306],
        "./shared_italian.json": [1864, 912],
        "./shared_japanese.json": [7263, 973],
        "./shared_koreana.json": [295, 539],
        "./shared_latam.json": [559, 435],
        "./shared_norwegian.json": [6512, 320],
        "./shared_polish.json": [2889, 967],
        "./shared_portuguese.json": [2269, 239],
        "./shared_romanian.json": [4419, 749],
        "./shared_russian.json": [5777, 25],
        "./shared_sc_schinese.json": [3723, 27],
        "./shared_schinese.json": [5436, 786],
        "./shared_spanish.json": [6736, 632],
        "./shared_swedish.json": [4625, 225],
        "./shared_tchinese.json": [5191, 241],
        "./shared_thai.json": [4230, 976],
        "./shared_turkish.json": [4792, 152],
        "./shared_ukrainian.json": [7246, 954],
        "./shared_vietnamese.json": [9863, 149],
      };
      function i(e) {
        if (!n.o(o, e))
          return Promise.resolve().then(() => {
            var t = new Error("Cannot find module '" + e + "'");
            throw ((t.code = "MODULE_NOT_FOUND"), t);
          });
        var t = o[e],
          i = t[0];
        return n.e(t[1]).then(() => n.t(i, 19));
      }
      (i.keys = () => Object.keys(o)), (i.id = 4919), (e.exports = i);
    },
    2968: (e, t, n) => {
      "use strict";
      n.d(t, { U: () => i, a: () => s });
      var o = n(4094);
      let i = {
        EUNIVERSE: 0,
        WEB_UNIVERSE: "",
        LANGUAGE: "english",
        BASE_URL: "",
        IMG_URL: "",
        VIDEO_URL: "",
        AUDIO_URL: "",
        PROJECT_NAME: "",
        PROJECT_ROOT: "",
        VALVE_INTERNAL: !1,
      };
      function s() {
        let e = (0, o.Tc)("deadlock_react", "application_config");
        e && Object.assign(i, e);
      }
    },
    587: (e, t, n) => {
      "use strict";
      var o = n(2968),
        i = n(4629);
      const s = () => `${o.U.PROJECT_ROOT}`,
        r = (e) => "/",
        a = () => "/oldgods";
      var l = n(3288),
        c = n(626),
        u = n(7083),
        d = n(2757),
        m = n(3244);
      function h(e, t) {
        null != e &&
          ("function" == typeof e ? e(t) : "current" in e && (e.current = t));
      }
      function p(...e) {
        return c.useCallback((t) => {
          for (const n of e) h(n, t);
        }, e);
      }
      function _(e, t) {
        const n = c.useRef(void 0);
        return c.useCallback((t) => {
          n.current && n.current(), (n.current = e(t));
        }, t);
      }
      var g = n(2739),
        f = n(4947);
      function b(e) {
        return null != e && void 0 !== e.focus;
      }
      function E(e, t) {
        let n = t;
        for (; n; ) {
          if (
            (n.parentNode?.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
              (n = n.parentNode.host),
            n == e)
          )
            return !0;
          n = n.parentElement;
        }
        return !1;
      }
      function S(e, t) {
        return {
          top: e.screenTop + t.top,
          bottom: e.screenTop + t.bottom,
          left: e.screenLeft + t.left,
          right: e.screenLeft + t.right,
        };
      }
      function C() {
        return (function (e) {
          const t = {};
          return (
            e.querySelectorAll('link[rel="stylesheet"]').forEach((e) => {
              t[e.href] = e;
            }),
            t
          );
        })(document);
      }
      function v(e, t, n) {
        const o = Object.assign({}, t),
          i = e.getElementsByTagName("head")[0],
          s = i.getElementsByTagName("link"),
          r = s.length;
        for (let e = 0; e < r; ++e) {
          const t = s[e];
          o[t.href] ? delete o[t.href] : n && t.parentNode?.removeChild(t);
        }
        const a = [];
        for (const t in o) {
          const n = o[t],
            i = e.createElement("link");
          for (let e = 0; e < n.attributes.length; e++) {
            const t = n.attributes.item(e);
            i.setAttribute(t.name, t.value);
          }
          a.push(i);
        }
        return i.prepend(...a), a;
      }
      function w(e, t, n, o) {
        c.useEffect(() => {
          if (e && n)
            return (
              e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o)
            );
        }, [e, t, n]);
      }
      function M() {
        const [, e] = c.useState(0);
        return c.useCallback(() => e((e) => e + 1), []);
      }
      function y(e, t) {
        c.useLayoutEffect(() => {
          if (!t || !e) return;
          const n = e.Register(t);
          return () => n.Unregister();
        }, [e, t]);
      }
      function I(e) {
        return R;
      }
      function R() {}
      function k(e) {
        return c.useSyncExternalStore(
          e ? e.SyncStore : I,
          e ? e.GetValue : R,
          e ? e.GetValue : R,
        );
      }
      function T(e, t) {
        return (
          (function (e, t) {
            const [n, o] = c.useState(e);
            return (
              c.useEffect(() => {
                if (!e) {
                  const e = window.setTimeout(() => o(!1), t);
                  return () => window.clearTimeout(e);
                }
                o(!0);
              }, [e, t]),
              n
            );
          })(e, t) || e
        );
      }
      var O,
        A = n(4238),
        D = n.n(A),
        F = n(6144);
      !(function (e) {
        (e[(e.LaunchGame = 0)] = "LaunchGame"),
          (e[(e.FriendMessage = 1)] = "FriendMessage"),
          (e[(e.ChatMention = 2)] = "ChatMention"),
          (e[(e.ChatMessage = 3)] = "ChatMessage"),
          (e[(e.ToastMessage = 4)] = "ToastMessage"),
          (e[(e.ToastAchievement = 5)] = "ToastAchievement"),
          (e[(e.ToastMisc = 6)] = "ToastMisc"),
          (e[(e.ToastMiscShort = 7)] = "ToastMiscShort"),
          (e[(e.FriendOnline = 8)] = "FriendOnline"),
          (e[(e.FriendInGame = 9)] = "FriendInGame"),
          (e[(e.VolSound = 10)] = "VolSound"),
          (e[(e.ShowModal = 11)] = "ShowModal"),
          (e[(e.HideModal = 12)] = "HideModal"),
          (e[(e.IntoGameDetail = 13)] = "IntoGameDetail"),
          (e[(e.OutOfGameDetail = 14)] = "OutOfGameDetail"),
          (e[(e.PagedNavigation = 15)] = "PagedNavigation"),
          (e[(e.ToggleOn = 16)] = "ToggleOn"),
          (e[(e.ToggleOff = 17)] = "ToggleOff"),
          (e[(e.SliderUp = 18)] = "SliderUp"),
          (e[(e.SliderDown = 19)] = "SliderDown"),
          (e[(e.ChangeTabs = 20)] = "ChangeTabs"),
          (e[(e.DefaultOk = 21)] = "DefaultOk"),
          (e[(e.OpenSideMenu = 22)] = "OpenSideMenu"),
          (e[(e.CloseSideMenu = 23)] = "CloseSideMenu"),
          (e[(e.BasicNav = 24)] = "BasicNav"),
          (e[(e.FailedNav = 25)] = "FailedNav"),
          (e[(e.Typing = 26)] = "Typing"),
          (e[(e.TimerExpired = 27)] = "TimerExpired"),
          (e[(e.Screenshot = 28)] = "Screenshot");
      })(O || (O = {}));
      const P = new (class {
          m_fnCallbackOnPlaySound = new F.lu();
          m_fnCallbackOnSuppressSound = new F.lu();
          RegisterCallbackOnPlaySound(e) {
            return this.m_fnCallbackOnPlaySound.Register(e);
          }
          PlayNavSound(e, t) {
            this.m_fnCallbackOnPlaySound.Dispatch(e, t);
          }
          RegisterCallbackOnSuppressNavImminentSound(e) {
            return this.m_fnCallbackOnSuppressSound.Register(e);
          }
          SuppressImminentNavSound() {
            this.m_fnCallbackOnSuppressSound.Dispatch();
          }
        })(),
        L = c.createContext({ focusNavWindow: null, bSupportsFocus: !0 });
      function N(e = !0) {
        return c.useContext(L)?.bSupportsFocus ?? e;
      }
      var B = n(6419);
      class x {
        async GetObject(e, t) {
          try {
            const n = await this.GetString(e);
            return n ? JSON.parse(n, t) : null;
          } catch {
            return null;
          }
        }
        async StoreObject(e, t) {
          return this.StoreString(e, JSON.stringify(t));
        }
      }
      class W extends x {
        GetString(e) {
          return Promise.resolve(localStorage.getItem(e));
        }
        StoreString(e, t) {
          return localStorage.setItem(e, t), Promise.resolve();
        }
        RemoveObject(e) {
          return localStorage.removeItem(e), Promise.resolve();
        }
      }
      var H,
        U = n(1986);
      !(function (e) {
        (e[(e.Debug = 0)] = "Debug"),
          (e[(e.Info = 1)] = "Info"),
          (e[(e.Warning = 2)] = "Warning"),
          (e[(e.Error = 3)] = "Error");
      })(H || (H = {}));
      class G {
        m_sName;
        m_fnIdGenerator = void 0;
        constructor(e, t) {
          (this.m_sName = e),
            (this.m_fnIdGenerator = t),
            V.Get().RegisterLogName(e);
        }
        Debug(...e) {
          this.Log(H.Debug, ...e);
        }
        Info(...e) {
          this.Log(H.Info, ...e);
        }
        Warning(...e) {
          this.Log(H.Warning, ...e);
        }
        Error(...e) {
          this.Log(H.Error, ...e);
        }
        Assert(e, ...t) {
          e || this.Log(H.Error, "Assertion failed:", ...t);
        }
        IsDebugEnabled() {
          return V.Get().IsDebugLogEnabled(this.m_sName);
        }
        Log(e, ...t) {
          const n = V.Get().IsDebugLogEnabled(this.m_sName);
          if (e == H.Debug && !n) return;
          let o = this.m_sName;
          const i = this.m_fnIdGenerator?.() ?? null;
          null != i && (o += " (" + i + ")");
          K(e, n, V.Get().IncludeBacktraceInLog, o, this.m_sName, ...t);
        }
      }
      (0, i.Cg)([B.o], G.prototype, "Debug", null),
        (0, i.Cg)([B.o], G.prototype, "Info", null),
        (0, i.Cg)([B.o], G.prototype, "Warning", null),
        (0, i.Cg)([B.o], G.prototype, "Error", null),
        (0, i.Cg)([B.o], G.prototype, "Assert", null);
      class V {
        static k_EnabledLogNames_StorageKey = "EnabledWebLogs";
        static k_IncludeBacktraceInLog_StorageKey = "IncludeBacktraceInLog";
        static s_Singleton = null;
        m_Storage = null;
        m_setKnownDebugLogs = new Set();
        m_setEnabledDebugLogs = new Set();
        m_bIncludeBacktraceInLog = !1;
        m_SettingsChangedCallback = new U.l();
        m_bLoading = !1;
        constructor() {
          (this.m_Storage = new W()), this.LoadSettings();
        }
        LogAsLogManager(...e) {
          K(
            H.Info,
            !0,
            this.IncludeBacktraceInLog,
            "LogManager",
            "LogManager",
            ...e,
          );
        }
        async LoadSettings() {
          (this.m_bLoading = !0),
            (this.m_bIncludeBacktraceInLog = !!(await this.m_Storage?.GetObject(
              V.k_IncludeBacktraceInLog_StorageKey,
            )));
          const e = await this.m_Storage?.GetObject(
            V.k_EnabledLogNames_StorageKey,
          );
          if (Array.isArray(e)) {
            this.m_setEnabledDebugLogs = new Set(e);
            for (const t of e) this.m_setKnownDebugLogs.add(t);
            this.LogAsLogManager(
              "Loaded debug enabled log names. Will print log messages for:",
              Array.from(this.m_setEnabledDebugLogs),
            );
          } else 0;
          (this.m_bLoading = !1), this.m_SettingsChangedCallback.Dispatch();
        }
        async SaveSettings() {
          await this.m_Storage?.StoreObject(
            V.k_EnabledLogNames_StorageKey,
            Array.from(this.m_setEnabledDebugLogs),
          ),
            await this.m_Storage?.StoreObject(
              V.k_IncludeBacktraceInLog_StorageKey,
              this.m_bIncludeBacktraceInLog,
            ),
            this.LogAsLogManager(
              "Saved enabled debug log names. Will print log messages for:",
              Array.from(this.m_setEnabledDebugLogs),
            );
        }
        PrintEnabledLogs() {
          this.LogAsLogManager(
            "Will print log messages for:",
            Array.from(this.m_setEnabledDebugLogs),
          );
        }
        static Get() {
          return (
            null == V.s_Singleton && (V.s_Singleton = new V()), V.s_Singleton
          );
        }
        get Loading() {
          return this.m_bLoading;
        }
        get LogNames() {
          return this.m_setKnownDebugLogs.values();
        }
        RegisterLogName(e) {
          this.m_setKnownDebugLogs.add(e);
        }
        IsLogName(e) {
          return this.m_setKnownDebugLogs.has(e);
        }
        IsDebugLogEnabled(e) {
          return this.m_setEnabledDebugLogs.has(e);
        }
        async ToggleDebugLogEnabled(e) {
          this.SetDebugLogEnabled(e, !this.IsDebugLogEnabled(e));
        }
        async SetDebugLogEnabled(e, t) {
          t
            ? this.m_setEnabledDebugLogs.add(e)
            : this.m_setEnabledDebugLogs.delete(e),
            this.m_SettingsChangedCallback.Dispatch(),
            await this.SaveSettings();
        }
        async SetAllDebugLogsEnabled(e) {
          (this.m_setEnabledDebugLogs = e
            ? new Set(this.m_setKnownDebugLogs)
            : new Set()),
            this.m_SettingsChangedCallback.Dispatch(),
            await this.SaveSettings();
        }
        RegisterForSettingsChanges(e) {
          return this.m_SettingsChangedCallback.Register(e);
        }
        get IncludeBacktraceInLog() {
          return this.m_bIncludeBacktraceInLog;
        }
        async SetIncludeBacktraceInLog(e) {
          (this.m_bIncludeBacktraceInLog = e),
            this.m_SettingsChangedCallback.Dispatch(),
            await this.SaveSettings();
        }
      }
      function K(e, t, n, o, i, ...s) {
        const r = (function (e) {
            let t = 0;
            for (let n = 0; n < e.length; n++)
              t = e.charCodeAt(n) + ((t << 5) - t);
            return [(t >> 0) & 255, (t >> 8) & 255, (t >> 16) & 255];
          })(i).map((e, t) =>
            Math.round(
              Math.max(0, Math.min(255, 255 * (0.8 * (e / 255 - 0.5) + 0.15))),
            ),
          ),
          a = (299 * (l = r)[0] + 587 * l[1] + 114 * l[2]) / 1e3 >= 128;
        var l;
        let c = o;
        n &&
          (c =
            (function (e) {
              switch (e) {
                case H.Debug:
                  return String.fromCodePoint(128027);
                case H.Info:
                  return String.fromCodePoint(8505);
                case H.Warning:
                  return String.fromCodePoint(9888);
                case H.Error:
                  return String.fromCodePoint(128165);
              }
            })(e) +
            " " +
            c);
        const u =
            s.length >= 1 && "string" == typeof s[0] && s[0].includes("%c"),
          d = u && s.shift();
        let m;
        if (
          ((m = t
            ? [
                `%c${c}%c:${u ? " %c" + d : ""}`,
                `color: ${a ? "black" : "white"}; background: rgb(${r.join(",")}); padding: 0 1ch; border-radius: 3px;`,
                "color: transparent; margin-right: -1ch",
                ...(u ? [""] : []),
                ...s,
              ]
            : s),
          n)
        )
          console.groupCollapsed(...m),
            console.trace("Callstack"),
            console.groupEnd();
        else
          switch (e) {
            case H.Debug:
            case H.Info:
              console.log(...m);
              break;
            case H.Warning:
              console.warn(...m);
              break;
            case H.Error:
              console.clogerror
                ? console.clogerror(3, ...m)
                : console.error(...m);
          }
      }
      const z = () => [...V.Get().LogNames].sort(),
        j = (e, t) => {
          V.Get().IsLogName(e)
            ? V.Get().SetDebugLogEnabled(e, t)
            : console.warn(`No log named "${e}", available logs:`, z());
        };
      var $, q, Y;
      (window.DebugLogEnable = (...e) => e.forEach((e) => j(e, !0))),
        (window.DebugLogDisable = (...e) => e.forEach((e) => j(e, !1))),
        (window.DebugLogEnableAll = () => V.Get().SetAllDebugLogsEnabled(!0)),
        (window.DebugLogDisableAll = () => V.Get().SetAllDebugLogsEnabled(!1)),
        (window.DebugLogEnableBacktrace = () =>
          V.Get().SetIncludeBacktraceInLog(!0)),
        (window.DebugLogDisableBacktrace = () =>
          V.Get().SetIncludeBacktraceInLog(!1)),
        (window.DebugLogNames = z),
        (window.DebugLogEnabled = (...e) => {
          e.length > 0 &&
            console.warn(
              `Use DebugLogEnable( '${e.join("', '")}' ) to enable a log. This function tells you what's enabled.`,
            ),
            V.Get().PrintEnabledLogs();
        }),
        (window.EnableSteamConsole = (e = !0) =>
          V.Get().SetDebugLogEnabled("SteamClient", e)),
        (function (e) {
          (e[(e.INVALID = 0)] = "INVALID"),
            (e[(e.OK = 1)] = "OK"),
            (e[(e.CANCEL = 2)] = "CANCEL"),
            (e[(e.SECONDARY = 3)] = "SECONDARY"),
            (e[(e.OPTIONS = 4)] = "OPTIONS"),
            (e[(e.BUMPER_LEFT = 5)] = "BUMPER_LEFT"),
            (e[(e.BUMPER_RIGHT = 6)] = "BUMPER_RIGHT"),
            (e[(e.TRIGGER_LEFT = 7)] = "TRIGGER_LEFT"),
            (e[(e.TRIGGER_RIGHT = 8)] = "TRIGGER_RIGHT"),
            (e[(e.DIR_UP = 9)] = "DIR_UP"),
            (e[(e.DIR_DOWN = 10)] = "DIR_DOWN"),
            (e[(e.DIR_LEFT = 11)] = "DIR_LEFT"),
            (e[(e.DIR_RIGHT = 12)] = "DIR_RIGHT"),
            (e[(e.SELECT = 13)] = "SELECT"),
            (e[(e.START = 14)] = "START"),
            (e[(e.LSTICK_CLICK = 15)] = "LSTICK_CLICK"),
            (e[(e.RSTICK_CLICK = 16)] = "RSTICK_CLICK"),
            (e[(e.LSTICK_TOUCH = 17)] = "LSTICK_TOUCH"),
            (e[(e.RSTICK_TOUCH = 18)] = "RSTICK_TOUCH"),
            (e[(e.LPAD_TOUCH = 19)] = "LPAD_TOUCH"),
            (e[(e.LPAD_CLICK = 20)] = "LPAD_CLICK"),
            (e[(e.RPAD_TOUCH = 21)] = "RPAD_TOUCH"),
            (e[(e.RPAD_CLICK = 22)] = "RPAD_CLICK"),
            (e[(e.REAR_LEFT_UPPER = 23)] = "REAR_LEFT_UPPER"),
            (e[(e.REAR_LEFT_LOWER = 24)] = "REAR_LEFT_LOWER"),
            (e[(e.REAR_RIGHT_UPPER = 25)] = "REAR_RIGHT_UPPER"),
            (e[(e.REAR_RIGHT_LOWER = 26)] = "REAR_RIGHT_LOWER"),
            (e[(e.STEAM_GUIDE = 27)] = "STEAM_GUIDE"),
            (e[(e.STEAM_QUICK_MENU = 28)] = "STEAM_QUICK_MENU"),
            (e[(e.DUMMY_INPUT = 29)] = "DUMMY_INPUT");
        })($ || ($ = {})),
        (function (e) {
          (e[(e.UNKNOWN = 0)] = "UNKNOWN"),
            (e[(e.GAMEPAD = 1)] = "GAMEPAD"),
            (e[(e.KEYBOARD_SIMULATOR = 2)] = "KEYBOARD_SIMULATOR"),
            (e[(e.MOUSE = 3)] = "MOUSE"),
            (e[(e.TOUCH = 4)] = "TOUCH"),
            (e[(e.LPAD = 5)] = "LPAD"),
            (e[(e.RPAD = 6)] = "RPAD");
        })(q || (q = {}));
      !(function (e) {
        (e[(e.GAMEPAD = 0)] = "GAMEPAD"),
          (e[(e.KEYBOARD = 1)] = "KEYBOARD"),
          (e[(e.APPLICATION = 2)] = "APPLICATION"),
          (e[(e.BROWSER = 3)] = "BROWSER");
      })(Y || (Y = {}));
      $.OK, $.CANCEL, $.SECONDARY, $.OPTIONS, $.START;
      function X(e, t, n) {
        return (
          e.addEventListener(t, n),
          () =>
            (function (e, t, n) {
              e.removeEventListener(t, n);
            })(e, t, n)
        );
      }
      function Q(e, t) {
        return X(e, "vgp_onok", ee(t));
      }
      function J(e, t) {
        return X(e, "vgp_ondirection", ee(t));
      }
      function Z(e, t) {
        return X(e, "vgp_onblur", t);
      }
      function ee(e) {
        return (t) => {
          !1 !== e(t) && (t.stopPropagation(), t.preventDefault());
        };
      }
      const te = new G("GamepadEvents").Debug;
      function ne(e, t, n) {
        void 0 === n &&
          (n = [
            e.onButtonDown,
            e.onButtonUp,
            e.onOKButton,
            e.onCancelButton,
            e.onSecondaryButton,
            e.onOptionsButton,
            e.onMenuButton,
            e.onGamepadDirection,
            e.onGamepadFocus,
            e.onGamepadBlur,
          ]),
          c.useEffect(() => {
            let n = t.current;
            const o = [];
            return (
              n &&
                (e.onButtonDown &&
                  o.push(
                    (function (e, t) {
                      return X(e, "vgp_onbuttondown", t);
                    })(n, e.onButtonDown),
                  ),
                e.onButtonUp &&
                  o.push(
                    (function (e, t) {
                      return X(e, "vgp_onbuttonup", t);
                    })(n, e.onButtonUp),
                  ),
                e.onOKButton && o.push(Q(n, e.onOKButton)),
                e.onCancelButton &&
                  o.push(
                    (function (e, t) {
                      return X(e, "vgp_oncancel", ee(t));
                    })(n, e.onCancelButton),
                  ),
                e.onSecondaryButton &&
                  o.push(
                    (function (e, t) {
                      return X(e, "vgp_onsecondaryaction", ee(t));
                    })(n, e.onSecondaryButton),
                  ),
                e.onOptionsButton &&
                  o.push(
                    (function (e, t) {
                      return X(e, "vgp_onoptions", ee(t));
                    })(n, e.onOptionsButton),
                  ),
                e.onMenuButton &&
                  o.push(
                    (function (e, t) {
                      return X(e, "vgp_onmenu", ee(t));
                    })(n, e.onMenuButton),
                  ),
                e.onGamepadDirection && o.push(J(n, e.onGamepadDirection)),
                e.onGamepadFocus &&
                  o.push(
                    (function (e, t) {
                      return X(e, "vgp_onfocus", t);
                    })(n, e.onGamepadFocus),
                  ),
                e.onGamepadBlur && o.push(Z(n, e.onGamepadBlur))),
              () => o.forEach((e) => e())
            );
          }, n);
      }
      function oe(e) {
        return e.stopPropagation(), !1;
      }
      var ie = n(1393);
      const se = new G("FocusHistory"),
        re = se.Debug;
      class ae {
        m_root;
        constructor(e) {
          this.m_root = e;
        }
        static SerializeNavState(e, t = !0, n = !0) {
          return {
            root: ae.SerializeNavNode(e, t, n),
            bHadFocus: e.BFocusWithin(),
          };
        }
        static SerializeNavNode(e, t = !0, n = !0) {
          let o = null;
          const [i, s] = e.GetChildren();
          return (
            i.length &&
              -1 != s &&
              t &&
              (o = i.map((e, t) => ae.SerializeNavNode(e, t == s || n, n))),
            { sNavKey: e.NavKey, iActiveChild: s, rgChildren: o }
          );
        }
        static RestoreSerializedNavState(e, t, n = 0) {
          const { root: o, bHadFocus: i } = t;
          e.Tree.Controller.RestoreHistoryTransaction(() => {
            ae.RestoreSerializedNavNode(e, o),
              (1 == n || (0 == n && i)) && e.BTakeFocus(Y.APPLICATION);
          });
        }
        static RestoreSerializedNavNode(e, t, n = 0) {
          const { sNavKey: o, iActiveChild: i, rgChildren: s } = t;
          o && (0, ie.wT)(o == e.NavKey, "navkey mismatch"),
            e.SetActiveChild(i);
          const r = se.IsDebugEnabled()
            ? `[${e.Tree.id}]${(function (e) {
                if (0 == e) return "";
                let t = "";
                for (let n = 0; n < e; n++) t += "*";
                return (t += " "), t;
              })(n)}`
            : "";
          if (s && s.length) {
            const [t] = e.GetChildren();
            -1 != i &&
              re(
                `${r}Restoring node ${e.NavKey} which had active child ${i} of ${s.length} - now ${t.length} children.`,
              );
            let o = new Map();
            t.forEach((e) => {
              e.NavKey && o.set(e.NavKey, e);
            });
            for (const e of s) {
              if (!e.sNavKey) continue;
              const t = o.get(e.sNavKey);
              t && ae.RestoreSerializedNavNode(t, e, n + 1);
            }
            if (-1 != i && s[i]?.sNavKey) {
              const n = o.get(s[i].sNavKey);
              re(
                `${r}Restoring node ${e.NavKey}, child with focus: ${s[i].sNavKey} ${void 0 === n ? "MISSING!!" : ""}`,
              ),
                n && e.SetActiveChild(t.indexOf(n));
            }
            let a = 0,
              l = 0;
            for (; a < t.length && l < s.length; ) {
              for (; a < t.length && t[a].NavKey; ) a++;
              for (; l < s.length && s[l].sNavKey; ) l++;
              if (a >= t.length || l >= s.length) break;
              ae.RestoreSerializedNavNode(t[a], s[l], n + 1), a++, l++;
            }
          }
        }
      }
      class le extends ae {
        m_rgHistory = [];
        PushState() {
          this.m_rgHistory.push(ae.SerializeNavState(this.m_root));
        }
        PopState(e = 0) {
          this.m_rgHistory.length &&
            ae.RestoreSerializedNavState(
              this.m_root,
              this.m_rgHistory.pop(),
              e,
            );
        }
      }
      class ce extends ae {
        m_mapHistory = new Map();
        SaveState(e) {
          this.m_mapHistory.set(e, ae.SerializeNavState(this.m_root));
        }
        RestoreState(e, t = 0) {
          const n = this.m_mapHistory.get(e);
          return (
            !!n &&
            (console.log(`Restoring history for state ${e}`),
            ae.RestoreSerializedNavState(this.m_root, n, t),
            !0)
          );
        }
      }
      const ue = { x: "y", y: "x" };
      function de(e, t, n) {
        const o = [],
          [i, s] = e.GetChildren(),
          r = e.GetActiveChild();
        let a;
        const l = r ? r.Element?.getBoundingClientRect() : null;
        if (r) {
          const e = pe(r, t, n);
          if (
            e &&
            !e.offScreen &&
            ((a = me(r, e, e.overlap, n)), a && !a.visibility.offScreen)
          )
            return a;
          e && o.push({ child: r, visibility: e });
        }
        const c = n || l;
        for (let e = 0; e < i.length; e++) {
          const n = i[e];
          if (n == r) continue;
          const s = pe(n, t, c ?? void 0);
          s && o.push({ child: n, visibility: s });
        }
        let u;
        o.sort(he);
        for (const e of o) {
          const { child: n, visibility: o } = e;
          if (o.offScreen && u) {
            if (!u.visibility.offScreen) break;
            if (o.distance && o.distance > u.visibility.distance) break;
          }
          const i = n == r ? a : me(n, o, o.overlap || t, c ?? void 0);
          i && (!u || he(i, u) < 0) && (u = i);
        }
        return u;
      }
      function me(e, t, n, o) {
        switch (e.GetFocusable()) {
          case "none":
            return;
          case "children":
            return de(e, t.overlap || n, o);
          case "self":
            return { child: e, visibility: t };
        }
      }
      function he(e, t) {
        const n = e.visibility,
          o = t.visibility;
        return n.offScreen
          ? o.offScreen
            ? n.distance - o.distance
            : 1
          : o.offScreen
            ? -1
            : n.distance - o.distance;
      }
      function pe(e, t, n) {
        const o = e.Element?.getBoundingClientRect(),
          i = e.GetFocusable();
        let s;
        if ("none" == i || !o || !t) return null;
        if ("self" == i) {
          if (
            o.top < t.top ||
            o.right > t.right ||
            o.bottom > t.bottom ||
            o.left < t.left
          ) {
            const e = o.top + o.height / 2,
              n = o.left + o.width / 2;
            if (e < t.top) return { offScreen: "top", distance: t.top - e };
            if (n > t.right)
              return { offScreen: "right", distance: n - t.right };
            if (e > t.bottom)
              return { offScreen: "bottom", distance: e - t.bottom };
            if (n < t.left) return { offScreen: "left", distance: t.left - n };
          }
          n &&
            (s = (function (e, t) {
              let n = 0,
                o = 0;
              return (
                t.right < e.left
                  ? (n = e.left - t.right)
                  : t.left > e.right && (n = t.left - e.right),
                t.bottom < e.top
                  ? (o = e.top - t.bottom)
                  : t.top > e.bottom && (o = t.top - e.bottom),
                Math.sqrt(n * n + o * o)
              );
            })(o, n));
        } else if ("children" == i) {
          const n = e.Element;
          if (!n) return null;
          if (n.scrollHeight > o.height || n.scrollWidth > o.width) {
            const e = n.ownerDocument.defaultView.getComputedStyle(n);
            if ("visible" == e.overflowX || "visible" == e.overflowY)
              return { overlap: t };
          }
          if (o.bottom < t.top)
            return { offScreen: "top", distance: t.top - o.bottom };
          if (o.left > t.right)
            return { offScreen: "right", distance: o.left - t.right };
          if (o.top > t.bottom)
            return { offScreen: "bottom", distance: o.top - t.bottom };
          if (o.right < t.left)
            return { offScreen: "left", distance: t.left - o.right };
        }
        return {
          overlap: {
            top: Math.max(o.top, t.top),
            right: Math.min(o.right, t.right),
            bottom: Math.min(o.bottom, t.bottom),
            left: Math.max(o.left, t.left),
          },
          distance: s,
        };
      }
      var _e = n(5489);
      function ge(e) {
        return null != e && void 0 !== e.focus;
      }
      function fe(e, t) {
        let n = 0,
          o = 0;
        return (
          t.right < e.left
            ? (n = e.left - t.right)
            : t.left > e.right && (n = t.left - e.right),
          t.bottom < e.top
            ? (o = e.top - t.bottom)
            : t.top > e.bottom && (o = t.top - e.bottom),
          Math.sqrt(n * n + o * o)
        );
      }
      function be(e) {
        let t;
        return e && (t = e.ownerDocument.defaultView), t;
      }
      function Ee(e, t) {
        let n = e?.parentElement;
        for (; n; ) {
          if (ge(n)) {
            const e = window.getComputedStyle(n);
            if (
              !(
                (t && "x" != t) ||
                ("scroll" != e.overflowX &&
                  "auto" != e.overflowX &&
                  "fixed" != e.position)
              )
            )
              break;
            if (
              !(
                (t && "y" != t) ||
                ("scroll" != e.overflowY &&
                  "auto" != e.overflowY &&
                  "fixed" != e.position)
              )
            )
              break;
          }
          n = n.parentElement;
        }
        return ge(n) ? n : null;
      }
      function Se(e, t) {
        if (!("ownerDocument" in e)) return !0;
        const n = e.ownerDocument.defaultView.getComputedStyle(e),
          o = "x" === t ? n.overflowX : n.overflowY;
        return "auto" === o || "scroll" === o;
      }
      class Ce {
        m_options;
        m_msStart;
        m_msEnd;
        m_bActive = !1;
        m_fnBoundAnimationFunc = void 0;
        m_window;
        constructor(e, t) {
          (this.m_window = e), (this.m_options = { timing: "sine", ...t });
        }
        Start() {
          let e;
          switch (
            ((this.m_msStart = performance.now()),
            (this.m_msEnd = this.m_msStart + this.m_options.msDuration),
            this.m_options.timing)
          ) {
            case "linear":
              e = function (e) {
                return e;
              };
              break;
            case "cubic-in-out":
              e = function (e) {
                return e < 0.5
                  ? 4 * e * e * e
                  : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
              };
              break;
            default:
              e = function (e) {
                return 0.5 - Math.cos(e * Math.PI) / 2;
              };
          }
          (this.m_bActive = !0),
            (this.m_fnBoundAnimationFunc = this.OnInterval.bind(this, e)),
            this.m_window.requestAnimationFrame(this.m_fnBoundAnimationFunc);
        }
        BIsActive() {
          return this.m_bActive;
        }
        End() {
          if (this.m_bActive) {
            try {
              this.Update(1);
            } catch {}
            this.ClearInterval(), this.FireOnComplete();
          }
        }
        FireOnComplete() {
          this.m_options.onComplete && this.m_options.onComplete();
        }
        Cancel() {
          this.m_bActive = !1;
        }
        OnInterval(e) {
          if (!this.m_bActive) return;
          let t = performance.now() - this.m_msStart;
          if (t >= this.m_options.msDuration) return void this.End();
          let n = t / this.m_options.msDuration;
          try {
            this.Update(e(n));
          } catch {}
          this.m_window.requestAnimationFrame(this.m_fnBoundAnimationFunc);
        }
        ClearInterval() {
          this.m_bActive = !1;
        }
      }
      class ve extends Ce {
        m_fnCallback;
        constructor(e, t, n) {
          super(e, t), (this.m_fnCallback = n);
        }
        Update(e) {
          this.m_fnCallback(e);
        }
      }
      class we extends Ce {
        m_object;
        m_propTargets;
        m_props = {};
        constructor(e, t, n) {
          super("ownerDocument" in e ? be(e) : e, n),
            (this.m_object = e),
            (this.m_propTargets = t);
        }
        Start() {
          this.m_props = {};
          for (let e in this.m_propTargets) {
            let t = parseFloat(this.m_object[e]) || 0,
              n = this.m_propTargets[e];
            t != n && (this.m_props[e] = { start: t, end: n });
          }
          super.Start();
        }
        Update(e) {
          for (let t in this.m_props) {
            let n = this.m_props[t],
              o = n.start + (n.end - n.start) * e;
            this.m_object[t] = o;
          }
        }
      }
      const Me = new G("ScrollSnap").Debug;
      let ye = !1;
      let Ie;
      function Re(e) {
        if (!e) return { left: 0, top: 0, right: 0, bottom: 0 };
        if (!("ownerDocument" in e))
          return {
            left: 0,
            right: e.innerWidth,
            top: 0,
            bottom: e.innerHeight,
          };
        let t = 0,
          n = 0,
          o = e;
        for (; o; ) {
          if (((t += o.offsetTop), (n += o.offsetLeft), "ownerDocument" in o)) {
            if ("fixed" === window.getComputedStyle(o).position) break;
          }
          o = o.offsetParent;
        }
        for (o = e?.parentElement; o; ) {
          const { scrollTop: e, scrollLeft: i } = xe(o);
          if (((t -= e), (n -= i), "ownerDocument" in o)) {
            if ("fixed" === window.getComputedStyle(o).position) break;
          }
          o = o.parentElement;
        }
        return {
          left: n,
          top: t,
          right: n + e.offsetWidth,
          bottom: t + e.offsetHeight,
        };
      }
      function ke(e, t) {
        return "x" == t
          ? [e.left, e.right, e.right - e.left]
          : [e.top, e.bottom, e.bottom - e.top];
      }
      function Te(e, t, n, o) {
        let [i, s, r] = ke(e, o),
          [a, l, c] = ke(t, o),
          [u, d] = ke(n, o);
        if (i < a && s > l) return 0;
        const m = i - u,
          h = s + d,
          p = r > c;
        return (m < a && !p) || (h > l && p)
          ? m - a
          : (m < a && p) || (h > l && !p)
            ? h - l
            : 0;
      }
      function Oe(e) {
        return "auto" == e
          ? 0
          : e.endsWith("px")
            ? parseInt(e)
            : (console.log("Unsupported length", e), 0);
      }
      function Ae(e) {
        if (!("ownerDocument" in e))
          return { left: 0, right: 0, top: 0, bottom: 0 };
        const t = e.ownerDocument.defaultView.getComputedStyle(e);
        return {
          left: Oe(t.scrollMarginLeft),
          right: Oe(t.scrollMarginRight),
          top: Oe(t.scrollMarginTop),
          bottom: Oe(t.scrollMarginBottom),
        };
      }
      function De(e, t) {
        let n = (function (e) {
          let t;
          return (
            (t =
              "ownerDocument" in e
                ? e.ownerDocument.defaultView.getComputedStyle(e)
                : e.document.defaultView.getComputedStyle(
                    window.document.documentElement,
                  )),
            {
              left: Oe(t.scrollPaddingLeft),
              right: Oe(t.scrollPaddingRight),
              top: Oe(t.scrollPaddingTop),
              bottom: Oe(t.scrollPaddingBottom),
            }
          );
        })(e);
        return {
          left: Math.max(0, t.left + n.left),
          right: Math.max(0, t.right - n.right),
          top: Math.max(0, t.top + n.top),
          bottom: Math.max(0, t.bottom - n.bottom),
        };
      }
      function Fe(e) {
        return e > -1 && e < 1;
      }
      function Pe(e, t, n, o, i) {
        Me(
          "----------------------------------------------------------------------------------",
        ),
          Me("Scrolling Into View:", t);
        let s = [],
          r = t,
          a = Re(t),
          l = i ?? Number.MAX_VALUE;
        for (; r; ) {
          let e = Ee(r);
          e || (e = be(r));
          let t = Ae(r),
            n = De(e, Re(e)),
            c = Be(e),
            u = { element: e, left: 0, top: 0 };
          if (
            (Me(
              "Checking scroll div",
              e,
              `scroll y:${c.scrollTop} of ${c.MaxScrollTop()}, x:${c.scrollLeft} of ${c.MaxScrollLeft()}, adjusted =>`,
              n,
              "target => ",
              a,
            ),
            (o && "y" != o) ||
              !Se(e, "y") ||
              ((u.top = Te(a, n, t, "y")),
              (u.top = _e.OQ(
                u.top,
                -c.scrollTop,
                c.MaxScrollTop() - c.scrollTop,
              )),
              i &&
                ((u.top = Math.min(l, Math.abs(u.top)) * (u.top < 0 ? -1 : 1)),
                (l -= Math.abs(u.top))),
              Me(`- checked y: ${u.top}`)),
            (o && "x" != o) ||
              !Se(e, "x") ||
              ((u.left = Te(a, n, t, "x")),
              (u.left = _e.OQ(
                u.left,
                -c.scrollLeft,
                c.MaxScrollLeft() - c.scrollLeft,
              )),
              i &&
                ((u.left =
                  Math.min(l, Math.abs(u.left)) * (u.left < 0 ? -1 : 1)),
                (l -= Math.abs(u.left))),
              Me(`- checked x: ${u.left}`)),
            s.push(u),
            i && !l)
          )
            break;
          if (!("ownerDocument" in e)) break;
          const d = window.getComputedStyle(e);
          if ("fixed" === d.position || "sticky" === d.position) break;
          (r = e),
            (a = {
              top: a.top - u.top,
              right: a.right - u.left,
              bottom: a.bottom - u.top,
              left: a.left - u.left,
            });
        }
        let c = !1;
        for (let e of s) {
          if (Fe(e.left) && Fe(e.top)) continue;
          let t = Be(e.element),
            o = t.scrollTop + e.top,
            i = t.scrollLeft + e.left;
          (i = _e.OQ(i, 0, t.MaxScrollLeft())),
            (o = _e.OQ(o, 0, t.MaxScrollTop())),
            (Fe(t.scrollLeft - i) && Fe(t.scrollTop - o)) ||
              (t.scrollTo({ left: i, top: o, behavior: n }),
              c || (Me("Scrolling:"), (c = !0)),
              Me(
                `- ${e.top},${e.left} => ${o}, ${i}, behavior: ${n}`,
                e.element,
              ));
        }
      }
      class Le {
        m_element;
        m_fnOriginalScrollTo;
        m_window;
        m_scrollTopTarget = void 0;
        m_scrollLeftTarget = void 0;
        m_animation = void 0;
        constructor(e) {
          "ownerDocument" in e
            ? ((this.m_element = e),
              (this.m_fnOriginalScrollTo = e.scrollTo),
              (this.m_element.scrollTo = (e, t) => {
                "number" == typeof e
                  ? this.scrollTo({ left: e, top: t })
                  : this.scrollTo(e);
              }))
            : ((this.m_window = e),
              (this.m_element = e.document.documentElement));
        }
        ResetScrollState() {
          (this.m_scrollTopTarget = void 0),
            (this.m_scrollLeftTarget = void 0),
            this.m_window || (this.m_element.style.scrollSnapType = "");
        }
        scrollTo(e) {
          if ("smooth" != e?.behavior)
            this.m_animation &&
              (this.m_animation.Cancel(), (this.m_animation = void 0)),
              this.m_window
                ? this.m_window.scrollTo(e)
                : this.m_fnOriginalScrollTo?.apply(this.m_element, [e]),
              this.ResetScrollState();
          else {
            const t = e.left ?? this.scrollLeft,
              n = e.top ?? this.scrollTop;
            let o = "sine";
            this.m_animation && (this.m_animation.Cancel(), (o = "linear"));
            if (
              Math.max(
                Math.abs(this.currentScrollTop - n),
                Math.abs(this.currentScrollLeft - t),
              ) > 0
            ) {
              const e = {
                msDuration: 200,
                timing: o,
                onComplete: this.ResetScrollState,
              };
              if (this.m_window) {
                const o = this.currentScrollLeft,
                  i = this.currentScrollTop;
                this.m_animation = new ve(this.m_window, e, (e) => {
                  this.m_window?.scrollTo({
                    left: o + (t - o) * e,
                    top: i + (n - i) * e,
                    behavior: "auto",
                  });
                });
              } else
                (this.m_element.style.scrollSnapType = "initial"),
                  (this.m_animation = new we(
                    this.m_element,
                    { scrollTop: n, scrollLeft: t },
                    e,
                  ));
              (this.m_scrollLeftTarget = t),
                (this.m_scrollTopTarget = n),
                this.m_animation.Start();
            }
          }
        }
        get clientWidth() {
          return this.m_window
            ? this.m_window.innerWidth
            : this.m_element.clientWidth;
        }
        get clientHeight() {
          return this.m_window
            ? this.m_window.innerHeight
            : this.m_element.clientHeight;
        }
        get currentScrollLeft() {
          return this.m_window
            ? this.m_window.scrollX
            : this.m_element.scrollLeft;
        }
        get currentScrollTop() {
          return this.m_window
            ? this.m_window.scrollY
            : this.m_element.scrollTop;
        }
        get scrollLeft() {
          return this.m_scrollLeftTarget ?? this.currentScrollLeft;
        }
        get scrollTop() {
          return this.m_scrollTopTarget ?? this.currentScrollTop;
        }
        get scrollWidth() {
          return this.m_element.scrollWidth;
        }
        get scrollHeight() {
          return this.m_element.scrollHeight;
        }
        MaxScrollTop() {
          return this.scrollHeight - this.clientHeight;
        }
        MaxScrollLeft() {
          return this.scrollWidth - this.clientWidth;
        }
      }
      (0, i.Cg)([B.o], Le.prototype, "ResetScrollState", null);
      const Ne = new WeakMap();
      function Be(e) {
        let t = Ne.get(e);
        return t || ((t = new Le(e)), Ne.set(e, t)), t;
      }
      function xe(e) {
        const t = Ne.get(e);
        return t
          ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
          : { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop };
      }
      const We = new G("FocusNavigationMovement"),
        He = We.Debug;
      var Ue, Ge, Ve, Ke;
      !(function (e) {
        (e[(e.NONE = 0)] = "NONE"),
          (e[(e.COLUMN = 1)] = "COLUMN"),
          (e[(e.ROW = 2)] = "ROW"),
          (e[(e.COLUMN_REVERSE = 3)] = "COLUMN_REVERSE"),
          (e[(e.ROW_REVERSE = 4)] = "ROW_REVERSE"),
          (e[(e.GRID = 5)] = "GRID"),
          (e[(e.GEOMETRIC = 6)] = "GEOMETRIC");
      })(Ue || (Ue = {})),
        (function (e) {
          (e[(e.FIRST = 0)] = "FIRST"),
            (e[(e.LAST = 1)] = "LAST"),
            (e[(e.MAINTAIN_X = 2)] = "MAINTAIN_X"),
            (e[(e.MAINTAIN_Y = 3)] = "MAINTAIN_Y"),
            (e[(e.PREFERRED_CHILD = 4)] = "PREFERRED_CHILD");
        })(Ge || (Ge = {})),
        (function (e) {
          (e[(e.Standard = 0)] = "Standard"),
            (e[(e.NoTransform = 1)] = "NoTransform"),
            (e[(e.NoTransformSparseContent = 2)] = "NoTransformSparseContent");
        })(Ve || (Ve = {})),
        (function (e) {
          (e[(e.INVALID = 0)] = "INVALID"),
            (e[(e.FORWARD = 1)] = "FORWARD"),
            (e[(e.BACKWARD = 2)] = "BACKWARD");
        })(Ke || (Ke = {}));
      class ze {
        m_Tree;
        m_Parent;
        m_rgChildren = [];
        m_ActiveChild;
        m_iLastActiveChildIndex = -1;
        m_Properties;
        m_element;
        m_FocusRing;
        m_bChildrenSorted = !1;
        m_bAutoFocusChild = !1;
        m_bMounted = !1;
        m_nDepth;
        m_Focused = (0, F.Jc)(!1);
        m_FocusWithin = (0, F.Jc)(!1);
        m_ActionDescriptionsChangedCallbackList = new U.l();
        m_FocusableIfEmptyAncestor = null;
        m_rgNavigationHandlers = [];
        m_rgFocusHandlers = [];
        constructor(e, t, n) {
          (this.m_Tree = e),
            (this.m_Parent = t),
            (this.m_FocusRing = n),
            (this.m_nDepth = t ? t.m_nDepth + 1 : 0);
        }
        CreateHandle() {
          return new je(this);
        }
        get Tree() {
          return this.m_Tree;
        }
        get NavKey() {
          return this.m_Properties?.navKey ? this.m_Properties.navKey : void 0;
        }
        get Element() {
          return this.m_element;
        }
        get Parent() {
          return this.m_Parent;
        }
        SetProperties(e) {
          const t =
            ((n = this.m_Properties?.actionDescriptionMap),
            (o = e?.actionDescriptionMap),
            !(null == n || null == o
              ? n === o
              : "object" == typeof n &&
                "object" == typeof o &&
                Object.keys(n).length === Object.keys(o).length &&
                Object.keys(n).every(
                  (e) => o.hasOwnProperty(e) && n[e] === o[e],
                )));
          var n, o;
          const i = this.m_Properties?.focusableIfEmpty,
            s = this.m_Properties?.noFocusRing;
          (this.m_Properties = e || {}),
            t && this.m_ActionDescriptionsChangedCallbackList.Dispatch(),
            this.m_Properties.focusableIfEmpty && !i
              ? this.PropagateFocusableIfEmptyAncestorToDescendants(this)
              : !this.m_Properties.focusableIfEmpty &&
                i &&
                this.PropagateFocusableIfEmptyAncestorToDescendants(
                  this.m_FocusableIfEmptyAncestor,
                ),
            this.m_Properties.noFocusRing && !s && this.BHasFocus()
              ? this.m_FocusRing?.OnBlur(Y.APPLICATION, this, this)
              : !this.m_Properties.noFocusRing &&
                s &&
                this.BHasFocus() &&
                this.m_FocusRing?.OnFocus(Y.APPLICATION, this, this),
            this.m_element && this.RegisterDOMEvents();
        }
        BWantsAutoFocus() {
          return this.m_Properties?.autoFocus || this.m_bAutoFocusChild;
        }
        BWantsPreferredFocus() {
          return this.m_Properties?.preferredFocus;
        }
        BWantsFocusRing() {
          return (
            !this.m_Properties?.noFocusRing ||
            this.m_Tree.Controller.GetShowDebugFocusRing().Value
          );
        }
        GetBoundingRect() {
          return this.m_element?.getBoundingClientRect();
        }
        SetHasFocus(e) {
          this.m_Focused.Set(e);
        }
        SetFocusWithin(e) {
          this.m_FocusWithin.Set(e) &&
            this.m_Properties?.onFocusWithin &&
            this.m_Properties.onFocusWithin(e);
        }
        get SubscribableHasFocus() {
          return this.m_Focused;
        }
        BHasFocus() {
          return this.m_Focused.Value;
        }
        get SubscribableFocusWithin() {
          return this.m_FocusWithin;
        }
        BFocusWithin() {
          return this.m_FocusWithin.Value;
        }
        ForceMeasureFocusRing() {
          this.m_FocusRing?.OnForceMeasureFocusRing();
        }
        get ActionDescriptionChangedCallbackList() {
          return this.m_ActionDescriptionsChangedCallbackList;
        }
        GetActiveActionDescriptions() {
          return this.BuildConsolidatedActionDescriptionMap({});
        }
        BuildConsolidatedActionDescriptionMap(e) {
          const t = this.m_Properties?.actionDescriptionMap;
          if (t)
            for (const n in t) {
              const o = n;
              void 0 === e[o] && (e[o] = t[o]);
            }
          return this.m_Parent
            ? this.m_Parent.BuildConsolidatedActionDescriptionMap(e)
            : e;
        }
        AddChild(e) {
          this.m_rgChildren.push(e),
            (this.m_bChildrenSorted = !1),
            this.m_element && this.RegisterDOMEvents(),
            this.m_Properties?.focusableIfEmpty
              ? e.SetFocusableIfEmptyAncestor(this)
              : this.m_FocusableIfEmptyAncestor &&
                e.SetFocusableIfEmptyAncestor(this.m_FocusableIfEmptyAncestor),
            this.m_bMounted &&
              e.BFocusWithin() &&
              ((0, ie.wT)(
                !this.m_ActiveChild && this.BFocusWithin(),
                "Invalid focus state in AddChild",
              ),
              this.SetActiveChild(this.m_rgChildren.length - 1));
        }
        OnMount(e) {
          (this.m_element = e),
            this.m_Parent
              ? this.m_Parent.AddChild(this)
              : (0, ie.wT)(
                  this == this.m_Tree.Root,
                  "Only root should have no parent",
                ),
            (this.m_bMounted = !0),
            this.RegisterDOMEvents();
          const t =
              this.m_FocusableIfEmptyAncestor &&
              this.m_FocusableIfEmptyAncestor.BHasFocus(),
            n = this.m_Properties?.autoFocus || t;
          if (this.BWantsAutoFocus() || n) {
            let e = -1;
            this.m_rgChildren.length &&
              (this.EnsureChildrenSorted(),
              (e = this.m_rgChildren.findIndex((e) => e.BWantsAutoFocus()))),
              (this.m_Properties?.autoFocus || n || -1 !== e) &&
                (this.SetActiveChild(e),
                !this.m_Parent || this.m_Parent.m_element
                  ? t
                    ? this.m_Tree.DeferredFocus.BHasQueuedFocusNode() ||
                      this.m_Tree.DeferredFocus.RequestFocus(
                        this.m_FocusableIfEmptyAncestor,
                        { bFocusDescendant: !0 },
                      )
                    : this.Tree.DeferredFocus.RequestFocus(this)
                  : (this.m_Parent.m_bAutoFocusChild = !0));
          } else if (this.m_rgChildren.length) {
            const e = this.m_rgChildren.findIndex((e) => e.BFocusWithin());
            -1 != e &&
              (this.SetActiveChild(e),
              (0, ie.wT)(
                this.BFocusWithin(),
                "Child has focus, we should be m_bFocusWithin",
              ));
          }
        }
        DEV_SetDebugPropsOnElement() {}
        OnUnmount() {
          this.m_Properties?.focusableIfEmpty &&
            this.PropagateFocusableIfEmptyAncestorToDescendants(
              this.m_FocusableIfEmptyAncestor,
            ),
            (this.m_bMounted = !1);
          const e = this.Tree.DeferredFocus.BIsQueuedFocusNode(this);
          (this.BHasFocus() || e) &&
            (He(
              `The focused node is unmounting, ${this.m_FocusableIfEmptyAncestor ? "will transfer to retain focus ancestor" : "will blur"}.`,
            ),
            e && this.Tree.DeferredFocus.RequestFocus(null),
            this.m_FocusableIfEmptyAncestor
              ? this.m_FocusableIfEmptyAncestor.OnFocusedDecendantRemoved(this)
              : this.BHasFocus() &&
                this.m_Tree.TransferFocus(Y.APPLICATION, null)),
            this.UnregisterDOMEvents(),
            this.m_Parent
              ? this.m_Parent.RemoveChild(this)
              : (0, ie.wT)(
                  this == this.m_Tree.Root,
                  "Only root should have no parent",
                );
        }
        RegisterDOMEvents() {
          !this.m_rgNavigationHandlers.length &&
            this.m_element &&
            (this.m_rgChildren.length >= 2 ||
              this.m_Properties?.layout != Ue.NONE ||
              this.m_Properties.onMoveUp ||
              this.m_Properties.onMoveRight ||
              this.m_Properties.onMoveDown ||
              this.m_Properties.onMoveLeft) &&
            this.m_rgNavigationHandlers.push(
              J(this.m_element, this.OnNavigationEvent),
            ),
            (this.m_Properties?.focusable ||
              this.m_Properties?.focusableIfEmpty ||
              0 == this.m_rgChildren.length) &&
              (this.m_rgFocusHandlers.length ||
                (this.m_element?.addEventListener("focus", this.OnDOMFocus),
                this.m_element?.addEventListener("blur", this.OnDOMBlur),
                this.m_rgFocusHandlers.push(() => {
                  this.m_element?.removeEventListener("focus", this.OnDOMFocus),
                    this.m_element?.removeEventListener("blur", this.OnDOMBlur);
                })));
        }
        RemoveChild(e) {
          let t = this.m_rgChildren.indexOf(e);
          (0, ie.wT)(-1 !== t, "Child was not found to remove"),
            -1 !== t &&
              (this.m_ActiveChild == e && (this.m_ActiveChild = void 0),
              this.m_rgChildren.splice(t, 1));
        }
        UnregisterDOMEvents() {
          this.m_rgNavigationHandlers.forEach((e) => e()),
            (this.m_rgNavigationHandlers = []),
            this.m_rgFocusHandlers.forEach((e) => e()),
            (this.m_rgFocusHandlers = []);
        }
        GetActiveDescendant() {
          const e = this.GetActiveChild();
          return e ? e.GetActiveDescendant() : this;
        }
        IsValidChildIndex(e) {
          return e >= 0 && e < this.m_rgChildren.length;
        }
        GetActiveChild() {
          return this.m_ActiveChild
            ? this.m_ActiveChild
            : (this.EnsureChildrenSorted(),
              this.IsValidChildIndex(this.m_iLastActiveChildIndex)
                ? this.m_rgChildren[this.m_iLastActiveChildIndex]
                : null);
        }
        GetActiveChildIndex() {
          if (this.m_ActiveChild) {
            if (
              this.IsValidChildIndex(this.m_iLastActiveChildIndex) &&
              this.m_rgChildren[this.m_iLastActiveChildIndex] ==
                this.m_ActiveChild
            )
              return this.m_iLastActiveChildIndex;
            this.m_iLastActiveChildIndex = this.m_rgChildren.indexOf(
              this.m_ActiveChild,
            );
          }
          return this.m_iLastActiveChildIndex;
        }
        EnsureChildrenSorted(e = !1) {
          (this.m_bChildrenSorted && !e) ||
            (this.m_rgChildren.sort((e, t) => {
              const n = e.m_element,
                o = t.m_element;
              if (!n) return o ? 1 : 0;
              if (!o) return -1;
              const i = n.compareDocumentPosition(o);
              return i & Node.DOCUMENT_POSITION_PRECEDING
                ? 1
                : i & Node.DOCUMENT_POSITION_FOLLOWING
                  ? -1
                  : 0;
            }),
            this.m_ActiveChild &&
              (this.m_iLastActiveChildIndex = this.m_rgChildren.indexOf(
                this.m_ActiveChild,
              )),
            (this.m_bChildrenSorted = !0));
        }
        GetLastFocusElement() {
          const e = this.GetActiveChild();
          return e ? e.GetLastFocusElement() : this.m_element;
        }
        OnDOMFocus(e) {
          if (!this.BHasFocus()) {
            if ("children" == this.GetFocusable()) {
              const e = this.FindFocusableDescendant();
              if (e && e !== this)
                return (
                  He(
                    "Browser gave node focus but we are marked focusableIfEmpty, transfering focus to descendant.",
                    this.m_element,
                    e.m_element,
                  ),
                  void this.m_Tree.TransferFocus(Y.BROWSER, e)
                );
            }
            this.m_Tree.TransferFocus(Y.BROWSER, this);
          }
        }
        OnDOMBlur(e) {
          this.BHasFocus() &&
            this.m_element?.ownerDocument.hasFocus() &&
            this.m_Tree.TransferFocus(Y.BROWSER, null);
        }
        UpdateParentActiveChild() {
          this.m_Parent &&
            (this.m_Parent.SetActiveChild(this),
            this.m_Parent.UpdateParentActiveChild());
        }
        GetFocusable() {
          const {
            focusable: e,
            focusableIfEmpty: t,
            childFocusDisabled: n,
            fnCanTakeFocus: o,
          } = this.m_Properties;
          return this.m_bMounted
            ? o && !o(this)
              ? "none"
              : e || (t && (n || 0 == this.m_rgChildren.length))
                ? "self"
                : !n && this.m_rgChildren.length
                  ? "children"
                  : "none"
            : "none";
        }
        BTakeFocus(e, t) {
          const n = this.FindFocusableNode(t);
          return this.InternalFocusDescendant(n, e, t);
        }
        FindFocusableNode(e, t) {
          switch (this.GetFocusable()) {
            case "none":
              return null;
            case "self":
              return this;
            case "children":
              return this.FindFocusableDescendant(e, t);
          }
        }
        BChildTakeFocus(e, t) {
          const n = this.FindFocusableDescendant(t);
          return this.InternalFocusDescendant(n, e, t);
        }
        BFocusFirstChild(e) {
          const t = this.FindNextFocusableChildInDirection(
            -1,
            Ke.FORWARD,
            $.INVALID,
          );
          return this.InternalFocusDescendant(t, e);
        }
        BFocusLastChild(e) {
          const t = this.FindNextFocusableChildInDirection(
            this.m_rgChildren.length,
            Ke.BACKWARD,
            $.INVALID,
          );
          return this.InternalFocusDescendant(t, e);
        }
        FindFocusableDescendant(e, t) {
          const n = Qe(e),
            { focusableIfEmpty: o, childFocusDisabled: i } =
              this.m_Properties ?? {};
          if (i) return null;
          if (this.m_rgChildren.length) {
            this.EnsureChildrenSorted();
            const { navEntryPreferPosition: i, resetNavOnEntry: s } =
              this.m_Properties ?? {};
            let r = this.GetActiveChildIndex();
            s && void 0 !== e && (r = -1);
            const a = this.GetLayout();
            let l, c;
            if (
              (this.IsValidChildIndex(r) ||
                (r =
                  r >= this.m_rgChildren.length ||
                  a == Ue.ROW_REVERSE ||
                  a == Ue.COLUMN_REVERSE ||
                  i == Ge.LAST
                    ? this.m_rgChildren.length - 1
                    : 0),
              i == Ge.MAINTAIN_X
                ? (c = "x")
                : i == Ge.MAINTAIN_Y
                  ? (c = "y")
                  : a == Ue.GEOMETRIC && n && (c = ue[n]),
              (c || t) && n)
            ) {
              const o = this.m_Tree.GetLastFocusedNode();
              if (t || (o && c == ue[n])) {
                const s =
                  t ||
                  this.AdjustRectForLastMovementOnTangentAxis(
                    o.GetBoundingRect(),
                    n,
                  );
                He(
                  `Taking focus while preserving ${i && Ge[i]} preserved: ${c} movement: ${n}, node:`,
                  s,
                ),
                  (l = this.FindClosestFocusableNodeToRect(e, s));
              } else if (c != ue[n]) {
                const t = this.ComputeRelativeDirection(e, Ue.GRID),
                  n = t == Ke.BACKWARD ? this.m_rgChildren.length : -1;
                l = this.FindNextFocusableChildInDirection(n, t, e);
              }
            } else if (i == Ge.PREFERRED_CHILD) {
              for (const t of this.m_rgChildren)
                if (
                  ((l = t.BWantsPreferredFocus()
                    ? t.FindFocusableNode(e)
                    : void 0),
                  l)
                )
                  return l;
            } else
              i == Ge.LAST &&
                (l = this.FindNextFocusableChildInDirection(
                  r + 1,
                  Ke.BACKWARD,
                  e,
                ));
            return (
              l ||
                (l = this.FindNextFocusableChildInDirection(
                  r - 1,
                  Ke.FORWARD,
                  e,
                )),
              l ||
                (l = this.FindNextFocusableChildInDirection(r, Ke.BACKWARD, e)),
              l || (o ? this : null)
            );
          }
          return null;
        }
        BVisibleChildTakeFocus(e) {
          const t = this.Element?.ownerDocument?.defaultView ?? window,
            n = de(this, {
              top: 0,
              left: 0,
              right: t.innerWidth,
              bottom: t.innerHeight,
            });
          return (
            He(
              `Focusing visible child, best child match is ${n?.child?.Element?.className} - ${JSON.stringify(n?.visibility)}`,
            ),
            !!n && n.child.BTakeFocus(e)
          );
        }
        GetLayout() {
          if (this.m_Properties?.layout) return this.m_Properties.layout;
          if (this.m_rgChildren.length < 2) return Ue.NONE;
          return (function (e) {
            if (!e) return Ue.NONE;
            const t = e.ownerDocument.defaultView,
              n = t.getComputedStyle(e);
            if ("flex" == n.display)
              switch (n.flexDirection) {
                case "row":
                  return "wrap" == n.flexWrap ? Ue.GRID : Ue.ROW;
                case "row-reverse":
                  return Ue.ROW_REVERSE;
                case "column":
                  return Ue.COLUMN;
                case "column-reverse":
                  return Ue.COLUMN_REVERSE;
              }
            else {
              if ("grid" == n.display)
                return "none" !== n.gridTemplateAreas ? Ue.GEOMETRIC : Ue.GRID;
              if (e.childElementCount > 0) {
                const n = t.getComputedStyle(e.firstElementChild);
                if ("left" === n.float) return Ue.ROW;
                if ("right" === n.float) return Ue.ROW_REVERSE;
                if ("inline" === n.display || "inline-block" === n.display)
                  return Ue.GRID;
              }
            }
            return Ue.COLUMN;
          })(this.m_element);
        }
        OnNavigationEvent(e) {
          const t = e.detail.button;
          if (this.BTryInternalNavigation(t, e.detail.is_repeat ?? !1))
            return !0;
          const {
            onMoveUp: n,
            onMoveRight: o,
            onMoveDown: i,
            onMoveLeft: s,
          } = this.m_Properties ?? {};
          let r = !1;
          switch (t) {
            case $.DIR_UP:
              n && (r = n(e.detail, this));
              break;
            case $.DIR_RIGHT:
              o && (r = o(e.detail, this));
              break;
            case $.DIR_DOWN:
              i && (r = i(e.detail, this));
              break;
            case $.DIR_LEFT:
              s && (r = s(e.detail, this));
          }
          return r;
        }
        InternalFocusDescendant(e, t, n) {
          return !!e && (this.m_Tree.TransferFocus(t, e, Qe(n)), !0);
        }
        BTryInternalNavigation(e, t) {
          const n = this.GetLayout();
          let o,
            i = this.ComputeRelativeDirection(e, n);
          if (
            (He(
              `Handling navigation event ${$[e]} - ${Ue[n]} - ${Ke[i]}`,
              this.m_element,
            ),
            i == Ke.INVALID)
          )
            return !1;
          if (this.m_Properties?.focusable && this.BHasFocus())
            return He("Skipping navigation within focused element"), !1;
          if ((this.EnsureChildrenSorted(!0), n == Ue.GRID))
            o = this.FindNextFocusableChildInGrid(
              this.GetActiveChildIndex(),
              i,
              e,
            );
          else if (n == Ue.GEOMETRIC)
            o = this.FindNextFocusableChildGeometric(i, e);
          else {
            let t = this.GetActiveChildIndex();
            this.IsValidChildIndex(t) ||
              (t = i == Ke.FORWARD ? -1 : this.m_rgChildren.length),
              (o = this.FindNextFocusableChildInDirection(t, i, e));
          }
          if (o) {
            const n = Qe(e);
            if (this.GetScrollIntoViewType() == Ve.NoTransformSparseContent) {
              const e = o.Element?.ownerDocument.defaultView;
              if (e) {
                const s =
                    ("y" == n ? e.innerHeight : e.innerWidth) /
                    (t ? 4.5 : 3.33),
                  r = Re(o.Element);
                let a = !1;
                if (
                  ("y" == n
                    ? i == Ke.FORWARD
                      ? (a =
                          r.top > e.innerHeight && r.bottom > e.innerHeight + s)
                      : i == Ke.BACKWARD && (a = r.bottom < 0 && r.top < -s)
                    : "x" == n &&
                      (i == Ke.FORWARD
                        ? (a =
                            r.left > e.innerWidth && r.right > e.innerWidth + s)
                        : i == Ke.BACKWARD && (a = r.right < 0 && r.left < -s)),
                  a)
                )
                  return (
                    He(`Element too far away, scrolling ${s} on ${n} axis `),
                    Pe(o.Element, o.Element, "smooth", n, s),
                    !0
                  );
              }
            }
            return this.m_Tree.TransferFocus(Y.GAMEPAD, o, n), !0;
          }
          return !1;
        }
        GetScrollIntoViewType() {
          return this.m_Properties?.scrollIntoViewType
            ? this.m_Properties.scrollIntoViewType
            : this.m_Parent
              ? this.m_Parent.GetScrollIntoViewType()
              : Ve.Standard;
        }
        GetRelativeDirection(e) {
          return this.ComputeRelativeDirection(e, this.GetLayout());
        }
        ComputeRelativeDirection(e, t) {
          let n = t == Ue.ROW_REVERSE || t == Ue.COLUMN_REVERSE;
          switch (t) {
            case Ue.ROW:
            case Ue.ROW_REVERSE:
              switch (e) {
                case $.DIR_LEFT:
                  return n ? Ke.FORWARD : Ke.BACKWARD;
                case $.DIR_RIGHT:
                  return n ? Ke.BACKWARD : Ke.FORWARD;
                default:
                  return Ke.INVALID;
              }
            case Ue.COLUMN:
            case Ue.COLUMN_REVERSE:
              switch (e) {
                case $.DIR_UP:
                  return n ? Ke.FORWARD : Ke.BACKWARD;
                case $.DIR_DOWN:
                  return n ? Ke.BACKWARD : Ke.FORWARD;
                default:
                  return Ke.INVALID;
              }
            case Ue.GRID:
            case Ue.GEOMETRIC:
              switch (e) {
                case $.DIR_LEFT:
                case $.DIR_UP:
                  return n ? Ke.FORWARD : Ke.BACKWARD;
                case $.DIR_RIGHT:
                case $.DIR_DOWN:
                  return n ? Ke.BACKWARD : Ke.FORWARD;
                default:
                  return Ke.INVALID;
              }
            default:
              return Ke.INVALID;
          }
        }
        AdvanceIndex(e, t) {
          return e + (t == Ke.FORWARD ? 1 : -1);
        }
        FindNextFocusableChildInDirection(e, t, n) {
          let o = t == Ke.FORWARD ? 1 : -1;
          for (let t = e + o; t >= 0 && t < this.m_rgChildren.length; t += o) {
            const e = this.m_rgChildren[t].FindFocusableNode(n);
            if (e) return e;
          }
          return null;
        }
        ScanChildren(e, t, n) {
          let o = t == Ke.FORWARD ? 1 : -1;
          for (let t = e; t >= 0 && t < this.m_rgChildren.length; t += o)
            if (n(this.m_rgChildren[t], t)) return t;
          return -1;
        }
        FindNextFocusableChildInGrid(e, t, n) {
          const o = n == $.DIR_UP || n == $.DIR_DOWN,
            i = this.GetLastFocusElement();
          if (!i || i == this.m_element)
            return (
              (0, ie.wT)(
                !1,
                "No active child for grid navigation",
                this.m_iLastActiveChildIndex,
                this.m_rgChildren.length,
                i,
              ),
              this.FindFocusableDescendant(n)
            );
          let s = this.GetActiveDescendant().GetBoundingRect();
          if (
            ((n != $.DIR_UP && n != $.DIR_DOWN) ||
              (s = this.AdjustRectForLastMovementOnTangentAxis(s, "y")),
            o)
          ) {
            let o = e;
            for (; -1 != o; ) {
              const e = this.ScanChildren(
                this.AdvanceIndex(o, t),
                t,
                (e) => !$e("y", s, e.GetBoundingRect()),
              );
              if (-1 != e) {
                const o = this.m_rgChildren[e].GetBoundingRect(),
                  i = this.FindClosestChildInNextAxiallyAlignedSet(
                    "x",
                    t,
                    n,
                    s,
                    e,
                    o,
                  );
                if (i) return i;
              }
              o = e;
            }
          } else {
            let o = t == Ke.FORWARD ? 1 : -1;
            for (
              let i = this.AdvanceIndex(e, t);
              i >= 0 && i < this.m_rgChildren.length;
              i += o
            ) {
              const e = this.m_rgChildren[i];
              if (!$e("y", s, e.GetBoundingRect())) return null;
              let t = e.FindFocusableNode(n);
              if (t) return t;
            }
          }
          return null;
        }
        FindNextFocusableChildGeometric(e, t) {
          const n = this.GetLastFocusElement();
          if (!n || n == this.m_element)
            return (
              (0, ie.wT)(
                !1,
                "No active child for geometric navigation",
                this.m_iLastActiveChildIndex,
                this.m_rgChildren.length,
                n,
              ),
              this.FindFocusableDescendant(t)
            );
          const o = Qe(t);
          if (!o) return null;
          const i = this.AdjustRectForLastMovementOnTangentAxis(
            this.GetActiveDescendant().GetBoundingRect(),
            o,
          );
          return this.FindClosetChildInDirection(o, i, e, t);
        }
        AdjustRectForLastMovementOnTangentAxis(e, t) {
          const n = this.m_Tree.GetLastFocusedMovementRect(ue[t]);
          return n
            ? "x" == t
              ? { left: e.left, right: e.right, top: n.top, bottom: n.bottom }
              : { left: n.left, right: n.right, top: e.top, bottom: e.bottom }
            : e;
        }
        FindClosestFocusableNodeToRect(e, t) {
          const n = Qe(e),
            o = n && ue[n],
            i = [];
          for (const e of this.m_rgChildren) {
            const n = e.GetBoundingRect();
            if (n) {
              const s = fe(t, n),
                r = o ? qe(o, t, n) : 0;
              i.push({ child: e, overlap: r, dist: s });
            }
          }
          i.sort((e, t) =>
            e.dist != t.dist ? e.dist - t.dist : t.overlap - e.overlap,
          );
          for (const { child: n } of i) {
            const o = n.FindFocusableNode(e, t);
            if (o) return o;
          }
          return null;
        }
        FindClosetChildInDirection(e, t, n, o) {
          He(
            `Find child closest to rect, rect is at left ${t.left} top ${t.top} right ${t.right} bottom ${t.bottom}`,
          );
          const i = Ye(e, t),
            s = [];
          for (const o of this.m_rgChildren) {
            const r = o.GetBoundingRect();
            if (r) {
              const a = Ye(e, r);
              let l;
              (l = n == Ke.FORWARD ? a.min - i.max : i.min - a.max),
                l >= 0 &&
                  s.push({ child: o, overlap: qe(ue[e], t, r), dist: l });
            }
          }
          if (
            (s.sort((e, t) => {
              if (e.overlap) {
                if (!t.overlap) return -1;
              } else if (t.overlap) return 1;
              const n = e.dist - t.dist;
              return n || t.overlap - e.overlap;
            }),
            We.IsDebugEnabled())
          ) {
            const e = s
              .slice(0, 3)
              .map(
                ({ dist: e, overlap: t, child: n }) =>
                  `[ node: ${n.m_element?.className} dist: ${e} overlap: ${t} ]`,
              );
            He(`Found nodes on axis, top 3 (of ${s.length}: ${e.join(", ")}`);
          }
          for (const { child: e } of s) {
            const n = e.FindFocusableNode(o, t);
            if (n) return n;
          }
          return null;
        }
        FindClosestChildInNextAxiallyAlignedSet(e, t, n, o, i, s) {
          (!i || i < 0) && (i = 0);
          let r = [];
          if (!o) return null;
          const a = { x: (l = o).left, y: l.top };
          var l;
          this.ScanChildren(i, t, (t) => {
            const n = t.GetBoundingRect();
            return (
              !!n &&
              (!(!s || $e(ue[e], s, n)) ||
                (r.push({ child: t, overlap: qe(e, o, n), dist: Xe(e, a, n) }),
                !1))
            );
          }),
            t == Ke.BACKWARD && r.reverse(),
            r.sort((e, t) => {
              const n = t.overlap - e.overlap;
              return 0 != n ? n : e.dist - t.dist;
            });
          for (const { child: e } of r) {
            const t = e.FindFocusableNode(n, o);
            if (t) return t;
          }
          return null;
        }
        GetChildren() {
          return (
            this.EnsureChildrenSorted(),
            [this.m_rgChildren, this.m_iLastActiveChildIndex]
          );
        }
        SetActiveChild(e) {
          e instanceof ze
            ? (this.EnsureChildrenSorted(),
              (this.m_ActiveChild = e),
              (this.m_iLastActiveChildIndex = this.m_rgChildren.indexOf(e)))
            : (this.IsValidChildIndex(e) &&
                (this.m_ActiveChild = this.m_rgChildren[e]),
              (this.m_iLastActiveChildIndex = e));
        }
        GetDepth() {
          return this.m_nDepth;
        }
        SetFocusableIfEmptyAncestor(e) {
          (this.m_FocusableIfEmptyAncestor = e),
            this.m_Properties?.focusableIfEmpty ||
              this.PropagateFocusableIfEmptyAncestorToDescendants(e);
        }
        PropagateFocusableIfEmptyAncestorToDescendants(e) {
          for (let t = 0; t < this.m_rgChildren.length; t++)
            this.m_rgChildren[t].SetFocusableIfEmptyAncestor(e);
        }
        OnFocusedDecendantRemoved(e) {
          this.m_Tree.DeferredFocus.RequestFocus(this, {
            bFocusDescendant: !0,
          });
        }
        SetDOMFocusAndScroll(e, t) {
          this.UpdateParentActiveChild(),
            this.m_Tree.OnChildActivated(e),
            this.m_Tree.BIsActiveFocus()
              ? ((0, ie.wT)(
                  !this.m_Tree.BUseVirtualFocus(),
                  "Virtual focus tree should not have browser focus",
                ),
                this.m_element?.focus({ preventScroll: !0 }))
              : this.m_Tree.BUseVirtualFocus() ||
                He(
                  `Didn't move focus to element as tree ${this.m_Tree.id} is not active focus tree`,
                ),
            (function (e, t) {
              const n = e.Element;
              if (!n) return;
              let o = [
                { node: e, eScrollType: e.m_Properties?.scrollIntoViewType },
              ];
              for (let t = e.Parent; t; t = t.Parent) {
                const e = t.m_Properties?.scrollIntoViewWhenChildFocused,
                  n = t.m_Properties?.scrollIntoViewType;
                if (e) {
                  const i = { node: t, eScrollType: n };
                  "force" === e ? (o = [i]) : o.push(i);
                }
                if (void 0 !== n)
                  for (
                    let e = o.length - 1;
                    e >= 0 && void 0 === o[e].eScrollType;
                    e--
                  )
                    o[e].eScrollType = n;
              }
              for (; o.length; ) {
                let { node: n, eScrollType: i } = o.pop(),
                  s = 0 == o.length;
                if (
                  (void 0 === i && (i = ye ? Ve.NoTransform : Ve.Standard),
                  n?.m_Properties?.fnScrollIntoViewHandler &&
                    !1 !== n.m_Properties.fnScrollIntoViewHandler(e, t, n))
                )
                  continue;
                const r = n.m_element,
                  a =
                    i == Ve.NoTransform ||
                    i == Ve.NoTransformSparseContent ||
                    !s;
                if (t) {
                  const t = a ? Re(r) : r.getBoundingClientRect();
                  let n = !1;
                  const o = Math.max(1.4 * (t.bottom - t.top), 40),
                    i = Ie && performance.now() - Ie < 500;
                  (i ||
                    t.bottom < -o ||
                    t.top > r.ownerDocument.defaultView.innerHeight + o) &&
                    ((n = !0),
                    i ||
                      Me(
                        `Disabling smooth scrolling, ${t.bottom} < ${-o}, ${t.top} > ${r.ownerDocument.defaultView.innerHeight} + ${o} `,
                      ));
                  let s = n ? "auto" : "smooth";
                  n && (Ie = performance.now()),
                    e.Tree.Controller.BIsRestoringHistory() && (s = "auto"),
                    a
                      ? Pe(0, r, s)
                      : r.scrollIntoView({ behavior: s, block: "nearest" });
                } else
                  Me("No previous element for scrolling, will jump"),
                    a
                      ? Pe(0, r, "auto")
                      : r?.scrollIntoView({
                          behavior: "auto",
                          block: "nearest",
                          inline: "nearest",
                        });
              }
            })(this, t);
        }
      }
      (0, i.Cg)([B.o], ze.prototype, "OnDOMFocus", null),
        (0, i.Cg)([B.o], ze.prototype, "OnDOMBlur", null),
        (0, i.Cg)([B.o], ze.prototype, "OnNavigationEvent", null);
      class je {
        m_node;
        m_History;
        m_StateHistory;
        constructor(e) {
          this.m_node = e;
        }
        TakeFocus(e) {
          return this.m_node.BTakeFocus(e ? Y.GAMEPAD : Y.APPLICATION, e);
        }
        ParentTakeFocus(e) {
          this.m_node.Parent?.BTakeFocus(e ? Y.GAMEPAD : Y.APPLICATION, e);
        }
        ChildTakeFocus(e) {
          return this.m_node.BChildTakeFocus(e ? Y.GAMEPAD : Y.APPLICATION, e);
        }
        FocusVisibleChild(e) {
          return this.m_node.BVisibleChildTakeFocus(e);
        }
        BHasFocus() {
          return this.m_node.BHasFocus();
        }
        BFocusWithin() {
          return this.m_node.BFocusWithin();
        }
        get NavKey() {
          return this.m_node.NavKey;
        }
        PushState() {
          this.m_History || (this.m_History = new le(this.m_node)),
            this.m_History.PushState();
        }
        PopState(e = 0) {
          this.m_History && this.m_History.PopState(e);
        }
        SaveState(e) {
          this.m_StateHistory || (this.m_StateHistory = new ce(this.m_node)),
            this.m_StateHistory.SaveState(e);
        }
        RestoreState(e, t = 0) {
          return (
            !!this.m_StateHistory && this.m_StateHistory.RestoreState(e, t)
          );
        }
        GetFocusSnapshot() {
          return (e = this.m_node), ae.SerializeNavState(e, !0, !1);
          var e;
        }
        RestoreFocusSnapshot(e, t = 0) {
          return (function (e, t, n = 0) {
            return ae.RestoreSerializedNavState(e, t, n);
          })(this.m_node, e, t);
        }
        NavTree() {
          return this.m_node.Tree;
        }
        Node() {
          return this.m_node;
        }
      }
      function $e(e, t, n, o = 0.001) {
        return "x" == e
          ? t.right > n.left + o && t.left + o < n.right
          : "y" == e
            ? t.bottom > n.top + o && t.top + o < n.bottom
            : ((0, ie.wT)(!1, `Invalid axis ${e}`), !1);
      }
      function qe(e, t, n) {
        let o;
        return (
          "x" == e
            ? (o = Math.min(t.right, n.right) - Math.max(t.left, n.left))
            : "y" == e
              ? (o = Math.min(t.bottom, n.bottom) - Math.max(t.top, n.top))
              : ((0, ie.wT)(!1, `Invalid axis ${e}`), (o = 0)),
          o < 0 ? 0 : o
        );
      }
      function Ye(e, t) {
        return "x" == e
          ? { min: t.left, max: t.right }
          : { min: t.top, max: t.bottom };
      }
      function Xe(e, t, n) {
        const o = t[e],
          i = Ye(e, n);
        return o < i.min ? i.min - o : o > i.max ? o - i.max : 0;
      }
      function Qe(e) {
        switch (e) {
          case $.DIR_UP:
          case $.DIR_DOWN:
            return "y";
          case $.DIR_LEFT:
          case $.DIR_RIGHT:
            return "x";
          default:
            return;
        }
      }
      function Je(e) {
        if (!e) return Ue.NONE;
        switch (e) {
          case "column":
            return Ue.COLUMN;
          case "column-reverse":
            return Ue.COLUMN_REVERSE;
          case "row":
            return Ue.ROW;
          case "row-reverse":
            return Ue.ROW_REVERSE;
          case "grid":
            return Ue.GRID;
          case "geometric":
            return Ue.GEOMETRIC;
          default:
            return (0, ie.z_)(e, `Unhandled flow-children: ${e}`), Ue.NONE;
        }
      }
      const Ze = c.createContext(function (e) {
        return {
          ShowVirtualKeyboard: () => {},
          ShowModalKeyboard: () => {},
          SetAsCurrentVirtualKeyboardTarget: () => {},
          HideVirtualKeyboard: () => {},
          DelayHideVirtualKeyboard: () => {},
          BIsActive: () => !1,
          BIsElementValidForInput: () => !1,
        };
      });
      function et(e, t) {
        const { onTextEntered: n, ...o } = e,
          i = c.useRef(null),
          s = c.useRef({});
        Object.assign(s.current, {
          ...o,
          BIsElementValidForInput: () =>
            i.current && document.activeElement == i.current,
        });
        const r = (function (e) {
            const t = c.useRef(void 0),
              n = c.useContext(Ze);
            t.current || (t.current = n(e || {}));
            return t.current;
          })(s.current),
          a = c.useCallback(
            (e) => {
              (document.hasFocus() || document.activeElement != i.current) &&
                (e.currentTarget == i.current
                  ? (r.BIsActive() || r.bInVR) && r.DelayHideVirtualKeyboard()
                  : console.warn(
                      "keyboard got blur event, but it's not the active element",
                    ));
            },
            [r],
          ),
          l = _(
            (e) => {
              i.current = e;
              const t = [];
              return (
                e &&
                  (e.addEventListener(
                    "focus",
                    r.SetAsCurrentVirtualKeyboardTarget,
                  ),
                  t.push(() =>
                    e.removeEventListener(
                      "focus",
                      r.SetAsCurrentVirtualKeyboardTarget,
                    ),
                  ),
                  e.addEventListener("click", r.ShowVirtualKeyboard),
                  t.push(() =>
                    e.removeEventListener("click", r.ShowVirtualKeyboard),
                  ),
                  t.push(Q(e, r.ShowVirtualKeyboard)),
                  t.push(Z(e, a))),
                () => t.forEach((e) => e())
              );
            },
            [a, r],
          );
        return (
          c.useLayoutEffect(
            () => (
              h(t, {
                TakeFocusAndShowKeyboard: () => {
                  const e = i.current;
                  e &&
                    (document.activeElement != e && e.focus(),
                    r.ShowVirtualKeyboard());
                },
                HideVirtualKeyboard: () => {
                  r.HideVirtualKeyboard();
                },
              }),
              () => h(t, null)
            ),
            [r, t],
          ),
          l
        );
      }
      const tt = c.createContext(void 0);
      function nt() {
        return c.useContext(tt);
      }
      c.forwardRef(function (e, t) {
        const {
            navID: n,
            onActivated: o,
            onDeactivated: i,
            navTreeRef: s,
            enabled: r,
            modal: a,
            virtualFocus: l,
            parentEmbeddedNavTree: u,
            onGlobalButtonDown: d,
            disableFocusClasses: m,
            disabledRoot: h,
            "flow-children": p,
            ..._
          } = e,
          { elemProps: g, navOptions: f, gamepadEvents: b } = ut(_);
        return nt()
          ? c.createElement(
              ot,
              {
                navID: n,
                onActivated: o,
                onDeactivated: i,
                navTreeRef: s,
                enabled: r,
                modal: a,
                virtualFocus: l,
                parentEmbeddedNavTree: u,
                onGlobalButtonDown: d,
                disableFocusClasses: m,
                disabledRoot: h,
                "flow-children": p,
                ...f,
                ...b,
              },
              c.createElement("div", { ...g, ref: t }),
            )
          : c.createElement("div", { ...g, ref: t });
      });
      function ot(e) {
        const {
            navID: t,
            onActivated: n,
            onDeactivated: o,
            navTreeRef: i,
            enabled: s = !0,
            modal: r = !1,
            virtualFocus: a = !1,
            children: l,
            parentEmbeddedNavTree: u,
            onGlobalButtonDown: d,
            disableFocusClasses: m = !1,
            disabledRoot: _ = !1,
            "flow-children": g,
            ...f
          } = e,
          { elemProps: b, navOptions: E, gamepadEvents: S } = ut(f),
          { refDiv: C, tree: v } = (function (e) {
            const {
                navID: t,
                virtualFocus: n,
                parentEmbeddedNavTree: o,
                disabledRoot: i,
                enabled: s,
                modal: r,
                navTreeRef: a,
                onGlobalButtonDown: l,
              } = e,
              u = nt(),
              d = c.useContext(L)?.focusNavWindow || u.GetDefaultContext(),
              m = c.useContext(rt),
              [p] = c.useState(() =>
                u.NewGamepadNavigationTree(d, t, o ?? m?.Tree),
              );
            let _ = c.useRef(null);
            return (
              p.SetUseVirtualFocus(n),
              p.SetModal(r),
              p.SetIsEmbeddedInLegacyTree(!!o),
              p.SetOnGlobalButtonDown(l),
              c.useEffect(
                () => p.RegisterNavigationItem(p.Root, _.current),
                [p, _],
              ),
              c.useEffect(() => {
                p.SetIsEnabled(s);
              }, [p, s]),
              c.useEffect(() => {
                if (!i)
                  return u.RegisterGamepadNavigationTree(
                    p,
                    _.current.ownerDocument.defaultView,
                  );
              }, [u, p, i]),
              c.useEffect(() => (h(a, p), () => h(a, null)), [a, p]),
              { refDiv: _, tree: p }
            );
          })({
            navID: t,
            virtualFocus: a,
            parentEmbeddedNavTree: u,
            disabledRoot: _,
            enabled: s,
            modal: r,
            onGlobalButtonDown: d,
            navTreeRef: i,
          });
        y(v.OnActivateCallbacks, n),
          y(v.OnDeactivateCallbacks, o),
          (function (e, t, n) {
            const { onButtonDown: o, ...i } = e,
              s = c.useCallback(
                (e) => {
                  o && o(e),
                    te(
                      "Gamepad Event fired:",
                      e.detail.button,
                      ", handled:",
                      null != o,
                      ", propagation stopped:",
                      e.cancelBubble,
                    ),
                    e.cancelBubble || n.OnRootButtonDown(e);
                },
                [o, n],
              );
            ne(i, t),
              ne(
                {
                  onButtonDown: s,
                  onButtonUp: oe,
                  onOKButton: oe,
                  onCancelButton: oe,
                  onSecondaryButton: oe,
                  onOptionsButton: oe,
                  onMenuButton: oe,
                  onGamepadDirection: oe,
                  onGamepadFocus: oe,
                  onGamepadBlur: oe,
                },
                t,
                [s],
              );
          })(S, C, v),
          c.useLayoutEffect(() => {
            const e = Je(g);
            v.Root.SetProperties({ ...E, layout: e });
          });
        const w = p(C, l.props.ref);
        return c.createElement(
          st,
          { tree: _ ? null : v, disableFocusClasses: m || _ },
          c.createElement(
            rt.Provider,
            { value: _ ? null : v.Root },
            c.cloneElement(l, { id: t, "data-react-nav-root": t, ref: w }),
          ),
        );
      }
      const it = c.createContext({
        bActiveTree: !1,
        bActiveTreeWithinContext: !1,
        bDisableFocusClasses: !1,
      });
      function st(e) {
        const { tree: t, disableFocusClasses: n = !1, children: o } = e,
          [i, s] = c.useState(t?.BIsActive() || !1),
          [r, a] = c.useState(t?.BIsActiveWithinContext() || !1);
        c.useEffect(
          () =>
            t
              ? (s(t.BIsActive()),
                a(t.BIsActiveWithinContext()),
                t.OnActiveStateChangedCallbacks.Register(() => {
                  s(t.BIsActive()), a(t.BIsActiveWithinContext());
                }).Unregister)
              : (s(!1), void a(!1)),
          [t],
        );
        const l = c.useMemo(
          () => ({
            bActiveTree: i,
            bActiveTreeWithinContext: r,
            bDisableFocusClasses: n,
          }),
          [i, n, r],
        );
        return c.createElement(it.Provider, { value: l }, o);
      }
      const rt = c.createContext(null),
        at = c.createContext({
          OnBlur: () => {},
          OnFocus: () => {},
          OnFocusChange: () => {},
          OnForceMeasureFocusRing: () => {},
        });
      function lt(e) {
        const { navRef: t, ...n } = e,
          o = c.useRef(null),
          i = (0, c.useContext)(rt),
          s = (0, c.useContext)(at),
          r = (function (e, t) {
            let n = c.useRef(null);
            return (
              !e ||
                (n.current && n.current.m_Parent == e) ||
                (n.current = e.Tree.CreateNode(e, t)),
              n.current
            );
          })(i, s);
        return (
          c.useLayoutEffect(() => {
            r && r.SetProperties(n);
          }),
          c.useLayoutEffect(() => {
            if (!i) return;
            const e = i.Tree.RegisterNavigationItem(r, o.current);
            return () => {
              e();
            };
          }, [i, r, o]),
          c.useLayoutEffect(() => {
            if (r && t) return h(t, r.CreateHandle()), () => h(t, null);
          }, [r, t]),
          { ref: o, node: r }
        );
      }
      function ct(e) {
        const {
            onButtonDown: t,
            onButtonUp: n,
            onOKButton: o,
            onCancelButton: i,
            onSecondaryButton: s,
            onOptionsButton: r,
            onGamepadDirection: a,
            onGamepadFocus: l,
            onGamepadBlur: c,
            onMenuButton: u,
            onOKActionDescription: d,
            onCancelActionDescription: m,
            onSecondaryActionDescription: h,
            onOptionsActionDescription: p,
            onMenuActionDescription: _,
            actionDescriptionMap: g,
            ...f
          } = e,
          b = {};
        void 0 !== t && (b.onButtonDown = t),
          void 0 !== n && (b.onButtonUp = n),
          void 0 !== o && (b.onOKButton = o),
          void 0 !== i && (b.onCancelButton = i),
          void 0 !== s && (b.onSecondaryButton = s),
          void 0 !== r && (b.onOptionsButton = r),
          void 0 !== u && (b.onMenuButton = u),
          void 0 !== a && (b.onGamepadDirection = a),
          void 0 !== l && (b.onGamepadFocus = l),
          void 0 !== c && (b.onGamepadBlur = c);
        const E = (function (e) {
          const {
              onOKActionDescription: t,
              onCancelActionDescription: n,
              onSecondaryActionDescription: o,
              onOptionsActionDescription: i,
              onMenuActionDescription: s,
              actionDescriptionMap: r,
            } = e,
            a = { ...r };
          return (
            void 0 !== t && (a[$.OK] = t),
            void 0 !== n && (a[$.CANCEL] = n),
            void 0 !== o && (a[$.SECONDARY] = o),
            void 0 !== i && (a[$.OPTIONS] = i),
            void 0 !== s && (a[$.START] = s),
            a
          );
        })({
          onOKActionDescription: d,
          onCancelActionDescription: m,
          onSecondaryActionDescription: h,
          onOptionsActionDescription: p,
          onMenuActionDescription: _,
          actionDescriptionMap: g,
        });
        return { gamepadEvents: b, actionDescriptions: E, props: f };
      }
      function ut(e) {
        const {
            autoFocus: t,
            preferredFocus: n,
            disableNavSounds: o,
            fnCanTakeFocus: i,
            childFocusDisabled: s,
            focusableIfEmpty: r,
            onFocusWithin: a,
            navKey: l,
            noFocusRing: c,
            focusable: u,
            navRef: d,
            actionDescriptionMap: m,
            onMoveUp: h,
            onMoveRight: p,
            onMoveDown: _,
            onMoveLeft: g,
            navEntryPreferPosition: f,
            scrollIntoViewWhenChildFocused: b,
            fnScrollIntoViewHandler: E,
            scrollIntoViewType: S,
            resetNavOnEntry: C,
            ...v
          } = e,
          { gamepadEvents: w, actionDescriptions: M, props: y } = ct(v);
        return {
          elemProps: y,
          navOptions: {
            autoFocus: t,
            preferredFocus: n,
            disableNavSounds: o,
            fnCanTakeFocus: i,
            childFocusDisabled: s,
            focusableIfEmpty: r,
            onFocusWithin: a,
            navKey: l,
            noFocusRing: c,
            focusable: u,
            navRef: d,
            onMoveUp: h,
            onMoveRight: p,
            onMoveDown: _,
            onMoveLeft: g,
            navEntryPreferPosition: f,
            scrollIntoViewWhenChildFocused: b,
            fnScrollIntoViewHandler: E,
            scrollIntoViewType: S,
            resetNavOnEntry: C,
            actionDescriptionMap: { ...m, ...M },
          },
          gamepadEvents: w,
        };
      }
      function dt(e) {
        return function (t) {
          const {
              focusClassName: n,
              focusWithinClassName: o,
              bFocusableByDefault: i,
              className: s,
              divRef: r,
              node: a,
              tabIndex: l,
              children: u,
              ...d
            } = t,
            m = N(),
            h = k(a.SubscribableHasFocus) && m,
            p = k(a.SubscribableFocusWithin) && m,
            {
              bActiveTree: _,
              bActiveTreeWithinContext: g,
              bDisableFocusClasses: f,
            } = c.useContext(it),
            b = _ && !f,
            E = !g && (void 0 !== l || i);
          return c.createElement(
            e,
            {
              ...d,
              className: D()(s, h && b && n, p && b && o),
              tabIndex: E ? -1 : l,
              ref: r,
            },
            u,
          );
        };
      }
      const mt = dt("div");
      function ht(e) {
        return (
          P.PlayNavSound(O.DefaultOk),
          b(e.currentTarget) && e.currentTarget.click(),
          !0
        );
      }
      const pt = c.createContext(void 0);
      pt.Provider;
      function _t(e, t, n, o, i) {
        const {
            elemProps: {
              focusClassName: s,
              children: r,
              "flow-children": a,
              ...l
            },
            navOptions: u,
            gamepadEvents: d,
          } = ut(n),
          {
            bFocusableByDefault: m = !0,
            bActivateByDefault: h = !1,
            bDOMElementFocusByDefault: _ = m,
          } = i || {};
        void 0 === u.focusable && !l.disabled && m && (u.focusable = !0);
        const g = Je(a),
          { ref: f, node: b } = lt({ layout: g, ...u });
        d.onOKButton ||
          ((("onClick" in l && l.onClick) || (h && (!0 === h || h(l)))) &&
            (d.onOKButton = ht)),
          u.focusable && !_
            ? (l.tabIndex = l.tabIndex || 0)
            : !u.focusable && _ && (l.tabIndex = l.tabIndex ?? -1),
          ne(d, f);
        const E = p(o, f),
          S = (0, c.useContext)(pt)?.Component;
        let C = { ...l };
        return (
          "onClick" in l && (C.role ??= "button"),
          b
            ? ((C = {
                ...C,
                divRef: E,
                node: b,
                focusClassName: D()(s, "gpfocus"),
                focusWithinClassName: "gpfocuswithin",
                bFocusableByDefault: _,
                className: D()(l.className, "Focusable"),
              }),
              c.createElement(
                rt.Provider,
                { value: b },
                S
                  ? c.createElement(S, { ...C, Component: t }, r)
                  : c.createElement(t, C, r),
              ))
            : c.createElement(
                e,
                { ...C, ref: o, className: D()(l.className, "Focusable") },
                r,
              )
        );
      }
      function gt(e, t) {
        const n = dt(e);
        return c.forwardRef(function (o, i) {
          return _t(e, n, o, i, t);
        });
      }
      function ft(e) {
        const t = dt(e);
        return c.forwardRef(function (n, o) {
          const {
              virtualKeyboardProps: i,
              props: { refKeyboardHandle: s, ...r },
            } = (function (e) {
              const {
                onEnterKeyPress: t,
                strEnterKeyLabel: n,
                onKeyboardNavOut: o,
                onKeyboardShow: i,
                onKeyboardFullyVisible: s,
                onTextEntered: r,
                BIsElementValidForInput: a,
                ...l
              } = e;
              return {
                virtualKeyboardProps: {
                  onEnterKeyPress: t,
                  strEnterKeyLabel: n,
                  onKeyboardNavOut: o,
                  onKeyboardShow: i,
                  onKeyboardFullyVisible: s,
                  onTextEntered: r,
                  BIsElementValidForInput: a,
                },
                props: l,
              };
            })(n),
            a = p(o, et(i, s));
          return _t(e, t, r, a);
        });
      }
      gt("div", { bDOMElementFocusByDefault: !1 }),
        gt("button", { bActivateByDefault: (e) => "submit" === e.type });
      const bt = gt("a", {
        bActivateByDefault: !0,
        bDOMElementFocusByDefault: !1,
      });
      c.forwardRef(function (e, t) {
        const { href: n = "#", ...o } = e;
        return c.createElement(bt, { ref: t, href: n, ...o });
      }),
        ft("input"),
        ft("textarea"),
        gt("img", { bDOMElementFocusByDefault: !1 }),
        gt("label", { bActivateByDefault: !0, bDOMElementFocusByDefault: !1 }),
        gt("section", { bFocusableByDefault: !1 }),
        gt("form", { bFocusableByDefault: !1 });
      const Et = c.createContext({ Component: mt });
      function St(e) {
        const {
            "flow-children": t,
            onActivate: n,
            onCancel: o,
            focusClassName: i,
            focusWithinClassName: s,
            ...r
          } = e,
          { elemProps: a, navOptions: l, gamepadEvents: u } = ut(r);
        let d = {};
        const m = Je(t);
        m != Ue.NONE && (d.layout = m),
          n &&
            ((a.onClick = a.onClick || n), (u.onOKButton = u.onOKButton || n)),
          u.onOKButton &&
            void 0 === l.focusable &&
            void 0 === l.focusableIfEmpty &&
            (l.focusable = !0),
          o && (u.onCancelButton = u.onCancelButton || o);
        const { ref: h, node: _ } = lt({ ...d, ...l }),
          g = N();
        (a.className = D()(a.className, "Panel", g && "Focusable")), ne(u, h);
        const f = p(h, e.ref);
        (!l.focusable && !l.focusableIfEmpty) ||
          (_ && _.Tree.BUseVirtualFocus()) ||
          (a.tabIndex = a.tabIndex || 0),
          l.focusable && (n || u.onOKButton) && (a.role ??= "button");
        const b = (0, c.useContext)(Et).Component;
        return c.createElement(
          rt.Provider,
          { value: _ },
          _
            ? c.createElement(b, {
                ...a,
                divRef: f,
                node: _,
                focusClassName: D()(i, "gpfocus"),
                focusWithinClassName: D()(s, "gpfocuswithin"),
              })
            : c.createElement("div", { ...a, ref: f }),
        );
      }
      const Ct = Object.seal({ onMoveUp: vt, onMoveDown: vt });
      Object.seal({ onMoveRight: vt, onMoveLeft: vt });
      function vt(e, t) {
        if (e.is_repeat) return !1;
        const n = t.GetRelativeDirection(e.button);
        return n == Ke.FORWARD
          ? t.BFocusFirstChild(Y.GAMEPAD)
          : n == Ke.BACKWARD && t.BFocusLastChild(Y.GAMEPAD);
      }
      function wt(e, t) {
        return !!e && "object" == typeof e.SteamClient && t in e.SteamClient;
      }
      function Mt(e, t) {
        if (!e) return !1;
        const [n, o] = t.split(".", 2);
        return n && o && wt(e, n) && o in e.SteamClient[n];
      }
      var yt = n(2038),
        It = n(650),
        Rt = n.n(It);
      const kt = c.forwardRef((e, t) => {
        const { className: n, contextMenuStyles: o, disabled: i, ...s } = e;
        return c.createElement("div", {
          ...s,
          ref: t,
          className: (0, yt.A)(
            n,
            (o || Rt()).contextMenuItem,
            "contextMenuItem",
            i && "disabled",
          ),
        });
      });
      kt.displayName = "MenuItem";
      n(7866);
      var Tt = n(4094);
      function Ot(e) {
        return c.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_DownArrowContextMenu",
            "data-name": "Layer 1",
            viewBox: "0 0 128 128",
            x: "0px",
            y: "0px",
            ...e,
          },
          c.createElement("polygon", {
            points:
              "50 59.49 13.21 22.89 4.74 31.39 50 76.41 95.26 31.39 86.79 22.89 50 59.49",
          }),
        );
      }
      function At(e) {
        const { color: t = "#FFFFFF", ...n } = e;
        return c.createElement(
          "svg",
          {
            version: "1.1",
            id: "Layer_2",
            xmlns: "http://www.w3.org/2000/svg",
            className: (0, yt.A)(
              "SVGIcon_Button",
              "SVGIcon_X_Line",
              e.className,
            ),
            x: "0px",
            y: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
            ...n,
          },
          c.createElement("line", {
            fill: "none",
            stroke: t,
            strokeWidth: "45",
            strokeMiterlimit: "10",
            x1: "212",
            y1: "212",
            x2: "44",
            y2: "44",
          }),
          c.createElement("line", {
            fill: "none",
            stroke: t,
            strokeWidth: "45",
            strokeMiterlimit: "10",
            x1: "44",
            y1: "212",
            x2: "212",
            y2: "44",
          }),
        );
      }
      function Dt() {
        return c.createElement(
          "svg",
          {
            version: "1.1",
            id: "base",
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_Maximize",
            x: "0px",
            y: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
          },
          c.createElement("rect", {
            x: "24",
            y: "42.167",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "18",
            strokeMiterlimit: "10",
            width: "208",
            height: "171.667",
          }),
          c.createElement("line", {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "42",
            strokeMiterlimit: "10",
            x1: "24",
            y1: "54.01",
            x2: "232",
            y2: "54.01",
          }),
        );
      }
      function Ft() {
        return c.createElement(
          "svg",
          {
            version: "1.1",
            id: "base",
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_Minimize",
            x: "0px",
            y: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
          },
          c.createElement("line", {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "18",
            strokeMiterlimit: "10",
            x1: "24",
            y1: "209.01",
            x2: "232",
            y2: "209.01",
          }),
        );
      }
      function Pt() {
        return c.createElement(
          "svg",
          {
            version: "1.1",
            id: "Layer_2",
            xmlns: "http://www.w3.org/2000/svg",
            className: "SVGIcon_Button SVGIcon_Restore",
            x: "0px",
            y: "0px",
            width: "256px",
            height: "256px",
            viewBox: "0 0 256 256",
          },
          c.createElement("polyline", {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "12",
            strokeMiterlimit: "10",
            points: "83,90.861 83,42.167 232,42.167 232,165.14 173,165.14 ",
          }),
          c.createElement("rect", {
            x: "24",
            y: "90.861",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "18",
            strokeMiterlimit: "10",
            width: "149",
            height: "122.973",
          }),
        );
      }
      function Lt(e, t = !0) {
        return function (n, o, i) {
          const s = i.value;
          i.value = function (...n) {
            let i = this[o + "_DebounceProperties"];
            void 0 === i &&
              (i = this[o + "_DebounceProperties"] =
                { hTimer: void 0, nPending: 0 }),
              void 0 === i.hTimer
                ? (t ? s.apply(this, n) : (i.nPending += 1),
                  (i.hTimer = window.setInterval(() => {
                    i.nPending > 0
                      ? (s.apply(this, n), (i.nPending = 0))
                      : (window.clearInterval(i.hTimer), (i.hTimer = void 0));
                  }, e)))
                : (i.nPending += 1);
          };
        };
      }
      var Nt = n(3339);
      const Bt = c.createContext(null);
      let xt = class extends c.Component {
        static contextType = Bt;
        m_navRef = (function () {
          return c.createRef();
        })();
        get instance() {
          return this.context.instance;
        }
        componentDidMount() {
          this.instance.SetLabel(this.props.label),
            this.m_navRef.current?.TakeFocus(),
            h(this.props.refInstance, this.instance);
        }
        componentDidUpdate(e) {
          e.label !== this.props.label &&
            this.context &&
            this.instance.SetLabel(this.props.label);
        }
        HideIfSubmenu() {
          return !!this.instance.BIsSubMenu() && (this.instance.HideSelf(), !0);
        }
        HideMenu() {
          return (
            this.instance.BIsSubMenu()
              ? this.instance.HideSelf()
              : this.instance.Hide(),
            !0
          );
        }
        render() {
          let {
            children: e,
            className: t,
            label: n,
            onCancel: o,
            cancelText: i,
            refInstance: s,
            bForceDesktopPresentation: r,
            footer: a,
            role: l = "menu",
            labelId: u,
            style: d = {},
            refScrollable: m,
            ...h
          } = this.props;
          const p = this.context.styles ?? Rt();
          let _ = i ?? "#Button_Cancel";
          if (1 != this.context.presentation || r)
            return c.createElement(
              "div",
              {
                ref: m,
                style: d,
                ...h,
                className: (0, yt.A)(
                  {
                    [p.contextMenuContents]: !0,
                    [p.hasSubMenu]: this.instance.BIsSubMenuVisible(),
                    [p.ForceDesktop]: r,
                  },
                  t,
                ),
              },
              e,
            );
          {
            const i = () => {
              o && o(), this.instance.Hide();
            };
            return (
              (d.overflowY = this.instance.BIsSubMenuVisible()
                ? "hidden"
                : void 0),
              c.createElement(
                St,
                {
                  ...h,
                  className: (0, yt.A)(
                    p.contextMenuContents,
                    { [p.hasSubMenu]: this.instance.BIsSubMenuVisible() },
                    t,
                  ),
                  "flow-children": "column",
                  onMoveLeft: this.HideIfSubmenu,
                  onCancel: this.instance.BIsSubMenu() ? this.HideMenu : i,
                  style: d,
                  navEntryPreferPosition: Ge.PREFERRED_CHILD,
                  navRef: this.m_navRef,
                  ref: m,
                  role: l,
                  "aria-labelledby": n ? u : void 0,
                  ...Ct,
                },
                e,
                n &&
                  c.createElement(
                    "div",
                    { id: u, style: { display: "none" } },
                    n,
                  ),
                !this.instance.BIsSubMenu() &&
                  c.createElement(
                    c.Fragment,
                    null,
                    c.createElement(Ut, null),
                    c.createElement(
                      Ht,
                      { className: p.Cancel, onSelected: i },
                      (0, Nt.we)(_),
                    ),
                    a,
                  ),
                this.instance.BIsSubMenuVisible() &&
                  c.createElement("div", {
                    className: p.contextMenuFade,
                    onClick: () => this.instance.HideSubMenu(),
                  }),
              )
            );
          }
        }
      };
      function Wt(e) {
        const t = c.useId();
        return c.createElement(xt, { labelId: t, ...e });
      }
      (0, i.Cg)([B.o], xt.prototype, "HideIfSubmenu", null),
        (0, i.Cg)([B.o], xt.prototype, "HideMenu", null),
        (xt = (0, i.Cg)([l.PA], xt));
      class Ht extends c.PureComponent {
        static contextType = Bt;
        m_ref = c.createRef();
        m_refDiv = c.createRef();
        get element() {
          return this.m_refDiv.current;
        }
        get instance() {
          return this.context.instance;
        }
        OnClick(e) {
          this.props.disabled
            ? this.context.callbacks?.onDisabledItemSelected &&
              this.context.callbacks.onDisabledItemSelected()
            : (this.props.onClick && this.props.onClick(e),
              this.props.bInteractableItem ||
                (this.props.onSelected && this.props.onSelected(e),
                this.context && this.instance.ForceHide()));
        }
        OnOKButton(e) {
          this.m_refDiv.current?.click();
        }
        OnMouseEnter(e) {
          0 == this.context.presentation && this.instance.HideSubMenu();
        }
        Focus() {
          this.m_ref.current
            ? this.m_ref.current.TakeFocus()
            : this.m_refDiv.current && this.m_refDiv.current.focus();
        }
        render() {
          const {
              onSelected: e,
              bInteractableItem: t,
              onMoveRight: n,
              ...o
            } = this.props,
            i = this.context?.styles ?? Rt();
          return 1 == this.context.presentation
            ? c.createElement(
                St,
                {
                  noFocusRing: !0,
                  preferredFocus: this.props.selected,
                  ref: this.m_refDiv,
                  navRef: this.m_ref,
                  onMouseEnter: this.OnMouseEnter,
                  ...o,
                  className: (0, yt.A)(
                    this.props.className,
                    i.contextMenuItem,
                    "contextMenuItem",
                    this.props.disabled && "disabled",
                    this.props.selected && i.Selected,
                    "positive" == this.props.tone && i.Positive,
                    "emphasis" == this.props.tone && i.Emphasis,
                    "destructive" == this.props.tone && i.Destructive,
                  ),
                  focusClassName: i.Focused,
                  onClick: this.props.disabled ? void 0 : this.OnClick,
                  focusable: !this.props.disabled,
                  onOKButton: this.OnOKButton,
                  onMoveRight: n,
                  unselectable: this.props.unselectable,
                  role: o.role ?? "menuitem",
                  "aria-selected": this.props.selected,
                },
                this.props.children,
              )
            : c.createElement(
                kt,
                {
                  ref: this.m_refDiv,
                  onMouseEnter: this.OnMouseEnter,
                  ...o,
                  onClick: this.OnClick,
                  unselectable: this.props.unselectable,
                  className: this.props.className,
                  role: o.role ?? "menuitem",
                  "aria-selected": this.props.selected,
                },
                this.props.children,
              );
        }
      }
      (0, i.Cg)([B.o], Ht.prototype, "OnClick", null),
        (0, i.Cg)([B.o], Ht.prototype, "OnOKButton", null),
        (0, i.Cg)([B.o], Ht.prototype, "OnMouseEnter", null),
        (0, i.Cg)([B.o], Ht.prototype, "Focus", null);
      c.PureComponent;
      c.PureComponent;
      function Ut(e) {
        const t = c.useContext(Bt).styles ?? Rt();
        return c.createElement("div", {
          className: t.ContextMenuSeparator,
          role: "separator",
        });
      }
      class Gt extends c.PureComponent {
        static contextType = Bt;
        m_refItem = c.createRef();
        constructor(e) {
          super(e), (this.state = { bActive: !1 });
        }
        get instance() {
          return this.context.instance;
        }
        OnSubMenuMouseEnter() {
          this.instance.CancelHideSubMenuTimer();
        }
        OnSubMenuHidden() {
          this.setState({ bActive: !1 }),
            this.props.bInGamepadUI &&
              1 == this.context.presentation &&
              this.m_refItem.current &&
              this.m_refItem.current.Focus();
        }
        ShowSubMenu(e) {
          const t = e || this.m_refItem.current.element;
          let n = this.instance.ShowSubMenu(t, this.RenderSubMenu);
          return (
            !!n &&
            (this.setState({ bActive: !0 }),
            n.SetOnHideCallback(this.OnSubMenuHidden),
            !0)
          );
        }
        RenderSubMenu() {
          return c.createElement(
            Wt,
            { onMouseEnter: this.OnSubMenuMouseEnter, label: this.props.label },
            this.props.children,
          );
        }
        OnMouseEnter(e) {
          0 == this.context.presentation && this.ShowSubMenu(e.currentTarget);
        }
        OnClick(e) {
          this.OnMouseEnter(e),
            this.props.onClick && this.props.onClick(e),
            this.props.bInGamepadUI &&
              1 == this.context.presentation &&
              this.ShowSubMenu(e.currentTarget);
        }
        render() {
          let {
            label: e,
            selectedWithin: t,
            children: n,
            className: o,
            bInGamepadUI: i,
            ...s
          } = this.props;
          const r = this.context.styles ?? Rt();
          return c.createElement(
            Ht,
            {
              ...s,
              ref: this.m_refItem,
              onClick: this.OnClick,
              selected: t && !this.state.bActive,
              className: (0, yt.A)(
                o,
                r.SubMenu,
                this.state.bActive && r.active,
              ),
              onMouseEnter: this.OnMouseEnter,
              bInteractableItem: !0,
              onMoveRight: () => this.ShowSubMenu(),
            },
            c.createElement("div", { className: r.Label }, e),
            c.createElement(
              "div",
              { className: r.Arrow },
              c.createElement(Ot, null),
            ),
          );
        }
      }
      (0, i.Cg)([B.o], Gt.prototype, "OnSubMenuMouseEnter", null),
        (0, i.Cg)([B.o], Gt.prototype, "OnSubMenuHidden", null),
        (0, i.Cg)([B.o], Gt.prototype, "ShowSubMenu", null),
        (0, i.Cg)([B.o], Gt.prototype, "RenderSubMenu", null),
        (0, i.Cg)([B.o], Gt.prototype, "OnMouseEnter", null),
        (0, i.Cg)([B.o], Gt.prototype, "OnClick", null);
      let Vt = class extends c.Component {
        m_elMenu = void 0;
        m_cReenteranceGuard = 1;
        m_mutationObserver;
        constructor(e) {
          super(e),
            (this.state = {
              ready: !1,
              menuLeft: void 0,
              menuTop: void 0,
              menuRight: void 0,
              menuBottom: void 0,
              menuWidth: void 0,
              menuHeight: void 0,
              menuMinWidth: void 0,
            }),
            (this.m_mutationObserver = new MutationObserver(
              this.OnMenuMutation,
            ));
        }
        get parentWin() {
          return (
            this.props.element?.ownerDocument.defaultView ||
            this.props.parentWin
          );
        }
        BindMenuElement(e) {
          this.props.instance.SetElement(e),
            this.m_elMenu &&
              (this.m_mutationObserver.disconnect(),
              (this.props.popup && !this.props.options.bScreenCoordinates) ||
                this.m_elMenu.ownerDocument.defaultView?.removeEventListener(
                  "resize",
                  this.OnWindowResize,
                )),
            e &&
              (this.m_mutationObserver.observe(e, {
                childList: !0,
                subtree: !0,
              }),
              (this.props.popup && !this.props.options.bScreenCoordinates) ||
                e.ownerDocument.defaultView?.addEventListener(
                  "resize",
                  this.OnWindowResize,
                )),
            (this.m_elMenu = e || void 0),
            Tt.TS.IN_CLIENT && this.props.popup && this.m_elMenu
              ? this.m_elMenu.ownerDocument.fonts.ready.then(() => {
                  this.PositionMenu();
                })
              : this.PositionMenu(),
            this.state.ready ||
              (this.props.instance.SetTakeFocus(this.TakeFocus.bind(this)),
              this.setState({ ready: !0 }, () => {
                this.props.options?.bSkipFocusWhenReady || this.TakeFocus();
              }));
        }
        OnMenuMutation(e, t) {
          this.PositionMenu();
        }
        OnWindowResize() {
          this.PositionMenu();
        }
        OnBlur(e) {
          if (
            (!e.relatedTarget || !E(e.currentTarget, e.relatedTarget)) &&
            (!e.relatedTarget ||
              !this.props.instance.BIsElementInMenuHierarchy(
                e.relatedTarget,
              )) &&
            !this.props.instance.BIsSubMenuVisible() &&
            this.state.ready &&
            this.props.instance.visible
          ) {
            const e = $t() ? 150 : 0;
            this.props.instance.OnCancel(e);
          }
        }
        OnKeyDown(e) {
          27 == e.keyCode &&
            this.state.ready &&
            (this.props.instance.Hide(),
            e.preventDefault(),
            e.stopPropagation());
        }
        componentDidUpdate() {
          this.m_cReenteranceGuard-- > 0
            ? this.PositionMenu()
            : (this.m_cReenteranceGuard = 2);
        }
        TakeFocus() {
          if (
            this.m_elMenu &&
            this.state.ready &&
            this.props.instance.visible &&
            (this.props.popup ||
              !E(this.m_elMenu, this.m_elMenu.ownerDocument.activeElement))
          ) {
            let e = this.m_elMenu.querySelector(".ContextMenuAutoFocus");
            e && e.focus ? e.focus() : this.m_elMenu.focus();
          }
        }
        PositionMenu(e = !1) {
          const t = this.props.options;
          let n = this.m_elMenu,
            o = this.props.element;
          if (!n) return;
          let i = null != this.props.popup,
            s = this.parentWin;
          if (!s || (o && "none" === s.getComputedStyle(o).display)) return;
          let r = this.props.clientX,
            a = this.props.clientY,
            l = 0,
            c = 0,
            u = s.innerWidth,
            d = s.innerHeight,
            m = o?.getBoundingClientRect();
          if (i)
            if (
              (t.bScreenCoordinates ||
                void 0 === r ||
                void 0 === a ||
                ((r += s.screenLeft), (a += s.screenTop)),
              m && (m = S(s, m)),
              t.targetMonitor)
            )
              (l = t.targetMonitor.nScreenLeft),
                (c = t.targetMonitor.nScreenTop),
                (u = t.targetMonitor.nScreenWidth),
                (d = t.targetMonitor.nScreenHeight);
            else {
              let e = s.screen,
                t = 0,
                n = 0;
              e.availLeft && (t = e.availLeft),
                e.availTop && (n = e.availTop),
                (l = t),
                (c = n),
                (u = e.availWidth),
                (d = e.availHeight);
            }
          (t.bOverlapHorizontal || t.bOverlapVertical) && (r = a = void 0);
          const h = n.getBoundingClientRect();
          let p = {
              menuLeft: void 0,
              menuRight: void 0,
              menuTop: void 0,
              menuBottom: void 0,
              menuWidth: void 0,
              menuHeight: void 0,
              menuMinWidth: void 0,
            },
            _ = r ?? m.left,
            g = r ?? m.right,
            f = h.width;
          t.bMatchWidth && ((f = g - _), (p.menuWidth = f)),
            t.bGrowToElementWidth && (p.menuMinWidth = Math.max(f, g - _));
          let b = (t.bOverlapHorizontal ? g : _) - l - f,
            E = b > 0,
            C = l + u - (t.bOverlapHorizontal ? _ : g) - f,
            v = C > 0,
            w = t.bPreferPopLeft;
          o?.matches(":dir(rtl)") && (w = !w);
          let M = (w || !v) && E;
          E ||
            v ||
            ((M = E > v),
            t.bFitToWindow && ((f += (M ? b : C) - 8), (p.menuWidth = f))),
            M
              ? (p.menuRight = u - (t.bOverlapHorizontal ? g : _))
              : (p.menuLeft = t.bOverlapHorizontal ? _ : g);
          let y = a ?? m.top,
            I = a ?? m.bottom,
            R = n.scrollHeight;
          t.bMatchHeight && ((R = I - y), (p.menuHeight = R));
          let k = (t.bOverlapVertical ? I : y) - c - R,
            T = k > 0,
            O = c + d - (t.bOverlapVertical ? y : I) - R,
            A = O > 0,
            D = (t.bPreferPopTop || !A) && T && !t.bDisablePopTop;
          if (!T && !A) {
            const e =
              void 0 !== t.bShiftToFitWindow
                ? t.bShiftToFitWindow
                : !!t.bFitToWindow && !t.bOverlapHorizontal;
            (D = k > O && !t.bDisablePopTop),
              e && (D ? (p.menuTop = 4) : (p.menuBottom = 4)),
              t.bFitToWindow &&
                (e ? (R = Math.min(R, d - 8)) : (R += D ? k : O),
                (p.menuHeight = R - 8));
          }
          void 0 === p.menuBottom &&
            void 0 === p.menuTop &&
            (D
              ? (p.menuBottom = d - (t.bOverlapVertical ? I : y))
              : (p.menuTop = t.bOverlapVertical ? y : I)),
            i
              ? (p.menuHeight || (p.menuHeight = h.height),
                p.menuWidth || (p.menuWidth = h.width),
                p.menuBottom &&
                  !p.menuTop &&
                  ((p.menuTop = d - p.menuBottom - p.menuHeight),
                  (p.menuBottom = void 0)),
                p.menuRight &&
                  !p.menuLeft &&
                  ((p.menuLeft = u - p.menuRight - p.menuWidth),
                  (p.menuRight = void 0)))
              : "fixed" != s.getComputedStyle(n).position &&
                (p.menuLeft && (p.menuLeft += s.scrollX),
                p.menuTop && (p.menuTop += s.scrollY),
                p.menuBottom &&
                  (p.menuBottom +=
                    s.document.body.clientHeight - s.scrollY - s.innerHeight),
                p.menuRight &&
                  (p.menuRight +=
                    s.document.body.clientWidth - s.scrollX - s.innerWidth)),
            (e ||
              p.menuLeft !== this.state.menuLeft ||
              p.menuRight !== this.state.menuRight ||
              p.menuTop !== this.state.menuTop ||
              p.menuBottom !== this.state.menuBottom ||
              p.menuWidth !== this.state.menuWidth ||
              p.menuHeight !== this.state.menuHeight) &&
              this.setState(p);
        }
        PositionPopupWindow() {
          if (
            !(
              void 0 !== this.state.menuLeft &&
              void 0 !== this.state.menuTop &&
              void 0 !== this.state.menuWidth &&
              void 0 !== this.state.menuHeight
            )
          )
            return;
          const e = this.props.popup?.window,
            t = this.props.options;
          if (t.bScreenCoordinates) {
            const n =
              t.targetMonitor?.flScaleToTargetMonitor ??
              this.parentWin?.devicePixelRatio;
            return (
              e?.SteamClient.Window.MoveTo(
                this.state.menuLeft,
                this.state.menuTop,
                n ?? !0,
              ),
              void e?.SteamClient.Window.ResizeTo(
                this.state.menuWidth,
                this.state.menuHeight,
                n ?? !0,
              )
            );
          }
          this.parentWin?.SteamClient.Window.GetWindowRestoreDetails().then(
            (t) => {
              const n = this.state.menuLeft - this.parentWin.screenX,
                o = this.state.menuTop - this.parentWin.screenY;
              try {
                e?.SteamClient.Window.PositionWindowRelative(
                  t,
                  n,
                  o,
                  this.state.menuWidth,
                  this.state.menuHeight,
                );
              } catch (e) {
                console.error(e);
              }
            },
          );
        }
        render() {
          let e = { visibility: this.state.ready ? "visible" : "hidden" };
          this.props.options.flElementZoom &&
            this.props.options.flElementZoom > 0 &&
            (e.zoom = this.props.options.flElementZoom),
            this.props.popup
              ? (this.PositionPopupWindow(),
                void 0 !== this.state.menuMinWidth &&
                  (e.minWidth = Math.floor(this.state.menuMinWidth)))
              : (void 0 !== this.state.menuTop
                  ? (e.top = this.state.menuTop)
                  : void 0 !== this.state.menuBottom &&
                    (e.bottom = this.state.menuBottom),
                void 0 !== this.state.menuLeft
                  ? (e.left = this.state.menuLeft)
                  : void 0 !== this.state.menuRight &&
                    (e.right = this.state.menuRight),
                void 0 !== this.state.menuHeight &&
                  (e.height = this.state.menuHeight),
                void 0 !== this.state.menuWidth &&
                  (e.width = this.state.menuWidth),
                void 0 !== this.state.menuMinWidth &&
                  (e.minWidth = this.state.menuMinWidth));
          let t = this.props.options.strClassName || Rt().contextMenu;
          return (
            (this.props.options.bCreateHidden ||
              (this.props.instance.visible && this.state.ready)) &&
              (t += " visible"),
            this.props.instance.visible && this.state.ready && (t += " ready"),
            (t += " " + Rt().ContextMenuPosition),
            this.props.options.bStandalone && (t += " " + Rt().Standalone),
            c.createElement(
              "div",
              {
                className: t,
                ref: this.BindMenuElement,
                style: e,
                onBlur: this.OnBlur,
                onKeyDown: this.OnKeyDown,
                tabIndex: 0,
              },
              this.props.children,
            )
          );
        }
      };
      function Kt(e) {
        return c.createElement("div", {
          className: Rt().ContextMenuMouseOverlay,
        });
      }
      function zt(e) {
        let t = [],
          n = (function (e) {
            let t;
            return (
              e &&
                b(e.currentTarget) &&
                (t = e.currentTarget.ownerDocument.defaultView),
              t
            );
          })(e),
          o = n.getSelection(),
          i = o && o.rangeCount > 0 && o.toString().length > 0,
          s = e.target,
          r = !1;
        const a = e.clientY,
          l = e.clientX;
        if (
          (s &&
            "tagName" in s &&
            (("INPUT" != s.tagName && "TEXTAREA" != s.tagName) || (r = !0)),
          Tt.TS.IN_CLIENT && r && Mt(n, "Browser.GetSpellingSuggestions"))
        ) {
          let [e, ...o] = n.SteamClient.Browser.GetSpellingSuggestions(),
            i = s;
          if (
            (i &&
              o.forEach((e, o) => {
                t.push(
                  c.createElement(
                    Ht,
                    {
                      key: `spelling_${o}_${e}`,
                      onSelected: () => {
                        i.setRangeText(e),
                          (function (e, t) {
                            let n = t.createEvent("HTMLEvents");
                            n.initEvent("change", !0, !1), e.dispatchEvent(n);
                          })(i, n.document),
                          i.setSelectionRange(i.selectionEnd, i.selectionEnd),
                          s.focus();
                      },
                      className: Rt().NoSeparation,
                    },
                    e,
                  ),
                );
              }),
            e && Mt(n, "Browser.AddWordToDictionary"))
          ) {
            const o = 30;
            (e = e.trim()),
              t.push(
                c.createElement(
                  Ht,
                  {
                    key: `addtodictionary_${e}`,
                    onSelected: () =>
                      n.SteamClient.Browser.AddWordToDictionary(e),
                  },
                  (0, Nt.we)(
                    "#ContextMenu_AddToDictionary",
                    e.length < o ? e : e.substring(0, o) + "...",
                  ),
                ),
              );
          }
        }
        if (
          ((n.document.queryCommandEnabled("cut") || (i && r)) &&
            t.push(
              c.createElement(
                Ht,
                {
                  key: "cut",
                  onSelected: () => {
                    n.document.execCommand("cut");
                  },
                },
                (0, Nt.we)("#ContextMenu_Cut"),
              ),
            ),
          (n.document.queryCommandEnabled("copy") || i) &&
            t.push(
              c.createElement(
                Ht,
                {
                  key: "copy",
                  onSelected: () => {
                    n.document.execCommand("copy");
                  },
                  className: Rt().NoSeparation,
                },
                (0, Nt.we)("#ContextMenu_Copy"),
              ),
            ),
          Tt.TS.IN_CLIENT &&
            r &&
            Mt(n, "Browser.Paste") &&
            t.push(
              c.createElement(
                Ht,
                {
                  key: "paste",
                  onSelected: () => {
                    s.focus(), n.SteamClient.Browser.Paste();
                  },
                  className: Rt().NoSeparation,
                },
                (0, Nt.we)("#ContextMenu_Paste"),
              ),
            ),
          Tt.TS.IN_CLIENT && Tt.TS.DEV_MODE)
        ) {
          const e = [];
          Mt(n, "Browser.OpenDevTools") &&
            e.push(
              c.createElement(
                Ht,
                {
                  key: "opendevtools",
                  onSelected: () => {
                    s.focus(), n.SteamClient.Browser.OpenDevTools();
                  },
                },
                "Open Dev Tools",
              ),
            ),
            Mt(n, "Browser.InspectElement") &&
              e.push(
                c.createElement(
                  Ht,
                  {
                    key: "inspectelement",
                    onSelected: () => {
                      s.focus(), n.SteamClient.Browser.InspectElement(a, l);
                    },
                    className: Rt().NoSeparation,
                  },
                  "Inspect Element",
                ),
              ),
            e.length > 0 &&
              (t.push(c.createElement(Ut, { key: "devtools-separator" })),
              t.push(...e));
        }
        if (t.length)
          !(function (e, t, n) {
            let o,
              i,
              s,
              r = t;
            if (r?.preventDefault && r?.stopPropagation) {
              if (r.shiftKey || (r.altKey && !n?.bRootContextMenu)) return null;
              r.preventDefault(),
                r.stopPropagation(),
                (s = r.currentTarget),
                (o = r.clientX),
                (i = r.clientY);
            } else s = t;
            const a = en.GetContextMenuManagerFromWindow(s);
            let l = a.CreateContextMenuInstance(e, s, o, i, n);
            l.Show(), n?.bCreateHidden && l.Hide();
          })(c.createElement(Wt, null, t), e, { bRootContextMenu: !0 });
        else {
          if (e.shiftKey) return;
          e.preventDefault(), e.stopPropagation();
        }
      }
      (0, i.Cg)([B.o], Vt.prototype, "BindMenuElement", null),
        (0, i.Cg)([B.o, Lt(100)], Vt.prototype, "OnMenuMutation", null),
        (0, i.Cg)([B.o], Vt.prototype, "OnWindowResize", null),
        (0, i.Cg)([B.o], Vt.prototype, "OnBlur", null),
        (0, i.Cg)([B.o], Vt.prototype, "OnKeyDown", null),
        (Vt = (0, i.Cg)([l.PA], Vt));
      const jt = "EnableContextMenuBlurDelay3";
      function $t() {
        return (
          "true" === (window.localStorage && window.localStorage.getItem(jt))
        );
      }
      var qt = n(2837);
      class Yt {
        static s_nNextKeyValue = 1;
        m_nKey = null;
        m_ContextMenuManager;
        m_bVisible = !1;
        m_fnTakeFocus;
        m_element;
        m_rctElement;
        m_rctLabel = void 0;
        m_popupContextMenu;
        m_timerHideMenu = 0;
        m_options;
        m_position;
        m_submenu;
        m_parentInstance;
        m_elSubmenuItem = null;
        m_timerHideSubMenu = 0;
        m_fnOnHideCallback;
        constructor(e, t) {
          (0, f.Gn)(this),
            (this.m_ContextMenuManager = e),
            (this.m_rctElement = t);
        }
        get Manager() {
          return this.m_ContextMenuManager;
        }
        get key() {
          return (
            null == this.m_nKey &&
              ((this.m_nKey = Yt.s_nNextKeyValue), Yt.s_nNextKeyValue++),
            this.m_nKey
          );
        }
        SetElement(e) {
          this.m_element = e;
        }
        SetPopup(e) {
          this.m_popupContextMenu = e;
        }
        get ReactElement() {
          return this.m_rctElement;
        }
        get label() {
          return this.m_rctLabel;
        }
        get submenu() {
          return this.m_submenu;
        }
        get visible() {
          return this.m_bVisible;
        }
        get options() {
          return this.m_options;
        }
        get position() {
          return this.m_position;
        }
        SetOnHideCallback(e) {
          this.m_fnOnHideCallback = e;
        }
        Show() {
          this.CancelHideMenuTimer(),
            (this.m_bVisible = !0),
            this.m_ContextMenuManager.ShowMenu(this);
        }
        OnCancel(e = 0) {
          this.options?.onCancel && this.options.onCancel(), this.Hide(e);
        }
        Hide(e = 0) {
          e > 0
            ? (this.m_timerHideMenu = window.setTimeout(() => {
                (this.m_timerHideMenu = 0), this.InternalHide();
              }, e))
            : this.InternalHide();
        }
        CancelHideMenuTimer() {
          this.m_timerHideMenu > 0 &&
            (clearTimeout(this.m_timerHideMenu), (this.m_timerHideMenu = 0));
        }
        SetPosition(e, t, n) {
          (this.m_options = { ...this.m_options, ...n }),
            (this.m_position.clientX = e),
            (this.m_position.clientY = t),
            (this.m_position.options = this.m_options);
        }
        ForceHide() {
          this.InternalHide();
        }
        HideIfNotInFocus() {
          this.BHasFocus() || this.BIsFocusInChildHierarchy() || this.Hide();
        }
        InternalHide() {
          this.CancelHideMenuTimer(),
            this.m_bVisible &&
              ((this.m_bVisible = !1),
              this.InternalHideSubMenu(),
              this.m_fnOnHideCallback && this.m_fnOnHideCallback(),
              this.m_ContextMenuManager.HideMenu(this));
        }
        SetTakeFocus(e) {
          this.m_fnTakeFocus = e;
        }
        ShowSubMenu(e, t) {
          return this.m_elSubmenuItem == e
            ? (this.CancelHideSubMenuTimer(), this.m_submenu?.TakeFocus(), null)
            : (this.InternalHideSubMenu(),
              (this.m_elSubmenuItem = e),
              (this.m_submenu = new Qt(
                this,
                t(),
                e,
                this.m_options.bForcePopup,
              )),
              this.m_submenu.Show(),
              this.m_submenu);
        }
        CancelHideSubMenuTimer() {
          this.m_timerHideSubMenu > 0 &&
            (clearTimeout(this.m_timerHideSubMenu),
            (this.m_timerHideSubMenu = 0));
        }
        HideSubMenu() {
          if (!this.m_submenu) return void this.CancelHideSubMenuTimer();
          if (this.m_timerHideSubMenu > 0) return;
          this.m_timerHideSubMenu = window.setTimeout(() => {
            this.InternalHideSubMenu(), (this.m_timerHideSubMenu = 0);
          }, 150);
        }
        OnSubMenuDismissed(e) {
          this.m_submenu == e && this.InternalHideSubMenu();
        }
        HideSelf() {
          this.m_parentInstance
            ? this.m_parentInstance.OnSubMenuDismissed(this)
            : this.InternalHide();
        }
        InternalHideSubMenu() {
          this.CancelHideSubMenuTimer(),
            this.m_submenu &&
              (this.m_submenu.m_element &&
                this.BIsFocusInChildHierarchy() &&
                this.TakeFocus(qt.iE.k_EWindowBringToFrontAndForceOS),
              (this.m_elSubmenuItem = null),
              this.m_submenu.InternalHide(),
              (this.m_submenu = void 0));
        }
        TakeFocus(e = qt.iE.k_EWindowBringToFrontAndForceOS) {
          this.m_popupContextMenu && this.m_popupContextMenu.Focus(e),
            this.m_fnTakeFocus && this.m_fnTakeFocus();
        }
        BInternalElementInParentHierarchy(e) {
          return (
            null != this.m_parentInstance &&
            (this.m_parentInstance.BIsChildElement(e) ||
              this.m_parentInstance.BInternalElementInParentHierarchy(e))
          );
        }
        BInternalElementInChildHierarchy(e) {
          return (
            null != this.m_submenu &&
            (this.m_submenu.BIsChildElement(e) ||
              this.m_submenu.BInternalElementInChildHierarchy(e))
          );
        }
        BIsChildElement(e) {
          return this.m_element
            ? E(this.m_element, e)
            : E(this.m_popupContextMenu?.root_element, e);
        }
        BHasFocus() {
          return this.m_popupContextMenu
            ? this.m_popupContextMenu.focused
            : E(this.m_element, this.m_element?.ownerDocument.activeElement);
        }
        BIsFocusInChildHierarchy() {
          return (
            null != this.m_submenu &&
            (this.m_submenu.BHasFocus() ||
              this.m_submenu.BIsFocusInChildHierarchy())
          );
        }
        BIsElementInMenuHierarchy(e) {
          return (
            this.BInternalElementInParentHierarchy(e) ||
            this.BInternalElementInChildHierarchy(e)
          );
        }
        BIsSubMenuVisible() {
          return !!this.m_submenu;
        }
        SetLabel(e) {
          this.m_rctLabel = e;
        }
      }
      (0, i.Cg)([f.sH], Yt.prototype, "m_bVisible", void 0),
        (0, i.Cg)([f.sH.ref], Yt.prototype, "m_rctLabel", void 0);
      class Xt extends Yt {
        constructor(e, t, n, o, i, s) {
          super(e, t),
            (this.m_options = s || {}),
            (this.m_position = {
              element: n,
              clientX: o,
              clientY: i,
              instance: this,
              options: this.m_options,
              fnOnMenuItemSelected: () => {
                this.Hide();
              },
            });
        }
        Show() {
          super.Show();
        }
        Hide(e = 0) {
          super.Hide(e);
        }
        ForceHide() {
          super.ForceHide();
        }
        BIsSubMenu() {
          return !1;
        }
      }
      class Qt extends Yt {
        constructor(e, t, n, o) {
          super(e.Manager, t),
            (this.m_parentInstance = e),
            (this.m_options = {
              bOverlapVertical: !0,
              strClassName: e.options.strClassName,
              bFitToWindow: e.options.bFitToWindow,
              bShiftToFitWindow: e.options.bShiftToFitWindow,
              bForcePopup: o,
            }),
            (this.m_position = {
              element: n,
              clientX: void 0,
              clientY: void 0,
              instance: this,
              options: this.m_options,
              fnOnMenuItemSelected: () => {
                this.Hide();
              },
              bSubmenu: !0,
            });
        }
        Hide() {
          this.m_popupContextMenu
            ? window.setTimeout(() => {
                this.m_parentInstance?.HideIfNotInFocus();
              }, 10)
            : this.m_parentInstance?.Hide();
        }
        ForceHide() {
          this.m_parentInstance?.ForceHide();
        }
        BIsSubMenu() {
          return !0;
        }
      }
      var Jt = n(2490);
      class Zt {
        m_callbacksMenusChanged = new F.lu();
        m_ActiveMenu;
        m_rgActiveSubmenus = [];
        m_setHiddenMenus = new Set();
        constructor() {}
        CreateContextMenuInstance(e, t, n, o, i) {
          const s = new Xt(this, e, t, n, o, i);
          return (
            i?.bCreateHidden &&
              (this.m_setHiddenMenus.add(s),
              this.m_callbacksMenusChanged.Dispatch()),
            s
          );
        }
        get OnMenusChanged() {
          return this.m_callbacksMenusChanged;
        }
        HideActiveMenu() {
          this.m_ActiveMenu?.options.bRetainOnHide
            ? this.m_setHiddenMenus.add(this.m_ActiveMenu)
            : this.m_rgActiveSubmenus.length && (this.m_rgActiveSubmenus = []),
            (this.m_ActiveMenu = void 0);
        }
        get ActiveMenu() {
          return this.m_ActiveMenu;
        }
        GetVisibleMenus() {
          return this.m_ActiveMenu
            ? [this.m_ActiveMenu, ...this.m_rgActiveSubmenus]
            : [];
        }
        GetHiddenMenus() {
          return Array.from(this.m_setHiddenMenus);
        }
        GetAllMenus() {
          let e;
          return (
            (e = this.m_ActiveMenu
              ? [
                  this.m_ActiveMenu,
                  ...this.m_rgActiveSubmenus,
                  ...Array.from(this.m_setHiddenMenus),
                ]
              : [
                  ...this.m_rgActiveSubmenus,
                  ...Array.from(this.m_setHiddenMenus),
                ]),
            e.sort((e, t) => e.key - t.key)
          );
        }
        BShouldRenderMouseOverlay() {
          return (
            this.m_ActiveMenu && !this.m_ActiveMenu.options.bDisableMouseOverlay
          );
        }
        ShowMenu(e) {
          if (e.BIsSubMenu()) this.m_rgActiveSubmenus.push(e);
          else {
            if (e == this.m_ActiveMenu) return;
            this.m_ActiveMenu &&
              (this.m_ActiveMenu.options.bRetainOnHide &&
                this.m_setHiddenMenus.add(this.m_ActiveMenu),
              this.m_ActiveMenu.Hide()),
              (this.m_ActiveMenu = e),
              this.m_setHiddenMenus.delete(e);
          }
          this.m_callbacksMenusChanged.Dispatch();
        }
        HideMenu(e) {
          e.BIsSubMenu()
            ? Jt.x9(this.m_rgActiveSubmenus, e) &&
              this.m_callbacksMenusChanged.Dispatch()
            : ((0, ie.wT)(e == this.m_ActiveMenu, "Call to hide inactive menu"),
              e == this.m_ActiveMenu &&
                (this.HideActiveMenu(),
                this.m_callbacksMenusChanged.Dispatch()));
        }
        ReleaseHiddenMenu(e) {
          this.m_setHiddenMenus.delete(e);
        }
      }
      const en = new (class {
        m_mapManagers = new WeakMap();
        GetContextMenuManagerFromWindow(e) {
          let t = e?.ownerDocument?.defaultView || window;
          return this.GetContextMenuManager(t);
        }
        GetContextMenuManager(e) {
          let t = this.m_mapManagers.get(e);
          if (!t) {
            let n = e;
            for (; !t && n.opener; )
              (n = n.opener), (t = this.m_mapManagers.get(n));
          }
          return t || ((t = new Zt()), this.m_mapManagers.set(e, t)), t;
        }
        SetMenuManager(e, t) {
          (0, ie.wT)(
            void 0 === this.m_mapManagers.get(e) || !t || e == window,
            `Stomping CContextMenuManager for ${e.document.title}!`,
          ),
            this.m_mapManagers.set(e, t);
        }
        RegisterChildWindow(e, t) {
          return (
            this.m_mapManagers.set(t, this.GetContextMenuManager(e)),
            () => this.m_mapManagers.delete(t)
          );
        }
      })();
      var tn, nn, on, sn;
      !(function (e) {
        (e[(e.EBrowserType_OffScreen = 0)] = "EBrowserType_OffScreen"),
          (e[(e.EBrowserType_OpenVROverlay = 1)] =
            "EBrowserType_OpenVROverlay"),
          (e[(e.EBrowserType_OpenVROverlay_Dashboard = 2)] =
            "EBrowserType_OpenVROverlay_Dashboard"),
          (e[(e.EBrowserType_DirectHWND = 3)] = "EBrowserType_DirectHWND"),
          (e[(e.EBrowserType_DirectHWND_Borderless = 4)] =
            "EBrowserType_DirectHWND_Borderless"),
          (e[(e.EBrowserType_ChildHWNDNative = 6)] =
            "EBrowserType_ChildHWNDNative"),
          (e[(e.EBrowserType_Offscreen_SteamUI = 12)] =
            "EBrowserType_Offscreen_SteamUI"),
          (e[(e.EBrowserType_OpenVROverlay_Subview = 13)] =
            "EBrowserType_OpenVROverlay_Subview");
      })(tn || (tn = {})),
        (function (e) {
          (e[(e.SystemKey0 = 0)] = "SystemKey0"),
            (e[(e.SystemKey1 = 1)] = "SystemKey1");
        })(nn || (nn = {})),
        (function (e) {
          (e[(e.Hidden = 0)] = "Hidden"),
            (e[(e.Notification = 1)] = "Notification"),
            (e[(e.Overlay = 2)] = "Overlay"),
            (e[(e.Opaque = 3)] = "Opaque"),
            (e[(e.OverlayKeyboard = 4)] = "OverlayKeyboard");
        })(on || (on = {})),
        (function (e) {
          (e[(e.MainGamepadUI = 0)] = "MainGamepadUI"),
            (e[(e.OverlayGamepadUI = 1)] = "OverlayGamepadUI"),
            (e[(e.Keyboard = 2)] = "Keyboard"),
            (e[(e.ControllerConfigurator = 3)] = "ControllerConfigurator"),
            (e[(e.VR = 4)] = "VR"),
            (e[(e.MainDesktopUI = 5)] = "MainDesktopUI"),
            (e[(e.DesktopLogin = 6)] = "DesktopLogin"),
            (e[(e.OverlayDesktopUI = 7)] = "OverlayDesktopUI"),
            (e[(e.SteamChinaReviewLauncher = 8)] = "SteamChinaReviewLauncher");
        })(sn || (sn = {}));
      const rn = { m_unPID: 0, m_nBrowserID: -1 };
      class an {
        m_fnRender;
        m_rgLoadingLinks = [];
        constructor(e, t, n) {
          if (((this.m_rgLoadingLinks = []), n))
            for (let e = 0; e < n.length; e++) this.AddLink(n[e], !0);
          else if (e) {
            let t = e.getElementsByTagName("link");
            for (let e = 0; e < t.length; e++) {
              let n = t[e];
              this.AddLink(n, !1);
            }
          }
        }
        AddLink(e, t) {
          if (t) {
            let t = !1;
            try {
              (e.sheet && e.sheet.cssRules && 0 != e.sheet.cssRules.length) ||
                (t = !0);
            } catch (e) {}
            t &&
              (e.addEventListener("load", this.OnLinkLoad),
              this.m_rgLoadingLinks.push(e));
          } else
            e.addEventListener("load", this.OnLinkLoad),
              this.m_rgLoadingLinks.push(e);
        }
        SetTarget(e) {
          (this.m_fnRender = e),
            0 == this.m_rgLoadingLinks.length &&
              (this.m_fnRender(), (this.m_fnRender = void 0));
        }
        OnLinkLoad(e) {
          e.currentTarget.removeEventListener("load", this.OnLinkLoad),
            Jt.x9(this.m_rgLoadingLinks, e.currentTarget),
            0 == this.m_rgLoadingLinks.length &&
              (this.m_fnRender?.(), (this.m_fnRender = void 0));
        }
      }
      (0, i.Cg)([B.o], an.prototype, "OnLinkLoad", null);
      new Set([
        "sc_schinese",
        "schinese",
        "tchinese",
        "japanese",
        "koreana",
        "thai",
        "arabic",
        "bulgarian",
        "czech",
        "danish",
        "german",
        "english",
        "spanish",
        "latam",
        "greek",
        "french",
        "italian",
        "indonesian",
        "hungarian",
        "dutch",
        "norwegian",
        "polish",
        "portuguese",
        "brazilian",
        "romanian",
        "russian",
        "finnish",
        "swedish",
        "turkish",
        "vietnamese",
        "ukrainian",
      ]);
      const ln = new Map([
        ["en", "english"],
        ["de", "german"],
        ["fr", "french"],
        ["it", "italian"],
        ["ko", "koreana"],
        ["es-419", "latam"],
        ["es", "spanish"],
        ["zh", "schinese"],
        ["zh-cn", "schinese"],
        ["zh-tw", "tchinese"],
        ["ru", "russian"],
        ["ar", "arabic"],
        ["th", "thai"],
        ["ja", "japanese"],
        ["pt-br", "brazilian"],
        ["pt", "portuguese"],
        ["pl", "polish"],
        ["da", "danish"],
        ["nl", "dutch"],
        ["fi", "finnish"],
        ["nb", "norwegian"],
        ["no", "norwegian"],
        ["sv", "swedish"],
        ["hu", "hungarian"],
        ["cs", "czech"],
        ["ro", "romanian"],
        ["tr", "turkish"],
        ["bg", "bulgarian"],
        ["el", "greek"],
        ["uk", "ukrainian"],
        ["vn", "vietnamese"],
        ["vi", "vietnamese"],
        ["id", "indonesian"],
      ]);
      const cn = new Map();
      for (const [e, t] of ln.entries()) cn.set(t, e);
      var un, dn;
      function mn() {
        return (0, Tt.td)() ? un.Composited : un.None;
      }
      function hn(e) {
        let t = un.None;
        switch (e) {
          case dn.Overlay:
            return (
              (t |= un.AlwaysOnTop),
              (t |= un.NoTaskbarIcon),
              (t |= un.NotFocusable),
              (t |= un.TransparentParentWindow),
              t
            );
          case dn.Notification:
            return (
              (t |= hn(dn.Overlay)),
              (t |= un.NoWindowShadow),
              (t |= un.NoRoundedCorners),
              (t |= un.OverrideRedirect),
              (t |= un.ForceBrowserVisible),
              t
            );
          case dn.Tooltip:
            return (
              (t |= hn(dn.Overlay)),
              (t |= un.NoRoundedCorners),
              (t |= un.NoWindowShadow),
              (t |= un.TooltipHint),
              (t |= mn()),
              t
            );
          case dn.PopupContextMenu:
            return (
              (t |= un.NoTaskbarIcon),
              (t |= un.NoRoundedCorners),
              (t |= un.NoWindowShadow),
              (t |= un.PopUpMenuHint),
              (t |= un.TransparentParentWindow),
              (t |= mn()),
              t
            );
          case dn.StandaloneContextMenu:
            return (
              (t = un.NoTaskbarIcon),
              (t |= un.NoRoundedCorners),
              (t |= un.NoWindowShadow),
              (t |= un.OverrideRedirect),
              (t |= un.TransparentParentWindow),
              (t |= mn()),
              t
            );
        }
      }
      cn.set("sc_schinese", cn.get("schinese")),
        cn.set("korean", cn.get("koreana")),
        (function (e) {
          (e[(e.None = 0)] = "None"),
            (e[(e.Minimized = 1)] = "Minimized"),
            (e[(e.Hidden = 2)] = "Hidden"),
            (e[(e.TooltipHint = 4)] = "TooltipHint"),
            (e[(e.NoTaskbarIcon = 8)] = "NoTaskbarIcon"),
            (e[(e.Resizable = 16)] = "Resizable"),
            (e[(e.ScalePosition = 32)] = "ScalePosition"),
            (e[(e.ScaleSize = 64)] = "ScaleSize"),
            (e[(e.Maximized = 128)] = "Maximized"),
            (e[(e.Composited = 256)] = "Composited"),
            (e[(e.NotFocusable = 512)] = "NotFocusable"),
            (e[(e.FullScreen = 1024)] = "FullScreen"),
            (e[(e.Fullscreen_Exclusive = 2048)] = "Fullscreen_Exclusive"),
            (e[(e.ApplyBrowserScaleToDimensions = 4096)] =
              "ApplyBrowserScaleToDimensions"),
            (e[(e.AlwaysOnTop = 8192)] = "AlwaysOnTop"),
            (e[(e.NoWindowShadow = 16384)] = "NoWindowShadow"),
            (e[(e.NoMinimize = 32768)] = "NoMinimize"),
            (e[(e.PopUpMenuHint = 65536)] = "PopUpMenuHint"),
            (e[(e.IgnoreSavedSize = 131072)] = "IgnoreSavedSize"),
            (e[(e.NoRoundedCorners = 262144)] = "NoRoundedCorners"),
            (e[(e.ForceRoundedCorners = 524288)] = "ForceRoundedCorners"),
            (e[(e.OverrideRedirect = 1048576)] = "OverrideRedirect"),
            (e[(e.IgnoreSteamDisplayScale = 2097152)] =
              "IgnoreSteamDisplayScale"),
            (e[(e.TransparentParentWindow = 4194304)] =
              "TransparentParentWindow"),
            (e[(e.DisableDPIScale = 8388608)] = "DisableDPIScale"),
            (e[(e.ForceBrowserVisible = 16777216)] = "ForceBrowserVisible");
        })(un || (un = {})),
        (function (e) {
          (e[(e.Overlay = 0)] = "Overlay"),
            (e[(e.Notification = 1)] = "Notification"),
            (e[(e.Tooltip = 2)] = "Tooltip"),
            (e[(e.PopupContextMenu = 3)] = "PopupContextMenu"),
            (e[(e.StandaloneContextMenu = 4)] = "StandaloneContextMenu");
        })(dn || (dn = {}));
      const pn = c.createContext({ ownerWindow: window }),
        _n = () => c.useContext(pn);
      function gn(e) {
        const { ownerWindow: t, children: n } = e,
          o = c.useMemo(() => ({ ownerWindow: t }), [t]);
        return c.createElement(pn.Provider, { value: o }, n);
      }
      class fn {
        m_strName;
        m_strTitle;
        m_rgParams;
        m_popup;
        m_element;
        m_renderWhenReady;
        m_bCreateHidden;
        m_bCreated = !1;
        m_onCreateRender = null;
        m_bFocused = !1;
        constructor(e, t) {
          (0, f.Gn)(this),
            (0, ie.wT)(
              e,
              "Name is required.  This is an internal name, different from title.",
            ),
            (this.m_strName = e);
          const { title: n, eCreationFlags: o, ...i } = t;
          (this.m_rgParams = { ...i, eCreationFlags: o ?? 0 }),
            this.m_rgParams.target_browser &&
              (this.m_strName +=
                "_uid" + this.m_rgParams.target_browser.m_unPID),
            (this.m_bCreateHidden = !!(
              this.m_rgParams.eCreationFlags & un.Hidden
            )),
            (this.m_strTitle = n);
        }
        UpdateParamsBeforeShow(e) {
          return e;
        }
        OnDrop(e) {
          console.log("Ignoring drop onto toplevel window", e),
            e.preventDefault(),
            e.stopPropagation();
        }
        OnDragOver(e) {
          e.preventDefault(),
            (e.dataTransfer.dropEffect = "none"),
            e.stopPropagation();
        }
        OnMessage(e) {
          "window_moved" === e.data && this.OnMove(),
            "window_resized" === e.data && this.OnResize(),
            "popup-created" === e.data && this.OnCreateInternal();
        }
        Show(e = qt.iE.k_EWindowBringToFrontAndForceOS) {
          let t;
          (t =
            "boolean" == typeof e
              ? e
                ? qt.iE.k_EWindowBringToFrontAndForceOS
                : qt.iE.k_EWindowBringToFrontInvalid
              : e),
            window.SteamClient && (this.m_rgParams.eCreationFlags |= un.Hidden),
            this.m_rgParams.eCreationFlags & un.NotFocusable &&
              (t = qt.iE.k_EWindowBringToFrontInvalid),
            this.BIsValid() &&
              (this.BIsClosed()
                ? ((this.m_popup = void 0), (this.m_element = void 0))
                : t != qt.iE.k_EWindowBringToFrontInvalid && this.Focus(t));
          let n,
            o,
            i,
            s = En.GetExistingPopup(this.m_strName);
          (s && !this.m_rgParams.replace_existing_popup) ||
            ((this.m_rgParams = this.UpdateParamsBeforeShow(this.m_rgParams)),
            s
              ? ((o = s.m_element),
                (n = s.m_popup),
                (i = s.m_renderWhenReady),
                En.RemoveTrackedPopup(s),
                s.ReleasePopup(),
                n?.removeEventListener("beforeunload", s.OnBeforeUnloadEvent),
                n?.removeEventListener("unload", s.OnUnload),
                n?.removeEventListener("resize", s.OnResizeEvent),
                n?.removeEventListener("focus", this.OnFocusInternal),
                n?.removeEventListener("blur", this.OnBlurInternal),
                n?.removeEventListener("drop", s.OnDrop),
                n?.removeEventListener("dragover", s.OnDragOver),
                n?.removeEventListener("message", this.OnMessage))
              : (({ popup: n, element: o } = bn.CreatePopup(this.m_strName, {
                  ...this.m_rgParams,
                  title: this.m_strTitle,
                })),
                (i = new an(n?.document, o))),
            n &&
              o &&
              ((n.document.title = this.m_strTitle),
              n.addEventListener("beforeunload", this.OnBeforeUnloadEvent),
              n.addEventListener("unload", this.OnUnload),
              n.addEventListener("resize", this.OnResizeEvent),
              n.addEventListener("focus", this.OnFocusInternal),
              n.addEventListener("blur", this.OnBlurInternal),
              n.addEventListener("drop", this.OnDrop),
              n.addEventListener("dragover", this.OnDragOver),
              n.addEventListener("message", this.OnMessage),
              Tt.TS.LANGUAGE &&
                (n.document.documentElement.setAttribute(
                  "lang",
                  (0, Nt.l4)() ?? "",
                ),
                "arabic" === Tt.TS.LANGUAGE &&
                  n.document.documentElement.setAttribute("dir", "rtl")),
              (this.m_popup = n),
              (this.m_element = o),
              (this.m_renderWhenReady = i),
              this.m_renderWhenReady?.SetTarget(() => {
                this.m_popup &&
                  this.m_element &&
                  this.RenderInternal(this.m_popup, this.m_element, t);
              })),
            En.AddTrackedPopup(this),
            s &&
              (this.OnCreateInternal(),
              t != qt.iE.k_EWindowBringToFrontInvalid && this.Focus(t)));
        }
        RemoveEventListeners() {
          this.window?.removeEventListener(
            "beforeunload",
            this.OnBeforeUnloadEvent,
          ),
            this.window?.removeEventListener("unload", this.OnUnload),
            this.window?.removeEventListener("resize", this.OnResizeEvent),
            this.window?.removeEventListener("focus", this.OnFocusInternal),
            this.window?.removeEventListener("blur", this.OnBlurInternal),
            this.window?.removeEventListener("drop", this.OnDrop),
            this.window?.removeEventListener("dragover", this.OnDragOver),
            this.window?.removeEventListener("message", this.OnMessage);
        }
        RenderInternal(e, t, n) {
          var o;
          this.m_bCreated
            ? (this.browser_info &&
                ((o = this.browser_info.m_eBrowserType) ==
                  tn.EBrowserType_OpenVROverlay ||
                  o == tn.EBrowserType_OpenVROverlay_Dashboard ||
                  o == tn.EBrowserType_OpenVROverlay_Subview) &&
                (t.ownerDocument.body.className += " VR"),
              this.Render(e, t),
              this.OnLoad(),
              e?.SteamClient &&
                !this.m_bCreateHidden &&
                (n != qt.iE.k_EWindowBringToFrontInvalid
                  ? e.SteamClient.Window.BringToFront(n)
                  : e.SteamClient.Window.ShowWindow()))
            : (this.m_onCreateRender = () => this.RenderInternal(e, t, n));
        }
        OnCreateInternal() {
          this.m_bCreated ||
            ((this.m_bCreated = !0),
            this.OnCreate(),
            this.m_onCreateRender &&
              (this.m_onCreateRender(), (this.m_onCreateRender = null)));
        }
        OnCreate() {}
        OnResizeEvent() {
          this.OnResize();
        }
        OnBeforeUnloadEvent() {
          this.OnBeforeUnload();
        }
        OnUnload(e) {
          this.RemoveEventListeners(),
            En.RemoveTrackedPopup(this),
            this.OnClose(),
            (this.m_popup = void 0);
        }
        get browser_info() {
          return this.m_rgParams.target_browser;
        }
        get window() {
          return this.m_popup;
        }
        get root_element() {
          return this.m_element;
        }
        get title() {
          return this.m_strTitle;
        }
        set title(e) {
          (this.m_strTitle = e),
            this.m_popup && (this.m_popup.document.title = this.m_strTitle);
        }
        get params() {
          return this.m_rgParams;
        }
        Focus(e = qt.iE.k_EWindowBringToFrontAndForceOS) {
          e != qt.iE.k_EWindowBringToFrontInvalid &&
            (this.m_popup &&
            void 0 !== this.m_popup.SteamClient &&
            void 0 !== this.m_popup.SteamClient.Window
              ? this.m_popup.SteamClient.Window.BringToFront(e)
              : this.m_popup && this.m_popup.focus());
        }
        Close() {
          this.m_popup &&
            (Mt(this.m_popup.window, "Window.Close")
              ? this.m_popup.window.SteamClient.Window.Close()
              : this.m_popup.window.close());
        }
        GetName() {
          return this.m_strName;
        }
        BIsValid() {
          return !!this.m_popup;
        }
        BIsClosed() {
          return !this.m_popup || this.m_popup.closed;
        }
        BIsVisible() {
          return !(
            !this.m_popup ||
            this.m_popup.closed ||
            "visible" != this.m_popup.document.visibilityState
          );
        }
        BIsFocused() {
          return this.BIsVisible() && !!this.m_popup?.document.hasFocus();
        }
        OnFocusInternal() {
          this.m_popup &&
            this.m_popup.document.body.classList.add("WindowFocus"),
            (this.m_bFocused = !0),
            this.OnFocus();
        }
        OnBlurInternal() {
          this.m_popup &&
            this.m_popup.document.body.classList.remove("WindowFocus"),
            (this.m_bFocused = !1),
            this.OnBlur();
        }
        get focused() {
          return this.m_bFocused;
        }
        GetWindowRestoreDetails() {
          return Mt(this.m_popup, "Window.GetWindowRestoreDetails") &&
            !this.m_popup.closed
            ? this.m_popup.SteamClient.Window.GetWindowRestoreDetails()
            : Promise.resolve("");
        }
        IsMinimized() {
          return Mt(this.m_popup, "Window.IsWindowMinimized") &&
            !this.m_popup.closed
            ? this.m_popup.SteamClient.Window.IsWindowMinimized()
            : Promise.resolve(!1);
        }
        IsMaximized() {
          return Mt(this.m_popup, "Window.IsWindowMaximized") &&
            !this.m_popup.closed
            ? this.m_popup.SteamClient.Window.IsWindowMaximized()
            : Promise.resolve(!1);
        }
        ReleasePopup() {
          this.OnClose(), (this.m_popup = null);
        }
        OnMove() {}
        OnResize() {
          this.IsMaximized().then((e) => {
            e
              ? this.m_popup?.document.body.classList.add("Maximized")
              : this.m_popup?.document.body.classList.remove("Maximized");
          });
        }
        OnBeforeUnload() {}
        OnFocus() {}
        OnBlur() {}
      }
      (0, i.Cg)([f.sH], fn.prototype, "m_bFocused", void 0),
        (0, i.Cg)([B.o], fn.prototype, "OnMessage", null),
        (0, i.Cg)([B.o], fn.prototype, "RenderInternal", null),
        (0, i.Cg)([B.o], fn.prototype, "OnCreateInternal", null),
        (0, i.Cg)([B.o], fn.prototype, "OnResizeEvent", null),
        (0, i.Cg)([B.o], fn.prototype, "OnBeforeUnloadEvent", null),
        (0, i.Cg)([B.o], fn.prototype, "OnUnload", null),
        (0, i.Cg)([B.o], fn.prototype, "OnFocusInternal", null),
        (0, i.Cg)([B.o], fn.prototype, "OnBlurInternal", null);
      (0, i.Cg)(
        [B.o],
        class extends fn {
          m_strSavedDimensionsKey;
          m_strInitialSavedDimensionsKey;
          m_strInitialRestoreDetails;
          m_bExpires;
          constructor(e, t, n, o) {
            super(e, n), this.SetSavedDimensionsKey(t), (this.m_bExpires = o);
          }
          BIsInOverlay() {
            return (
              this.browser_info &&
              0 != this.browser_info.m_unPID &&
              -1 != this.browser_info.m_nBrowserID
            );
          }
          SetSavedDimensionsKey(e) {
            this.m_strSavedDimensionsKey = e;
          }
          UpdateParamsBeforeShow(e) {
            return (
              !this.m_strSavedDimensionsKey ||
              e.bIgnoreSavedDimensions ||
              e.strRestoreDetails
                ? e.strRestoreDetails &&
                  ((this.m_strInitialSavedDimensionsKey =
                    this.GetSavedDimensionsKey()),
                  En.SetRestoreDetails(
                    this.m_strInitialSavedDimensionsKey,
                    e.strRestoreDetails,
                    this.m_bExpires,
                  ))
                : ((this.m_strInitialSavedDimensionsKey =
                    this.GetSavedDimensionsKey()),
                  (e.strRestoreDetails = En.GetRestoreDetails(
                    this.m_strInitialSavedDimensionsKey,
                  ))),
              e
            );
          }
          OnLoad() {
            this.GetWindowRestoreDetails().then((e) => {
              (this.m_strInitialRestoreDetails = e), this.OnResizeComplete(e);
            });
          }
          OnMove() {
            super.OnMove(), this.QueryAndStoreWindowPosition();
          }
          OnResize() {
            super.OnResize(), this.QueryAndStoreWindowPosition();
          }
          OnResizeComplete(e) {}
          QueryAndStoreWindowPosition() {
            if (this.m_strInitialRestoreDetails) {
              let e = this.GetSavedDimensionsKey();
              this.m_popup?.setTimeout(() => {
                this.GetWindowRestoreDetails().then((t) => {
                  let n =
                    this.m_rgParams.strRestoreDetails == t &&
                    e == this.m_strInitialSavedDimensionsKey;
                  this.m_popup &&
                    this.m_strSavedDimensionsKey &&
                    t &&
                    !n &&
                    (En.SetRestoreDetails(e, t, this.m_bExpires),
                    (this.m_rgParams.strRestoreDetails = t),
                    (this.m_strInitialSavedDimensionsKey = e),
                    this.OnResizeComplete(t));
                });
              }, 30);
            }
          }
          OnBeforeUnload() {
            this.QueryAndStoreWindowPosition(), super.OnBeforeUnload();
          }
          OnClose() {}
          SaveWindowPosition(e) {
            En.SetRestoreDetails(this.GetSavedDimensionsKey(), e, !1),
              (this.m_rgParams.strRestoreDetails = e);
          }
        }.prototype,
        "QueryAndStoreWindowPosition",
        null,
      );
      class bn {
        m_bShuttingDown = !1;
        m_mapPopups = f.sH.map([], { deep: !1 });
        m_rgShutdownCallbacks = [];
        m_rgPopupCreatedCallbacks = new U.l();
        m_rgPopupDestroyedCallbacks = new U.l();
        m_unCurrentAccountID = 0;
        m_mapRestoreDetails = new Map();
        m_bSaveRequired = !1;
        m_DynamicCSSObserver;
        constructor() {
          if (
            !{ NODE_ENV: "production", STEAM_BUILD: "buildbot" }.MOBILE_BUILD &&
            "addEventListener" in window
          ) {
            window.addEventListener("beforeunload", (e) => {
              this.m_bShuttingDown = !0;
              for (let e of this.m_rgShutdownCallbacks) e();
              let t = [];
              this.m_mapPopups.forEach((e) => {
                e.BIsValid() && !e.BIsClosed() && t.push(e);
              });
              for (let e of t)
                e.window?.SteamClient.Browser
                  ?.SetShouldExitSteamOnBrowserClosed &&
                  e.window.SteamClient.Browser.SetShouldExitSteamOnBrowserClosed(
                    !1,
                  ),
                  e.window?.SteamClient.Window.SetHideOnClose &&
                    e.window?.SteamClient.Window.SetHideOnClose(!1),
                  e.Close();
              this.m_bSaveRequired && this.SaveSavedDimensionStore(),
                this.m_mapPopups.clear();
            });
            let e = document.querySelector("head");
            (0, ie.wT)(e, "Couldn't find head element"),
              e &&
                ((this.m_DynamicCSSObserver = new MutationObserver(() => {
                  const e = C();
                  this.m_mapPopups.forEach((t) => {
                    v(t.window.document, e, !1);
                  });
                })),
                this.m_DynamicCSSObserver.observe(e, { childList: !0 }));
          }
        }
        BAnyPopupHasFocus() {
          for (const e of this.m_mapPopups.values()) if (e.focused) return !0;
          return !1;
        }
        BAnyMenuHasFocus() {
          for (const e of this.m_mapPopups.values())
            if (e.focused && (e.params.eCreationFlags ?? 0) & un.NoTaskbarIcon)
              return !0;
          return !1;
        }
        SetCurrentLoggedInAccountID(e) {
          this.m_unCurrentAccountID != e &&
            ((this.m_unCurrentAccountID = e),
            e
              ? this.LoadSavedDimensionStore()
              : this.ClearSavedDimensionStore());
        }
        AddShutdownCallback(e) {
          this.m_rgShutdownCallbacks.push(e);
        }
        AddPopupCreatedCallback(e) {
          return this.m_rgPopupCreatedCallbacks.Register(e);
        }
        AddPopupDestroyedCallback(e) {
          return this.m_rgPopupDestroyedCallbacks.Register(e);
        }
        AddTrackedPopup(e) {
          this.m_mapPopups.set(e.GetName(), e),
            e.BIsValid() && this.m_rgPopupCreatedCallbacks.Dispatch(e);
        }
        RemoveTrackedPopup(e) {
          this.m_rgPopupDestroyedCallbacks.Dispatch(e),
            this.m_mapPopups.delete(e.GetName());
        }
        GetExistingPopup(e) {
          return this.m_mapPopups.get(e);
        }
        GetPopups() {
          return this.m_mapPopups.values();
        }
        GetPopupForWindow(e) {
          for (const t of this.m_mapPopups.values())
            if (t.window === e) return t;
        }
        ClosePopupsOwnedByBrowser(e) {
          this.m_mapPopups.forEach((t) => {
            t.browser_info &&
              t.browser_info.m_nBrowserID == e.m_nBrowserID &&
              t.browser_info.m_unPID == e.m_unPID &&
              t.Close();
          });
        }
        static CreatePopup(e, t) {
          let n = t.dimensions || {},
            o = n.width || 300,
            i = n.height || 300,
            s = t.title,
            r = "width=" + o + ",height=" + i;
          void 0 !== n.left && (r += ",left=" + n.left),
            void 0 !== n.top && (r += ",top=" + n.top),
            (r += ",resizeable,status=0,toolbar=0,menubar=0,location=0");
          let a = "about:blank",
            l = [];
          l.push("createflags=" + t.eCreationFlags),
            t.minWidth && l.push("minwidth=" + t.minWidth),
            t.minHeight && l.push("minheight=" + t.minHeight),
            t.maxWidth &&
              t.maxWidth != 1 / 0 &&
              l.push("maxwidth=" + t.maxWidth),
            t.maxHeight &&
              t.maxHeight != 1 / 0 &&
              l.push("maxheight=" + t.maxHeight),
            t.target_browser
              ? (l.push("pid=" + t.target_browser.m_unPID),
                l.push("browser=" + t.target_browser.m_nBrowserID),
                t.target_browser.m_eBrowserType
                  ? l.push("browserType=" + t.target_browser.m_eBrowserType)
                  : t.browserType && l.push("browserType=" + t.browserType),
                t.availscreenwidth &&
                  t.availscreenheight &&
                  (l.push("screenavailwidth=" + t.availscreenwidth),
                  l.push("screenavailheight=" + t.availscreenheight)))
              : t.browserType && l.push("browserType=" + t.browserType),
            t.strVROverlayKey && l.push("vrOverlayKey=" + t.strVROverlayKey),
            t.strRestoreDetails &&
              l.push("restoredetails=" + t.strRestoreDetails),
            t.window_opener_id && l.push("openerid=" + t.window_opener_id),
            t.parent_container_popup_id &&
              l.push("parentcontainerpopupid=" + t.parent_container_popup_id),
            t.center_on_window &&
              void 0 === n.left &&
              void 0 === n.top &&
              l.push(
                "centerOnBrowserID=" +
                  t.center_on_window.SteamClient.Browser.GetBrowserID(),
              ),
            t.strUserAgent && l.push("useragent=" + t.strUserAgent),
            t.hwndParent && l.push("hwndParent=" + t.hwndParent),
            t.bPinned && l.push("pinned=true"),
            t.bModal && l.push("modal=true"),
            l && (a += "?" + l.join("&"));
          let c = (t.owner_window || window).open(a, e, r);
          if (!c)
            return (
              console.error(
                `Failed to create popup, browser/CEF may be blocking popups for "${window.location.origin}"`,
              ),
              {}
            );
          let u = "";
          t.html_class && (u = `class="${t.html_class}"`);
          let d = "";
          t.body_class && (d = `class="${t.body_class}"`);
          let m = "";
          t.body_role && (m = `role="${t.body_role}"`);
          let h = "";
          t.popup_class && (h = `class="${t.popup_class}"`);
          let p = `<!DOCTYPE html><html ${u}><head><title></title></head><body ${d} ${m}><div id="popup_target" ${h}></div></body></html>`;
          var _, g;
          return (
            c.document.write(p),
            (c.document.title = s),
            c.document.close(),
            (_ = c),
            (g = C()),
            v(_.document, g, !0),
            { popup: c, element: c.document.getElementById("popup_target") }
          );
        }
        BShuttingDown() {
          return this.m_bShuttingDown;
        }
        GetLocalStorageKey() {
          return "PopupSavedDimensions_" + this.m_unCurrentAccountID;
        }
        LoadSavedDimensionStore() {
          if (!this.m_unCurrentAccountID) return;
          let e = this.GetLocalStorageKey();
          this.m_mapRestoreDetails.clear();
          let t = window.localStorage.getItem(e);
          if (t)
            try {
              let e = JSON.parse(t);
              this.m_mapRestoreDetails = new Map(e);
            } catch (e) {}
        }
        SaveSavedDimensionStore() {
          if (!this.m_unCurrentAccountID || !this.m_bSaveRequired) return;
          let e = this.GetLocalStorageKey(),
            t = JSON.stringify(Array.from(this.m_mapRestoreDetails));
          try {
            window.localStorage.setItem(e, t), (this.m_bSaveRequired = !1);
          } catch (n) {
            if ("name" in n && "QuotaExceededError" == n.name) {
              console.log("Quota exceeded");
              for (let t of Object.keys(window.localStorage))
                t.startsWith("PopupSavedDimensions_") &&
                  t != e &&
                  window.localStorage.removeItem(t);
              window.localStorage.setItem(e, t), (this.m_bSaveRequired = !1);
            }
          }
        }
        DebouncedSaveSavedDimensionStore() {
          this.SaveSavedDimensionStore();
        }
        ClearSavedDimensionStore() {
          this.m_mapRestoreDetails?.clear(), (this.m_bSaveRequired = !1);
        }
        GetRestoreDetails(e) {
          if (!this.m_mapRestoreDetails?.has(e)) return "";
          let t = this.m_mapRestoreDetails.get(e);
          return (
            (t.last_used = Date.now()),
            (this.m_bSaveRequired = !0),
            t.strRestoreDetails
          );
        }
        SetRestoreDetails(e, t, n) {
          if (e) {
            if (t) {
              if (this.m_mapRestoreDetails.size > 50) {
                let e = null,
                  t = Date.now();
                for (let n of Array.from(this.m_mapRestoreDetails.keys())) {
                  let o = this.m_mapRestoreDetails.get(n);
                  o.last_used < t && o.bExpires && ((t = o.last_used), (e = n));
                }
                e && this.m_mapRestoreDetails.delete(e);
              }
              let o = {
                strRestoreDetails: t,
                last_used: Date.now(),
                bExpires: n,
              };
              this.m_mapRestoreDetails.set(e, o);
            } else this.m_mapRestoreDetails.delete(e);
            (this.m_bSaveRequired = !0),
              this.m_bShuttingDown
                ? this.SaveSavedDimensionStore()
                : this.DebouncedSaveSavedDimensionStore();
          }
        }
      }
      (0, i.Cg)(
        [B.o, Lt(100)],
        bn.prototype,
        "DebouncedSaveSavedDimensionStore",
        null,
      );
      const En = new bn();
      window.g_PopupManager = En;
      const Sn = c.createContext(null);
      function Cn(e) {
        const {
            refContextMenuManager: t,
            bRegisterMenuManager: n = !0,
            children: o,
          } = e,
          i = _n(),
          s = i?.ownerWindow || window,
          r = c.useRef(void 0);
        return (
          r.current || (r.current = new Zt()),
          c.useLayoutEffect(() => {
            if (n)
              return (
                en.SetMenuManager(s, r.current),
                () => en.SetMenuManager(s, void 0)
              );
          }, [s, n]),
          c.useLayoutEffect(() => (h(t, r.current), () => h(t, void 0)), [t]),
          c.createElement(Sn.Provider, { value: r.current }, o)
        );
      }
      const vn = c.createContext({ body_class: "" });
      function wn() {
        return c.useContext(vn);
      }
      var Mn;
      !(function (e) {
        (e[(e.k_EAccountFlagNormalUser = 0)] = "k_EAccountFlagNormalUser"),
          (e[(e.k_EAccountFlagPersonaNameSet = 1)] =
            "k_EAccountFlagPersonaNameSet"),
          (e[(e.k_EAccountFlagUnbannable = 2)] = "k_EAccountFlagUnbannable"),
          (e[(e.k_EAccountFlagPasswordSet = 4)] = "k_EAccountFlagPasswordSet"),
          (e[(e.k_EAccountFlagSupport = 8)] = "k_EAccountFlagSupport"),
          (e[(e.k_EAccountFlagAdmin = 16)] = "k_EAccountFlagAdmin"),
          (e[(e.k_EAccountFlagSupervisor = 32)] = "k_EAccountFlagSupervisor"),
          (e[(e.k_EAccountFlagAppEditor = 64)] = "k_EAccountFlagAppEditor"),
          (e[(e.k_EAccountFlagHWIDSet = 128)] = "k_EAccountFlagHWIDSet"),
          (e[(e.k_EAccountFlagVacBeta = 512)] = "k_EAccountFlagVacBeta"),
          (e[(e.k_EAccountFlagDebug = 1024)] = "k_EAccountFlagDebug"),
          (e[(e.k_EAccountFlagDisabled = 2048)] = "k_EAccountFlagDisabled"),
          (e[(e.k_EAccountFlagLimitedUser = 4096)] =
            "k_EAccountFlagLimitedUser"),
          (e[(e.k_EAccountFlagLimitedUserForce = 8192)] =
            "k_EAccountFlagLimitedUserForce"),
          (e[(e.k_EAccountFlagEmailValidated = 16384)] =
            "k_EAccountFlagEmailValidated"),
          (e[(e.k_EAccountFlagValveEmail = 32768)] =
            "k_EAccountFlagValveEmail"),
          (e[(e.k_EAccountFlagForcePasswordChange = 131072)] =
            "k_EAccountFlagForcePasswordChange"),
          (e[(e.k_EAccountFlagLogonExtraSecurity = 524288)] =
            "k_EAccountFlagLogonExtraSecurity"),
          (e[(e.k_EAccountFlagLogonExtraSecurityDisabled = 1048576)] =
            "k_EAccountFlagLogonExtraSecurityDisabled"),
          (e[(e.k_EAccountFlagSteam2MigrationComplete = 2097152)] =
            "k_EAccountFlagSteam2MigrationComplete"),
          (e[(e.k_EAccountFlagNeedLogs = 4194304)] = "k_EAccountFlagNeedLogs"),
          (e[(e.k_EAccountFlagLockdown = 8388608)] = "k_EAccountFlagLockdown"),
          (e[(e.k_EAccountFlagMasterAppEditor = 16777216)] =
            "k_EAccountFlagMasterAppEditor"),
          (e[(e.k_EAccountFlagBannedFromWebAPI = 33554432)] =
            "k_EAccountFlagBannedFromWebAPI"),
          (e[(e.k_EAccountFlagPartnerMember = 67108864)] =
            "k_EAccountFlagPartnerMember"),
          (e[(e.k_EAccountFlagGlobalModerator = 134217728)] =
            "k_EAccountFlagGlobalModerator"),
          (e[(e.k_EAccountFlagParentalSettings = 268435456)] =
            "k_EAccountFlagParentalSettings"),
          (e[(e.k_EAccountFlagThirdPartySupport = 536870912)] =
            "k_EAccountFlagThirdPartySupport"),
          (e[(e.k_EAccountFlagNeedsSSANextSteamLogon = 1073741824)] =
            "k_EAccountFlagNeedsSSANextSteamLogon");
      })(Mn || (Mn = {}));
      Mn.k_EAccountFlagAdmin,
        Mn.k_EAccountFlagSupervisor,
        Mn.k_EAccountFlagSupport,
        Mn.k_EAccountFlagAdmin,
        Mn.k_EAccountFlagSupervisor;
      n(8506);
      function yn(e, t, n) {
        const o = c.useRef(void 0),
          [i, s] = c.useState(void 0),
          r = wn();
        return (
          o.current ||
            (o.current = new In(
              e,
              (function (e, t) {
                return {
                  ...e,
                  body_class: (0, yt.A)(e.body_class, t.body_class),
                };
              })(t, r),
              s,
            )),
          (o.current.m_callbacks = n),
          c.useEffect(() => {
            if (!o.current?.params.bNoInitialShow) {
              let e = o.current?.params.bNoFocusOnShow
                ? qt.iE.k_EWindowBringToFrontWithoutForcingOS
                : qt.iE.k_EWindowBringToFrontAndForceOS;
              o.current?.Show(e);
            }
            return () => {
              (o.current.m_callbacks = void 0),
                o.current.window?.SteamClient.Window.SetHideOnClose &&
                  o.current.window?.SteamClient.Window.SetHideOnClose(!1),
                o.current.Close();
            };
          }, []),
          c.useEffect(() => {
            o.current.window?.SteamClient.Window.SetHideOnClose &&
              o.current.window?.SteamClient.Window.SetHideOnClose(
                !!t.bHideOnClose,
              );
          }, [t.bHideOnClose]),
          { popup: o.current.window, element: i, popupObj: o.current }
        );
      }
      class In extends fn {
        m_callbacks;
        m_fnReadyToRender;
        constructor(e, t, n) {
          super(e, t), (this.m_fnReadyToRender = n);
        }
        DoCallback(e) {
          this.m_callbacks?.[e]?.(this.m_popup, this.m_element);
        }
        UpdateParamsBeforeShow(e) {
          return this.m_callbacks?.updateParamsBeforeShow
            ? this.m_callbacks.updateParamsBeforeShow(e)
            : e;
        }
        OnCreate() {
          this.m_callbacks?.onCreate &&
            this.m_callbacks.onCreate(this.m_popup, this.m_element);
        }
        OnBlur() {
          this.DoCallback("onBlur");
        }
        OnFocus() {
          this.DoCallback("onFocus");
        }
        OnLoad() {
          this.DoCallback("onLoad");
        }
        OnMove() {
          this.DoCallback("onMove");
        }
        OnResize() {
          this.DoCallback("onResize");
        }
        OnClose() {
          this.DoCallback("onClose");
        }
        Render(e, t) {
          this.m_fnReadyToRender(t);
        }
      }
      class Rn extends c.Component {
        state = {};
        constructor(e) {
          super(e), (this.state.lastErrorKey = e.errorKey);
        }
        static sm_ErrorReportingStore;
        static InstallErrorReportingStore(e) {
          this.sm_ErrorReportingStore = e;
        }
        componentDidCatch(e, t) {
          const n = Rn.sm_ErrorReportingStore;
          n
            ? n
                .ReportError(e, {
                  strComponentStack: t.componentStack || void 0,
                })
                .then(
                  (e) =>
                    e && this.setState({ identifierHash: e.identifierHash }),
                )
            : console.warn(
                "No ErrorReportingStore - use ErrorReportingStore().Init() to configure error reporting to server",
              ),
            this.setState({
              error: { error: e, info: t },
              lastErrorKey: this.props.errorKey,
            });
        }
        Reset() {
          this.setState({ error: void 0 });
        }
        render() {
          const { children: e, fallback: t, errorKey: n } = this.props,
            { error: o, identifierHash: i, lastErrorKey: s } = this.state;
          return o && n == s
            ? void 0 !== t
              ? "function" == typeof t
                ? t(o.error)
                : t
              : Rn.sm_ErrorReportingStore &&
                  Rn.sm_ErrorReportingStore.reporting_enabled
                ? c.createElement(Tn, {
                    error: o,
                    identifierHash: i,
                    store: Rn.sm_ErrorReportingStore,
                    onRefresh: this.Reset,
                  })
                : c.createElement(kn, { error: o, onDismiss: this.Reset })
            : e || null;
        }
      }
      (0, i.Cg)([B.o], Rn.prototype, "Reset", null);
      const kn = ({ error: e, onDismiss: t }) => {
          let n = e.error ? e.error.stack : "Stack missing",
            o = e.info ? e.info.componentStack : "",
            i = (e.error && e.error.message) || "unknown error";
          return c.createElement(
            On,
            null,
            c.createElement(An, null, 'Error: "', i, '"'),
            "",
            c.createElement(
              "span",
              {
                style: { textDecoration: "underline", cursor: "pointer" },
                onClick: t,
              },
              "(x) Dismiss",
            ),
            c.createElement("br", null),
            c.createElement(Dn, null, n),
            c.createElement(Dn, null, "The error occurred while rendering:", o),
          );
        },
        Tn = (e) => {
          const { error: t, onRefresh: n, identifierHash: o, store: i } = e,
            s = (t.error && t.error.message) || "unknown error",
            r = `${i.product}_${i.version}_${o}`;
          return c.createElement(
            On,
            null,
            c.createElement(
              An,
              null,
              "Something went wrong while displaying this content. ",
              c.createElement(
                "span",
                {
                  style: { textDecoration: "underline", cursor: "pointer" },
                  onClick: n,
                },
                "Refresh",
              ),
            ),
            c.createElement(Dn, null, "Error Reference: ", r),
            c.createElement(Dn, null, s),
          );
        },
        On = ({ children: e }) =>
          c.createElement(
            "div",
            {
              style: {
                overflow: "auto",
                marginLeft: "15px",
                color: "white",
                fontSize: "16px",
                userSelect: "auto",
                backgroundColor: "black",
              },
              className: "ErrorBoundary",
            },
            e,
          ),
        An = ({ children: e }) =>
          c.createElement(
            "h1",
            {
              style: {
                fontSize: "20px",
                display: "inline-block",
                marginTop: "15px",
                userSelect: "auto",
              },
            },
            e,
          ),
        Dn = ({ children: e }) =>
          c.createElement(
            "pre",
            { style: { marginTop: "15px", opacity: 0.7, userSelect: "auto" } },
            e,
          );
      function Fn(e) {
        const { managerOverride: t, bSuppressMouseOverlay: n } = e,
          o = M(),
          i = (function () {
            const { ownerWindow: e } = _n(),
              t = En.GetPopupForWindow(e);
            return t?.browser_info || rn;
          })(),
          s = c.useContext(Sn),
          r = t ?? s;
        y(r.OnMenusChanged, o);
        const a = !n && r.BShouldRenderMouseOverlay(),
          l = r.GetAllMenus();
        return c.createElement(
          c.Fragment,
          null,
          a && c.createElement(Kt, null),
          l.map((e) =>
            c.createElement(
              Rn,
              { key: e.key },
              c.createElement(Pn, { instance: e, browserInfo: i }),
            ),
          ),
        );
      }
      function Pn(e) {
        const { instance: t, browserInfo: n, children: o } = e,
          i = ho(),
          s = _n().ownerWindow,
          r = c.useRef(void 0);
        void 0 === r.current &&
          (r.current =
            (t.options.bForcePopup || s.innerWidth < 400 || i?.BOnlyPopups()) &&
            !!s.SteamClient?.Window);
        const a = c.useMemo(
            () => ({ instance: t, styles: Rt(), presentation: 0 }),
            [t],
          ),
          l = o || t.ReactElement;
        return c.createElement(
          Bt.Provider,
          { value: a },
          r.current
            ? c.createElement(Nn, { instance: t, browserInfo: n, children: l })
            : c.createElement(Ln, { instance: t, children: l }),
        );
      }
      function Ln(e) {
        const { instance: t, children: n } = e;
        return c.createElement(Vt, { ...t.position }, n);
      }
      function Nn(e) {
        const { instance: t, browserInfo: n, children: o } = e,
          i = c.useRef(null),
          s = _n().ownerWindow,
          r = s.SteamClient.Browser.GetBrowserID(),
          a = c.useCallback(
            (e) => {
              const { options: n, position: o } = t,
                i = o.element;
              if (n.bScreenCoordinates)
                e.dimensions = {
                  left: o.clientX,
                  top: o.clientY,
                  width: 2,
                  height: 1,
                };
              else {
                let t = S(s, i.getBoundingClientRect());
                (e.dimensions = {
                  left: t.right,
                  top: t.top,
                  width: 2,
                  height: 1,
                }),
                  (e.availscreenwidth = s.screen.availWidth),
                  (e.availscreenheight = s.screen.availHeight);
              }
              return e;
            },
            [s, t],
          );
        let l = t.options.bStandalone
          ? hn(dn.StandaloneContextMenu)
          : hn(dn.PopupContextMenu);
        t.options.bCreateHidden && (l |= un.Hidden),
          t.options.bAlwaysOnTop && (l |= un.AlwaysOnTop);
        const { popupObj: u, element: d } = yn(
          "contextmenu_" + t.key,
          {
            title: t.options.title || "Menu",
            html_class: (0, yt.A)(
              Rt().ContextMenuPopup,
              "client_chat_frame",
              t.options.bStandalone && Rt().Standalone,
            ),
            popup_class: Rt().PopupTarget,
            body_class: (0, yt.A)(
              Rt().ContextMenuPopupBody,
              "ContextMenuPopupBody",
            ),
            replace_existing_popup: !1,
            target_browser: n,
            window_opener_id: r,
            bHideOnClose: !0,
            eCreationFlags: l,
          },
          { updateParamsBeforeShow: a },
        );
        return (
          (0, c.useEffect)(() => {
            if (u)
              if (t.visible) {
                i.current && i.current.PositionMenu(),
                  i.current && i.current.PositionPopupWindow();
                let e = t.options.bNoFocusWhenShown
                  ? qt.iE.k_EWindowBringToFrontWithoutForcingOS
                  : qt.iE.k_EWindowBringToFrontAndForceOS;
                t.TakeFocus(e);
              } else
                t.options.bRetainOnHide &&
                  window.setTimeout(() => {
                    u.window?.SteamClient.Window.HideWindow();
                  }, 30);
          }, [u, t, t.visible]),
          (function (e) {
            const t = ho();
            c.useEffect(() => {
              if (e) return Zn.RegisterModalManager(t, e);
            }, [e, t]);
          })(u.window),
          c.useEffect(() => {
            t.SetPopup(u);
          }, [t, u]),
          d
            ? g.createPortal(
                c.createElement(
                  Vt,
                  { ref: i, ...t.position, parentWin: s, popup: u },
                  o,
                ),
                d,
              )
            : null
        );
      }
      function Bn(e) {
        const [t, n] = (0, c.useState)(!0);
        return (
          (0, c.useEffect)(() => {
            (0, c.startTransition)(() => {
              n(!0);
            });
          }, []),
          t ? e.children : (e.fallback ?? null)
        );
      }
      function xn(e) {
        const [t, n] = c.useState(!1),
          o = c.useCallback(() => {
            Mt(e, "Window.IsWindowMaximized")
              ? e.SteamClient.Window.IsWindowMaximized().then((e) => {
                  n(e);
                })
              : e?.screen &&
                n(
                  e.screen.availWidth == e.innerWidth &&
                    e.screen.availHeight == e.innerHeight,
                );
          }, [e]);
        return (
          c.useEffect(o, [o, e]),
          w(e, "resize", o),
          (function (e, t, n, o) {
            w(
              e,
              "message",
              function (e) {
                t.includes(e.data) && n(this, e);
              },
              o,
            );
          })(e, ["window_resized"], o),
          t
        );
      }
      function Wn(e) {
        const { popup: t, onMaximize: n, bOSX: o } = e,
          i = xn(t),
          s = c.useCallback(() => {
            n
              ? n()
              : Mt(t, "Window.ToggleMaximize") &&
                t.SteamClient.Window.ToggleMaximize();
          }, [t, n]);
        return c.createElement(
          Gn,
          {
            className: (0, yt.A)(
              i ? "restoreButton" : "maximizeButton",
              "windowControlButton",
            ),
            onClick: s,
          },
          !o && (i ? c.createElement(Pt, null) : c.createElement(Dt, null)),
        );
      }
      function Hn(e) {
        const { popup: t, onMinimize: n, bOSX: o } = e,
          i = c.useCallback(() => {
            t.SteamClient.Window.Minimize();
          }, [t]);
        return c.createElement(
          Gn,
          { className: "minimizeButton windowControlButton", onClick: n ?? i },
          !o && c.createElement(Ft, null),
        );
      }
      function Un(e) {
        const { popup: t, onClose: n, bOSX: o } = e,
          i = c.useCallback(() => {
            t &&
              (Mt(t, "Window.Close")
                ? t.SteamClient.Window.Close()
                : t.close());
          }, [t]);
        return c.createElement(
          Gn,
          { className: "closeButton windowControlButton", onClick: n ?? i },
          !o && c.createElement(At, null),
        );
      }
      function Gn(e) {
        const { className: t, onClick: n, children: o } = e,
          i = c.useCallback(
            (e) => {
              n && (e.stopPropagation(), n(e));
            },
            [n],
          );
        return c.createElement(
          "div",
          { className: (0, yt.A)("title-area-icon", t), onClick: i },
          c.createElement("div", { className: "title-area-icon-inner" }, o),
        );
      }
      function Vn(e) {
        const {
            className: t,
            style: n,
            hideActions: o,
            hideClose: i,
            hideMin: s,
            hideMax: r,
            bOSX: a = (0, Tt.Pr)(),
            bForceWindowFocused: l,
            onMinimize: u,
            onMaximize: d,
            onClose: m,
            extraActions: h,
            popup: p,
            children: _,
          } = e,
          g = (function (e, t = 100) {
            const [n, o] = c.useState(!1),
              i = c.useCallback(() => o(!0), [o]),
              s = c.useCallback(() => o(!1), [o]);
            return (
              c.useEffect(
                () =>
                  e
                    ? (e.addEventListener("focus", i),
                      e.addEventListener("blur", s),
                      () => {
                        e.removeEventListener("focus", i),
                          e.removeEventListener("blur", s);
                      })
                    : void 0,
                [e, i, s],
              ),
              T(n, t)
            );
          })(p);
        return c.createElement(
          "div",
          {
            className: (0, yt.A)(
              "TitleBar",
              "title-area",
              a && "OSX",
              (g || l) && "WindowFocus",
              t,
            ),
            style: n,
          },
          c.createElement("div", { className: "title-area-highlight" }),
          c.createElement("div", { className: "title-area-children" }, _),
          !o &&
            c.createElement(
              c.Fragment,
              null,
              h &&
                c.createElement(
                  "div",
                  { className: "title-bar-actions extra-actions" },
                  h,
                ),
              c.createElement(
                "div",
                { className: "title-bar-actions window-controls" },
                !i && c.createElement(Un, { popup: p, onClose: m, bOSX: a }),
                !r && c.createElement(Wn, { popup: p, onMaximize: d, bOSX: a }),
                !s && c.createElement(Hn, { popup: p, onMinimize: u, bOSX: a }),
              ),
            ),
        );
      }
      function Kn(e) {
        const { Modal: t } = e,
          { name: n, modalProps: o, options: i } = t,
          s = _n().ownerWindow,
          { popup: r, element: a } = yn(
            n,
            {
              title: o.strTitle,
              html_class:
                "client_chat_frame fullheight ModalDialogPopup LegacyPopup " +
                (o.className || ""),
              body_class: "fullheight ModalDialogBody",
              popup_class: "fullheight popup_chat_frame",
              owner_window: void 0,
              replace_existing_popup: !0,
              target_browser: o.browserContext,
              availscreenwidth: s.screen.availWidth,
              availscreenheight: s.screen.availHeight,
              bModal: o.bHideMainWindowForPopouts,
            },
            {
              updateParamsBeforeShow: (e) =>
                (function (e, t, n, o) {
                  let i,
                    s,
                    r,
                    a = t.popupWidth || 500,
                    l = t.popupHeight || 400;
                  if (Tt.TS.IN_CLIENT && o?.SteamClient?.Browser?.GetBrowserID)
                    r = o.SteamClient.Browser.GetBrowserID();
                  else {
                    let e = o.screen;
                    (i = (e.availWidth - a) / 2), (s = (e.availHeight - l) / 2);
                    let t = e;
                    void 0 !== t.availLeft &&
                      void 0 !== t.availTop &&
                      ((i += t.availLeft), (s += t.availTop));
                  }
                  return {
                    ...e,
                    dimensions: { width: a, height: l, left: i, top: s },
                    center_on_window: n.bCenterOnWindow ? o : void 0,
                    window_opener_id: r,
                  };
                })(e, o, i, s),
              onClose: () => o.fnOnClose && o.fnOnClose(),
            },
          ),
          l = c.useCallback(() => {
            o.bHideMainWindowForPopouts && r?.SteamClient.Window.BringToFront();
          }, [o.bHideMainWindowForPopouts, r]);
        w(s, "click", l);
        const u = i?.bHideActions,
          d =
            "number" == typeof i?.nDragAreaHeight
              ? { height: i.nDragAreaHeight }
              : void 0;
        return a
          ? g.createPortal(
              c.createElement(
                gn,
                { ownerWindow: r },
                c.createElement(
                  "div",
                  { className: "PopupFullWindow", onContextMenu: zt },
                  c.createElement(Vn, {
                    hideMin: !0,
                    hideMax: !0,
                    popup: r,
                    hideActions: u,
                    style: d,
                  }),
                  c.createElement(
                    mo,
                    {
                      browserInfo: o.browserContext,
                      bCenterPopupsOnWindow: i.bCenterOnWindow,
                    },
                    t.element,
                  ),
                ),
              ),
              a,
            )
          : null;
      }
      function zn(e) {
        const { ModalManager: t } = e,
          [n, o] = c.useState(void 0),
          [i, s] = c.useState(!0),
          r = c.useRef(0),
          a = c.useCallback(() => {
            c.startTransition(() => {
              s(!0);
            });
          }, []);
        c.useEffect(() => t.RegisterMeasureModalCallback(a).Unregister, [t, a]),
          c.useLayoutEffect(() => {
            n ||
              c.startTransition(() => {
                o(t.TakeMeasureModalRequest()), s(!1);
              });
          }, [t, n, i]);
        const l = c.useCallback((e) => {
          r.current++,
            c.startTransition(() => {
              o((t) => (t === e ? void 0 : t));
            });
        }, []);
        return n
          ? c.createElement(jn, {
              key: r.current,
              onMeasureComplete: l,
              request: n,
            })
          : null;
      }
      function jn(e) {
        const [t, n] = c.useState(),
          o = _n().ownerWindow;
        return (
          c.useLayoutEffect(() => {
            const e = o.document.body,
              t = o.document.createElement("div");
            return (
              (t.style.position = "absolute"),
              (t.style.visibility = "hidden"),
              e.appendChild(t),
              n(t),
              () => {
                e.removeChild(t);
              }
            );
          }, [o]),
          t
            ? g.createPortal(c.createElement($n, { ...e, elContainer: t }), t)
            : null
        );
      }
      function $n(e) {
        const { elContainer: t, onMeasureComplete: n, request: o } = e;
        return (
          c.useEffect(() => {
            let e = !1;
            const i = (t) => {
              e || (o.fnResults(t), n(o), (e = !0));
            };
            return (
              (async function (e, t) {
                t && (await t);
                let n = document;
                Tt.TS.IN_STEAMUI && n.fonts && (await n.fonts.ready);
                const o = e.getBoundingClientRect(),
                  i = Math.ceil(o.height),
                  s = Math.ceil(o.width);
                return { height: i, width: s };
              })(t, o.promiseContentReady).then(i),
              () => i(void 0)
            );
          }, [t, n, o]),
          c.createElement(Rn, null, o.rctToMeasure)
        );
      }
      class qn {
        key;
        static sm_lastKey = 0;
        ModalClosedCallback = new F.lu();
        constructor() {
          this.key = "Modal_" + qn.sm_lastKey++;
        }
      }
      class Yn extends qn {
        element;
        ModalUpdatedCallback = new F.lu();
        constructor(e) {
          super(), (this.element = e);
        }
        UpdateModal(e) {
          (this.element = e), this.ModalUpdatedCallback.Dispatch();
        }
      }
      class Xn extends qn {
        m_OnElementReadyCallbacks = new F.lu();
        m_OnActiveModalCallbacks = new F.lu();
        constructor() {
          super();
        }
        get OnElementReadyCallbacks() {
          return this.m_OnElementReadyCallbacks;
        }
        get OnModalActiveCallbacks() {
          return this.m_OnActiveModalCallbacks;
        }
        RefModalElement(e) {
          e && this.m_OnElementReadyCallbacks.Dispatch(e);
        }
        SetActive(e) {
          this.m_OnActiveModalCallbacks.Dispatch(e);
        }
      }
      (0, i.Cg)([B.o], Xn.prototype, "RefModalElement", null);
      class Qn extends Yn {
        m_strName;
        m_modalProps;
        m_options;
        constructor(e, t, n, o) {
          super(t),
            (this.m_strName = e),
            (this.m_modalProps = n),
            (this.m_options = o);
        }
        get name() {
          return this.m_strName;
        }
        get modalProps() {
          return this.m_modalProps;
        }
        get options() {
          return this.m_options;
        }
      }
      class Jn {
        m_bUsePopups = !0;
        m_bOnlyPopups = !1;
        m_bCenterPopupsOnWindow = !1;
        m_rgModals = [];
        m_OnModalCountChangedCallbacks = new F.lu();
        m_OnModalShownCallbacks = new F.lu();
        m_OnModalHiddenCallbacks = new F.lu();
        m_cMountedOverlays = 0;
        m_rgMeasureModalRequests = [];
        m_OnMeasureModal = new F.lu();
        m_rgLegacyPopupModals = [];
        m_OnLegacyPopupModalCountChanged = new F.lu();
        m_browserInfo;
        get ModalCountChangedCallbacks() {
          return this.m_OnModalCountChangedCallbacks;
        }
        get LegacyPopupModalCountChangedCallbacks() {
          return this.m_OnLegacyPopupModalCountChanged;
        }
        RegisterOnModalShownCallback(e) {
          return this.m_OnModalShownCallbacks.Register(e);
        }
        RegisterOnModalHiddenCallback(e) {
          return this.m_OnModalHiddenCallbacks.Register(e);
        }
        RegisterMeasureModalCallback(e) {
          return this.m_OnMeasureModal.Register(e);
        }
        TakeMeasureModalRequest() {
          return this.m_rgMeasureModalRequests.length
            ? this.m_rgMeasureModalRequests.shift()
            : void 0;
        }
        RegisterOverlay(e) {
          (0, ie.wT)(
            0 == this.m_cMountedOverlays,
            "Duplicate modal DialogOverlay; modals will appear in both",
          ),
            this.m_cMountedOverlays++;
          const t = this.m_OnModalCountChangedCallbacks.Register(e);
          return () => {
            this.m_cMountedOverlays--, t.Unregister();
          };
        }
        OnModalCountChanged(e) {
          "show" == e &&
            0 == this.m_cMountedOverlays &&
            window.setTimeout(() => {
              (0, ie.wT)(
                this.m_cMountedOverlays > 0,
                "Modal was shown but ModalManager has no associated DialogOverlay",
              );
            }, 50),
            this.m_OnModalCountChangedCallbacks.Dispatch(
              this.m_rgModals.length,
            ),
            "show" == e
              ? this.m_OnModalShownCallbacks.Dispatch(this.m_rgModals.length)
              : "hide" == e &&
                this.m_OnModalHiddenCallbacks.Dispatch(this.m_rgModals.length);
        }
        get modals() {
          return this.m_rgModals;
        }
        get active_modal() {
          return this.m_rgModals.length
            ? this.m_rgModals[this.m_rgModals.length - 1]
            : void 0;
        }
        ShowModal(e) {
          return this.ShowModalInternal(e);
        }
        RemoveModal(e) {
          let t = this.m_rgModals.indexOf(e);
          -1 != t && this.m_rgModals.splice(t, 1),
            e.ModalClosedCallback.Dispatch(),
            this.OnModalCountChanged("hide");
        }
        ShowModalInternal(e) {
          (0, ie.wT)(
            !this.m_bOnlyPopups,
            "Attempting to show modal in popup-only modal manager; will not display.",
          );
          const t = new Yn(e);
          this.m_rgModals.push(t);
          const n = {
            Close: () => {
              this.RemoveModal(t);
            },
            Update: (e) => {
              t.UpdateModal(e);
            },
            ClosedPromise: new Promise((e) => {
              const n = t.ModalClosedCallback.Register(() => {
                e(), n.Unregister();
              });
            }),
          };
          return this.OnModalCountChanged("show"), n;
        }
        ShowPortalModal() {
          (0, ie.wT)(
            !this.m_bOnlyPopups,
            "Attempting to show modal in popup-only modal manager; will not display.",
          );
          const e = new Xn();
          return (
            this.m_rgModals.push(e),
            this.OnModalCountChanged("show"),
            {
              key: e.key,
              Close: () => {
                this.RemoveModal(e);
              },
              OnElementReadyCallbacks: e.OnElementReadyCallbacks,
              OnModalActiveCallbacks: e.OnModalActiveCallbacks,
            }
          );
        }
        SetUsePopups(e) {
          this.m_bUsePopups = e;
        }
        BUsePopups() {
          return this.m_bUsePopups || this.m_bOnlyPopups;
        }
        SetOnlyPopups(e) {
          this.m_bOnlyPopups = e;
        }
        BOnlyPopups() {
          return this.m_bOnlyPopups;
        }
        SetBrowserInfo(e) {
          this.m_browserInfo = e;
        }
        GetBrowserInfo() {
          return this.m_browserInfo;
        }
        SetCenterPopupsOnWindow(e) {
          this.m_bCenterPopupsOnWindow = e;
        }
        BCenterPopupsOnWindow() {
          return this.m_bCenterPopupsOnWindow;
        }
        RequestModalMeasure(e, t, n) {
          this.m_rgMeasureModalRequests.push({
            rctToMeasure: e,
            fnResults: t,
            promiseContentReady: n,
          }),
            this.m_OnMeasureModal.Dispatch();
        }
        get legacy_popup_modals() {
          return this.m_rgLegacyPopupModals;
        }
        ShowLegacyPopupModal(e, t, n, o) {
          const i = () => {
              let e = this.m_rgLegacyPopupModals.indexOf(s);
              -1 != e && this.m_rgLegacyPopupModals.splice(e, 1),
                this.m_OnLegacyPopupModalCountChanged.Dispatch(
                  this.m_rgLegacyPopupModals.length,
                ),
                s.ModalClosedCallback.Dispatch(),
                n.fnOnClose && n.fnOnClose();
            },
            s = new Qn(
              e,
              t,
              { ...n, fnOnClose: i },
              { bCenterOnWindow: this.m_bCenterPopupsOnWindow, ...o },
            );
          return (
            this.m_rgLegacyPopupModals.push(s),
            this.m_OnLegacyPopupModalCountChanged.Dispatch(
              this.m_rgLegacyPopupModals.length,
            ),
            {
              Close: i,
              Update: (e) => {
                s.UpdateModal(e);
              },
              ClosedPromise: new Promise((e) => {
                const t = s.ModalClosedCallback.Register(() => {
                  e(), t.Unregister();
                });
              }),
            }
          );
        }
      }
      const Zn = new (class {
        m_mapModalManager = new WeakMap();
        GetModalManager(e) {
          let t = this.m_mapModalManager.get(e);
          return (
            t ||
              (console.assert(
                !1,
                `Early access to modal manager, creating one for ${e.document.title}`,
              ),
              (t = new Jn()),
              this.m_mapModalManager.set(e, t)),
            t
          );
        }
        RegisterModalManager(e, t) {
          (0, ie.wT)(
            !this.m_mapModalManager.has(t) || t == window,
            `Stomping CModalManager for ${t.document.title}!`,
          );
          const n = this.m_mapModalManager.get(t);
          return (
            this.m_mapModalManager.set(t, e),
            () => {
              n
                ? this.m_mapModalManager.set(t, n)
                : this.m_mapModalManager.delete(t);
            }
          );
        }
        UnregisterModalManager(e) {
          this.m_mapModalManager.delete(e);
        }
      })();
      var eo = n(8843);
      n(7739);
      n(7077);
      const to = c.createContext({});
      function no(e) {
        const [t, n] = c.useState(null),
          o = c.useMemo(() => ({ targetElement: t }), [t]);
        return c.createElement(
          to.Provider,
          { value: o },
          c.createElement("div", { ref: n }),
          e.children,
        );
      }
      function oo(e) {
        c.useEffect(() => {
          if (e)
            return (
              document.body.classList.add(eo.BodyNoScrollDialog),
              () => document.body.classList.remove(eo.BodyNoScrollDialog)
            );
        }, [e]);
      }
      function io(e) {
        let {
          ModalManager: t,
          bRegisterModalManager: n = !0,
          DialogWrapper: o,
          rctActiveContextMenus: i,
          bUseDialogElement: s = !0,
          style: r,
          ...a
        } = e;
        const l = t.modals,
          u = l && !!l.length,
          d = t.active_modal;
        oo(u),
          (function (e) {
            const t = _n().ownerWindow,
              n = M(),
              o = c.useCallback(() => {
                t?.SteamClient?.Window && t.SteamClient.Window.BringToFront();
              }, [t]);
            c.useEffect(() => e.RegisterOverlay(n), [e, n]),
              c.useEffect(
                () => e.RegisterOnModalShownCallback(o).Unregister,
                [e, o],
              );
          })(t);
        const m = (function (e, t) {
          return _(
            (n) => {
              if (!n || !t) return;
              const o = n.ownerDocument.defaultView;
              return Zn.RegisterModalManager(e, o);
            },
            [e],
          );
        })(t, n);
        let h = null,
          p = !s;
        return (
          l && l.length
            ? (h = l.map((e) => {
                const t = e == d,
                  n = {
                    key: e.key,
                    active: t,
                    rctActiveContextMenus: t && s ? i : void 0,
                  };
                return e instanceof Yn
                  ? c.createElement(ro, {
                      ...n,
                      key: n.key,
                      modal: e,
                      Component: o ?? ao,
                    })
                  : e instanceof Xn
                    ? c.createElement(so, {
                        ...n,
                        key: n.key,
                        modal: e,
                        bUseDialogElement: s,
                      })
                    : void 0;
              }))
            : ((p = !0), (r = { ...r, display: "none" })),
          c.createElement(
            c.Fragment,
            null,
            c.createElement(
              Bn,
              null,
              c.createElement(
                "div",
                {
                  ...a,
                  style: r,
                  ref: m,
                  className: (0, yt.A)(a.className, "FullModalOverlay"),
                },
                c.createElement("div", {
                  className: "ModalOverlayContent ModalOverlayBackground",
                }),
                h,
              ),
              p && i,
            ),
            c.createElement(zn, { ModalManager: t }),
            c.createElement(co, { ModalManager: t }),
          )
        );
      }
      function so(e) {
        const {
          modal: t,
          rctActiveContextMenus: n,
          active: o,
          bUseDialogElement: i,
        } = e;
        c.useEffect(() => {
          if (o)
            return (
              t.SetActive(o),
              () => {
                t.SetActive(!1);
              }
            );
        }, [t, o]);
        const s = c.createElement(
          Rn,
          null,
          c.createElement("div", {
            className: (0, yt.A)(
              "ModalOverlayContent",
              o ? "active" : "inactive",
            ),
            ref: t.RefModalElement,
          }),
          n,
        );
        return i ? c.createElement(lo, { active: o }, s) : s;
      }
      function ro(e) {
        const {
            modal: t,
            active: n,
            rctActiveContextMenus: o,
            Component: i,
          } = e,
          s = M();
        return (
          y(t.ModalUpdatedCallback, s),
          c.createElement(
            Rn,
            null,
            c.createElement(
              i,
              {
                className: (0, yt.A)(
                  "ModalOverlayContent",
                  n ? "active" : "inactive",
                ),
                active: n,
                modalKey: t.key,
              },
              o,
              t.element,
            ),
          )
        );
      }
      function ao(e) {
        const { className: t, active: n, children: o } = e;
        return c.createElement(
          lo,
          { active: n },
          c.createElement(
            no,
            null,
            c.createElement("div", { className: t, tabIndex: -1 }, o),
          ),
        );
      }
      function lo(e) {
        const { active: t, children: n } = e,
          o = c.useRef(null),
          [i, s] = c.useState(!1);
        return (
          c.useLayoutEffect(() => {
            t && !i ? s(!0) : !t && i && o.current?.close();
          }, [t, i]),
          c.useLayoutEffect(() => {
            i && o.current.showModal();
          }, [i]),
          c.createElement(
            "dialog",
            {
              ref: o,
              className: eo.ModalDialog,
              onClose: () => s(!1),
              onCancel: (e) => e.preventDefault(),
            },
            n,
          )
        );
      }
      function co(e) {
        const { ModalManager: t } = e,
          n = M();
        return (
          y(t.LegacyPopupModalCountChangedCallbacks, n),
          c.createElement(
            c.Fragment,
            null,
            t.legacy_popup_modals.map((e) =>
              c.createElement(Kn, { key: e.key, Modal: e }),
            ),
          )
        );
      }
      const uo = c.createContext({}),
        mo = c.memo(function (e) {
          const {
              children: t,
              bRenderOverlayAtRoot: n,
              refModalManager: o,
              DialogWrapper: i,
              bUseDialogElement: s = !0,
              ContextMenuComponent: r = Fn,
              refContextMenuManager: a,
              browserInfo: l,
              bUsePopups: u,
              bOnlyPopups: d,
              bCenterPopupsOnWindow: m,
              bRegisterManagersWithWindow: p = !0,
              ..._
            } = e,
            f = c.useRef(void 0);
          f.current || (f.current = new Jn());
          let b = c.createElement(io, {
            ..._,
            DialogWrapper: i,
            ModalManager: f.current,
            bUseDialogElement: s,
            bRegisterModalManager: p,
            rctActiveContextMenus: c.createElement(r, null),
          });
          e.bRenderOverlayAtRoot &&
            "undefined" != typeof document &&
            "body" in document &&
            (b = g.createPortal(b, document.body)),
            (function (e, t) {
              const n = c.useRef(!1);
              c.useLayoutEffect(
                () => () => {
                  n.current && h(e, void 0);
                },
                [e],
              ),
                c.useLayoutEffect(() => {
                  (t || n.current) && (h(e, t), (n.current = !!t));
                }, [e, t]);
            })(o, f.current),
            void 0 !== u && f.current?.SetUsePopups(u),
            void 0 !== m && f.current?.SetCenterPopupsOnWindow(m),
            void 0 !== d && f.current?.SetOnlyPopups(d),
            f.current.SetBrowserInfo(l);
          const E = c.useMemo(
            () => ({ ModalManager: f.current, DialogWrapper: i }),
            [i],
          );
          return c.createElement(
            uo.Provider,
            { value: E },
            c.createElement(
              Cn,
              { refContextMenuManager: a, bRegisterMenuManager: p },
              c.createElement(Rn, null, b),
              e.children,
            ),
          );
        });
      function ho() {
        return c.useContext(uo).ModalManager;
      }
      var po = n(6328),
        _o = n(258),
        go = n(5455);
      const fo = c.createContext(void 0),
        bo = fo.Provider;
      function Eo(e) {
        const { useStorage: t, children: n } = e;
        let o, i;
        if ("useActiveCMInterface" in e) i = o = e.useActiveCMInterface;
        else {
          if (!("useActiveSteamInterface" in e))
            return (
              (0, ie.z_)(
                e,
                "neither useActiveCMInterface nor useActiveSteamInterface were provided",
              ),
              n
            );
          i = e.useActiveSteamInterface;
        }
        const s = c.useMemo(
          () => ({
            useActiveSteamInterface: i,
            useActiveCMInterface: o,
            useStorage: t,
          }),
          [i, o, t],
        );
        return c.createElement(bo, { value: s }, n);
      }
      let So = c.lazy(() => n.e(333).then(n.bind(n, 8333)));
      const Co = new po.E({
          defaultOptions: { queries: { gcTime: 864e5, staleTime: 1 / 0 } },
        }),
        vo = (0, go.s)({ storage: window.localStorage });
      let wo = class extends c.Component {
        render() {
          return c.createElement(
            m.vd,
            null,
            c.createElement(
              _o.t,
              {
                client: Co,
                persistOptions: {
                  persister: vo,
                  buster: "v1",
                  maxAge: 6e4,
                  dehydrateOptions: {
                    shouldDehydrateQuery: (e) => e.meta?.persist,
                  },
                },
              },
              c.createElement(
                Eo,
                { useActiveSteamInterface: () => {}, useStorage: () => {} },
                c.createElement(
                  mo,
                  null,
                  c.createElement(
                    u.Kd,
                    { basename: s() },
                    c.createElement(
                      c.Suspense,
                      { fallback: null },
                      c.createElement(
                        d.dO,
                        null,
                        c.createElement(d.qh, { path: a(), component: So }),
                        c.createElement(d.qh, {
                          path: r(":page"),
                          render: () => c.createElement(d.rd, { to: s() }),
                        }),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          );
        }
      };
      wo = (0, i.Cg)([l.PA], wo);
      const Mo = wo;
      var yo = n(4844);
      n(1735), n(2244);
      new Map();
      n(3808);
      let Io = new (class {
        Init() {
          yo.createRoot(document.getElementById("react_root")).render(
            c.createElement(Mo, { app: this }),
          );
        }
      })();
      const Ro = ["main", "oldgods"];
      document.addEventListener("DOMContentLoaded", async function () {
        (0, Tt.XJ)("application_config"),
          (0, o.a)(),
          await (async function (e) {
            const t = await Promise.all([
              n(4919)(`./shared_${e}.json`),
              ...Ro.map((t) => n(9483)(`./${t}_${e}.json`)),
            ]);
            let o = {};
            for (const e of t) o = { ...o, ...e };
            const i = Nt.A0.GetLanguageFallback(e);
            if (i !== e) {
              const e = await Promise.all([
                n(4919)(`./shared_${i}.json`),
                ...Ro.map((e) => n(9483)(`./${e}_${i}.json`)),
              ]);
              let s = {};
              for (const t of e) s = { ...s, ...t };
              Nt.pf.InitFromObjects(o, s, t[0].default, e[0].default);
            } else Nt.pf.InitFromObjects(o, null, t[0].default, null);
          })(o.U.LANGUAGE),
          Io.Init();
      });
    },
    2837: (e, t, n) => {
      "use strict";
      n.d(t, { iE: () => E, sf: () => o });
      function o(e, t = 0) {
        switch (e) {
          case "english":
            return 0;
          case "german":
            return 1;
          case "french":
            return 2;
          case "italian":
            return 3;
          case "korean":
          case "koreana":
            return 4;
          case "spanish":
            return 5;
          case "schinese":
            return 6;
          case "tchinese":
            return 7;
          case "russian":
            return 8;
          case "thai":
            return 9;
          case "japanese":
            return 10;
          case "portuguese":
            return 11;
          case "polish":
            return 12;
          case "danish":
            return 13;
          case "dutch":
            return 14;
          case "finnish":
            return 15;
          case "norwegian":
            return 16;
          case "swedish":
            return 17;
          case "hungarian":
            return 18;
          case "czech":
            return 19;
          case "romanian":
            return 20;
          case "turkish":
            return 21;
          case "arabic":
            return 25;
          case "brazilian":
            return 22;
          case "bulgarian":
            return 23;
          case "greek":
            return 24;
          case "ukrainian":
            return 26;
          case "latam":
            return 27;
          case "vietnamese":
            return 28;
          case "sc_schinese":
            return 29;
          case "indonesian":
            return 30;
          default:
            return t;
        }
      }
      var i, s, r, a, l, c, u, d, m, h, p, _, g, f, b, E;
      !(function (e) {
        (e[(e.k_EConnectivityTestResult_Unknown = 0)] =
          "k_EConnectivityTestResult_Unknown"),
          (e[(e.k_EConnectivityTestResult_Connected = 1)] =
            "k_EConnectivityTestResult_Connected"),
          (e[(e.k_EConnectivityTestResult_CaptivePortal = 2)] =
            "k_EConnectivityTestResult_CaptivePortal"),
          (e[(e.k_EConnectivityTestResult_TimedOut = 3)] =
            "k_EConnectivityTestResult_TimedOut"),
          (e[(e.k_EConnectivityTestResult_Failed = 4)] =
            "k_EConnectivityTestResult_Failed"),
          (e[(e.k_EConnectivityTestResult_WifiDisabled = 5)] =
            "k_EConnectivityTestResult_WifiDisabled"),
          (e[(e.k_EConnectivityTestResult_NoLAN = 6)] =
            "k_EConnectivityTestResult_NoLAN");
      })(i || (i = {})),
        (function (e) {
          (e[(e.k_ENetFakeLocalSystemState_Normal = 0)] =
            "k_ENetFakeLocalSystemState_Normal"),
            (e[(e.k_ENetFakeLocalSystemState_NoLAN = 1)] =
              "k_ENetFakeLocalSystemState_NoLAN"),
            (e[(e.k_ENetFakeLocalSystemState_CaptivePortal_Redirected = 2)] =
              "k_ENetFakeLocalSystemState_CaptivePortal_Redirected"),
            (e[(e.k_ENetFakeLocalSystemState_CaptivePortal_InPlace = 3)] =
              "k_ENetFakeLocalSystemState_CaptivePortal_InPlace"),
            (e[(e.k_ENetFakeLocalSystemState_NoInternet = 4)] =
              "k_ENetFakeLocalSystemState_NoInternet"),
            (e[(e.k_ENetFakeLocalSystemState_NoSteam = 5)] =
              "k_ENetFakeLocalSystemState_NoSteam");
        })(s || (s = {})),
        (function (e) {
          (e[(e.k_ESuspendResumeProgressState_Invalid = 0)] =
            "k_ESuspendResumeProgressState_Invalid"),
            (e[(e.k_ESuspendResumeProgressState_Complete = 1)] =
              "k_ESuspendResumeProgressState_Complete"),
            (e[(e.k_ESuspendResumeProgressState_CloudSync = 2)] =
              "k_ESuspendResumeProgressState_CloudSync"),
            (e[(e.k_ESuspendResumeProgressState_LoggingIn = 3)] =
              "k_ESuspendResumeProgressState_LoggingIn"),
            (e[(e.k_ESuspendResumeProgressState_WaitingForApp = 4)] =
              "k_ESuspendResumeProgressState_WaitingForApp"),
            (e[(e.k_ESuspendResumeProgressState_Working = 5)] =
              "k_ESuspendResumeProgressState_Working");
        })(r || (r = {})),
        (function (e) {
          (e[(e.k_EFloatingGamepadTextInputModeModeSingleLine = 0)] =
            "k_EFloatingGamepadTextInputModeModeSingleLine"),
            (e[(e.k_EFloatingGamepadTextInputModeModeMultipleLines = 1)] =
              "k_EFloatingGamepadTextInputModeModeMultipleLines"),
            (e[(e.k_EFloatingGamepadTextInputModeModeEmail = 2)] =
              "k_EFloatingGamepadTextInputModeModeEmail"),
            (e[(e.k_EFloatingGamepadTextInputModeModeNumeric = 3)] =
              "k_EFloatingGamepadTextInputModeModeNumeric");
        })(a || (a = {})),
        (function (e) {
          (e[(e.k_EAppUpdateContentType_Content = 0)] =
            "k_EAppUpdateContentType_Content"),
            (e[(e.k_EAppUpdateContentType_Workshop = 1)] =
              "k_EAppUpdateContentType_Workshop"),
            (e[(e.k_EAppUpdateContentType_Shader = 2)] =
              "k_EAppUpdateContentType_Shader"),
            (e[(e.k_EAppUpdateContentType_Max = 3)] =
              "k_EAppUpdateContentType_Max");
        })(l || (l = {})),
        (function (e) {
          (e[(e.k_EAppUpdateProgress_VerifyingInstalledFiles = 0)] =
            "k_EAppUpdateProgress_VerifyingInstalledFiles"),
            (e[(e.k_EAppUpdateProgress_Preallocating = 1)] =
              "k_EAppUpdateProgress_Preallocating"),
            (e[(e.k_EAppUpdateProgress_Download = 2)] =
              "k_EAppUpdateProgress_Download"),
            (e[(e.k_EAppUpdateProgress_Staging = 3)] =
              "k_EAppUpdateProgress_Staging"),
            (e[(e.k_EAppUpdateProgress_VerifyingStagedFiles = 4)] =
              "k_EAppUpdateProgress_VerifyingStagedFiles"),
            (e[(e.k_EAppUpdateProgress_Copying = 5)] =
              "k_EAppUpdateProgress_Copying"),
            (e[(e.k_EAppUpdateProgress_Committing = 6)] =
              "k_EAppUpdateProgress_Committing"),
            (e[(e.k_EAppUpdateProgress_Max = 7)] = "k_EAppUpdateProgress_Max");
        })(c || (c = {})),
        (function (e) {
          (e[(e.k_EOverlayToStoreFlag_None = 0)] =
            "k_EOverlayToStoreFlag_None"),
            (e[(e.k_EOverlayToStoreFlag_AddToCart = 1)] =
              "k_EOverlayToStoreFlag_AddToCart"),
            (e[(e.k_EOverlayToStoreFlag_AddToCartAndShow = 2)] =
              "k_EOverlayToStoreFlag_AddToCartAndShow");
        })(u || (u = {})),
        (function (e) {
          (e[(e.k_EActivateGameOverlayToWebPageMode_Default = 0)] =
            "k_EActivateGameOverlayToWebPageMode_Default"),
            (e[(e.k_EActivateGameOverlayToWebPageMode_Modal = 1)] =
              "k_EActivateGameOverlayToWebPageMode_Modal");
        })(d || (d = {})),
        (function (e) {
          (e[(e.k_ELoginUIStyleOld = 0)] = "k_ELoginUIStyleOld"),
            (e[(e.k_ELoginUIStyleNewWithoutQRCode = 1)] =
              "k_ELoginUIStyleNewWithoutQRCode"),
            (e[(e.k_ELoginUIStyleNew = 2)] = "k_ELoginUIStyleNew");
        })(m || (m = {})),
        (function (e) {
          (e[(e.k_ECommunityProfileItemProperty_ImageSmall = 0)] =
            "k_ECommunityProfileItemProperty_ImageSmall"),
            (e[(e.k_ECommunityProfileItemProperty_ImageLarge = 1)] =
              "k_ECommunityProfileItemProperty_ImageLarge"),
            (e[(e.k_ECommunityProfileItemProperty_InternalName = 2)] =
              "k_ECommunityProfileItemProperty_InternalName"),
            (e[(e.k_ECommunityProfileItemProperty_Title = 3)] =
              "k_ECommunityProfileItemProperty_Title"),
            (e[(e.k_ECommunityProfileItemProperty_Description = 4)] =
              "k_ECommunityProfileItemProperty_Description"),
            (e[(e.k_ECommunityProfileItemProperty_AppID = 5)] =
              "k_ECommunityProfileItemProperty_AppID"),
            (e[(e.k_ECommunityProfileItemProperty_TypeID = 6)] =
              "k_ECommunityProfileItemProperty_TypeID"),
            (e[(e.k_ECommunityProfileItemProperty_Class = 7)] =
              "k_ECommunityProfileItemProperty_Class"),
            (e[(e.k_ECommunityProfileItemProperty_MovieWebM = 8)] =
              "k_ECommunityProfileItemProperty_MovieWebM"),
            (e[(e.k_ECommunityProfileItemProperty_MovieMP4 = 9)] =
              "k_ECommunityProfileItemProperty_MovieMP4"),
            (e[(e.k_ECommunityProfileItemProperty_MovieWebMSmall = 10)] =
              "k_ECommunityProfileItemProperty_MovieWebMSmall"),
            (e[(e.k_ECommunityProfileItemProperty_MovieMP4Small = 11)] =
              "k_ECommunityProfileItemProperty_MovieMP4Small");
        })(h || (h = {})),
        (function (e) {
          (e[(e.k_ERaiseGameWindowResult_NotRunning = 1)] =
            "k_ERaiseGameWindowResult_NotRunning"),
            (e[(e.k_ERaiseGameWindowResult_Success = 2)] =
              "k_ERaiseGameWindowResult_Success"),
            (e[(e.k_ERaiseGameWindowResult_Failure = 3)] =
              "k_ERaiseGameWindowResult_Failure");
        })(p || (p = {})),
        (function (e) {
          (e[(e.k_EPositionInvalid = -1)] = "k_EPositionInvalid"),
            (e[(e.k_EPositionTopLeft = 0)] = "k_EPositionTopLeft"),
            (e[(e.k_EPositionTopRight = 1)] = "k_EPositionTopRight"),
            (e[(e.k_EPositionBottomLeft = 2)] = "k_EPositionBottomLeft"),
            (e[(e.k_EPositionBottomRight = 3)] = "k_EPositionBottomRight");
        })(_ || (_ = {})),
        (function (e) {
          (e[(e.k_EAppReleaseState_Unknown = 0)] =
            "k_EAppReleaseState_Unknown"),
            (e[(e.k_EAppReleaseState_Unavailable = 1)] =
              "k_EAppReleaseState_Unavailable"),
            (e[(e.k_EAppReleaseState_Prerelease = 2)] =
              "k_EAppReleaseState_Prerelease"),
            (e[(e.k_EAppReleaseState_PreloadOnly = 3)] =
              "k_EAppReleaseState_PreloadOnly"),
            (e[(e.k_EAppReleaseState_Released = 4)] =
              "k_EAppReleaseState_Released"),
            (e[(e.k_EAppReleaseState_Disabled = 5)] =
              "k_EAppReleaseState_Disabled");
        })(g || (g = {})),
        (function (e) {
          (e[(e.k_EGameIDTypeApp = 0)] = "k_EGameIDTypeApp"),
            (e[(e.k_EGameIDTypeGameMod = 1)] = "k_EGameIDTypeGameMod"),
            (e[(e.k_EGameIDTypeShortcut = 2)] = "k_EGameIDTypeShortcut"),
            (e[(e.k_EGameIDTypeP2P = 3)] = "k_EGameIDTypeP2P");
        })(f || (f = {})),
        (function (e) {
          (e[(e.k_EInstallMgrStateNone = 0)] = "k_EInstallMgrStateNone"),
            (e[(e.k_EInstallMgrStateSetup = 1)] = "k_EInstallMgrStateSetup"),
            (e[(e.k_EInstallMgrStateWaitLicense = 2)] =
              "k_EInstallMgrStateWaitLicense"),
            (e[(e.k_EInstallMgrStateFreeLicense = 3)] =
              "k_EInstallMgrStateFreeLicense"),
            (e[(e.k_EInstallMgrStateShowCDKey = 4)] =
              "k_EInstallMgrStateShowCDKey"),
            (e[(e.k_EInstallMgrStateWaitAppInfo = 5)] =
              "k_EInstallMgrStateWaitAppInfo"),
            (e[(e.k_EInstallMgrStateShowPassword = 6)] =
              "k_EInstallMgrStateShowPassword"),
            (e[(e.k_EInstallMgrStateShowConfig = 7)] =
              "k_EInstallMgrStateShowConfig"),
            (e[(e.k_EInstallMgrStateShowEULAs = 8)] =
              "k_EInstallMgrStateShowEULAs"),
            (e[(e.k_EInstallMgrStateCreateApps = 9)] =
              "k_EInstallMgrStateCreateApps"),
            (e[(e.k_EInstallMgrStateReadFromMedia = 10)] =
              "k_EInstallMgrStateReadFromMedia"),
            (e[(e.k_EInstallMgrStateShowChangeMedia = 11)] =
              "k_EInstallMgrStateShowChangeMedia"),
            (e[(e.k_EInstallMgrStateWaitLegacyCDKeys = 12)] =
              "k_EInstallMgrStateWaitLegacyCDKeys"),
            (e[(e.k_EInstallMgrStateShowSignup = 13)] =
              "k_EInstallMgrStateShowSignup"),
            (e[(e.k_EInstallMgrStateComplete = 14)] =
              "k_EInstallMgrStateComplete"),
            (e[(e.k_EInstallMgrStateFailed = 15)] = "k_EInstallMgrStateFailed"),
            (e[(e.k_EInstallMgrStateCanceled = 16)] =
              "k_EInstallMgrStateCanceled");
        })(b || (b = {})),
        (function (e) {
          (e[(e.k_EWindowBringToFrontInvalid = 0)] =
            "k_EWindowBringToFrontInvalid"),
            (e[(e.k_EWindowBringToFrontAndForceOS = 1)] =
              "k_EWindowBringToFrontAndForceOS"),
            (e[(e.k_EWindowBringToFrontWithoutForcingOS = 2)] =
              "k_EWindowBringToFrontWithoutForcingOS");
        })(E || (E = {}));
    },
    2490: (e, t, n) => {
      "use strict";
      function o(e, t) {
        return (function (e, t) {
          const n = e.findIndex(t);
          return n >= 0 && (e.splice(n, 1), !0);
        })(e, (e) => t == e);
      }
      n.d(t, { x9: () => o });
    },
    1393: (e, t, n) => {
      "use strict";
      function o(e, t, ...n) {
        console.assert
          ? 0 == n.length
            ? console.assert(!!e, t)
            : console.assert(!!e, t, ...n)
          : e || console.warn(t, ...n);
      }
      function i(e, t, ...n) {
        o(!1, t, ...n);
      }
      n.d(t, { wT: () => o, z_: () => i });
    },
    6419: (e, t, n) => {
      "use strict";
      function o(e, t, n) {
        return {
          get() {
            let e = n.value.bind(this);
            return (
              Object.prototype.hasOwnProperty.call(this, t) ||
                Object.defineProperty(this, t, { value: e }),
              e
            );
          },
        };
      }
      n.d(t, { o: () => o });
    },
    1986: (e, t, n) => {
      "use strict";
      n.d(t, { l: () => i });
      var o = n(2490);
      class i {
        m_vecCallbacks = [];
        Register(e) {
          this.m_vecCallbacks.push(e);
          return {
            Unregister: () => {
              o.x9(this.m_vecCallbacks, e);
            },
          };
        }
        Dispatch(...e) {
          for (const t of Array.from(this.m_vecCallbacks)) t(...e);
        }
        ClearAllCallbacks() {
          this.m_vecCallbacks = [];
        }
        CountRegistered() {
          return this.m_vecCallbacks.length;
        }
        static PromiseFromAny(e) {
          return new Promise((t) => {
            let n = [];
            const o = () => {
              n.forEach((e) => e.Unregister()), t();
            };
            for (const t of e) n.push(t.Register(o));
          });
        }
      }
    },
    5489: (e, t, n) => {
      "use strict";
      function o(e, t) {
        return (
          (e = Math.ceil(e)),
          (t = Math.floor(t)),
          Math.floor(Math.random() * (t - e + 1)) + e
        );
      }
      function i(e, t, n) {
        return null == e || isNaN(e) ? e : Math.max(t, Math.min(n, e));
      }
      n.d(t, { OQ: () => i, Tg: () => o });
    },
    6144: (e, t, n) => {
      "use strict";
      n.d(t, { Jc: () => u, lu: () => r.l });
      var o = n(4629),
        i = n(2490),
        s = n(6419),
        r = n(1986);
      class a {
        SyncStore(e) {
          return this.Subscribe(e).Unsubscribe;
        }
        GetValue() {
          return this.Value;
        }
      }
      (0, o.Cg)([s.o], a.prototype, "SyncStore", null),
        (0, o.Cg)([s.o], a.prototype, "GetValue", null);
      class l extends a {}
      class c extends l {
        m_callbacks;
        m_currentValue;
        m_fnEquals;
        constructor(e, t) {
          super(),
            (this.m_callbacks = new r.l()),
            (this.m_currentValue = e),
            (this.m_fnEquals = t);
        }
        Set(e) {
          if (this.m_fnEquals) {
            if (this.m_fnEquals(this.m_currentValue, e)) return !1;
          } else if (this.m_currentValue === e) return !1;
          return (this.m_currentValue = e), this.m_callbacks.Dispatch(e), !0;
        }
        get Value() {
          return this.m_currentValue;
        }
        Subscribe(e) {
          return { Unsubscribe: this.m_callbacks.Register(e).Unregister };
        }
        get SubscriberCount() {
          return this.m_callbacks.CountRegistered();
        }
      }
      function u(e, t) {
        return new c(e, t);
      }
      (0, o.Cg)(
        [s.o],
        class {
          m_schTimer;
          m_fnCallback;
          m_fnOnCancel;
          Schedule(e, t) {
            this.IsScheduled() && this.Cancel(),
              (this.m_fnCallback = t),
              (this.m_schTimer = window.setTimeout(this.ScheduledInternal, e));
          }
          AsyncSchedule(e, t) {
            return new Promise((n, o) => {
              this.Schedule(e, () => {
                t(), n();
              }),
                (this.m_fnOnCancel = o);
            });
          }
          IsScheduled() {
            return void 0 !== this.m_schTimer;
          }
          Cancel() {
            if (this.m_schTimer) {
              const e = this.m_fnOnCancel;
              clearTimeout(this.m_schTimer), this.Reset(), e && e();
            }
          }
          Reset() {
            (this.m_schTimer = void 0),
              (this.m_fnCallback = void 0),
              (this.m_fnOnCancel = void 0);
          }
          ScheduledInternal() {
            const e = this.m_fnCallback;
            this.Reset(), e?.();
          }
        }.prototype,
        "ScheduledInternal",
        null,
      );
      (0, o.Cg)(
        [s.o],
        class {
          m_vecCallbacks = [];
          Push(e) {
            this.m_vecCallbacks.push(e);
          }
          PushArrayRemove(e, t) {
            this.m_vecCallbacks.push(() => i.x9(e, t));
          }
          Unregister() {
            for (const e of this.m_vecCallbacks) e();
            this.m_vecCallbacks = [];
          }
          GetUnregisterFunc() {
            return this.Unregister;
          }
        }.prototype,
        "Unregister",
        null,
      );
    },
    2038: (e, t, n) => {
      "use strict";
      function o(...e) {
        return e.reduce(
          (e, t) =>
            t
              ? "string" == typeof t
                ? e
                  ? `${e} ${t}`
                  : t
                : "object" == typeof t
                  ? e
                    ? `${e} ${i(t)}`
                    : i(t)
                  : e
              : e,
          "",
        );
      }
      function i(e) {
        return Object.keys(e).reduce(
          (t, n) => (e[n] ? (t ? `${t} ${n}` : n) : t),
          "",
        );
      }
      n.d(t, { A: () => o });
    },
    3339: (e, t, n) => {
      "use strict";
      n.d(t, {
        c9: () => u,
        A0: () => c,
        l4: () => p,
        pf: () => _,
        we: () => d,
      });
      n(626);
      var o,
        i = n(2837);
      !(function (e) {
        (e[(e.k_ESteamRealmUnknown = 0)] = "k_ESteamRealmUnknown"),
          (e[(e.k_ESteamRealmGlobal = 1)] = "k_ESteamRealmGlobal"),
          (e[(e.k_ESteamRealmChina = 2)] = "k_ESteamRealmChina");
      })(o || (o = {}));
      var s = n(4094),
        r = n(1393),
        a = n(6144);
      var l;
      !(function (e) {
        (e[(e.None = 0)] = "None"),
          (e[(e.Ago = 1)] = "Ago"),
          (e[(e.Remaining = 2)] = "Remaining");
      })(l || (l = {}));
      new Map();
      new Map();
      new Map(), new Map(), new Map(), new Map(), new Map(), new Map();
      class c {
        m_mapTokens = new Map();
        m_mapFallbackTokens = new Map();
        m_cbkTokensChanged = new a.lu();
        m_rgLocalesToUse;
        m_bReportIndividualMissingTokens = !0;
        static sm_ErrorReportingStore;
        static InstallErrorReportingStore(e) {
          this.sm_ErrorReportingStore = e;
        }
        static GetLanguageFallback(e) {
          return "sc_schinese" === e ? "schinese" : "english";
        }
        static GetELanguageFallback(e) {
          return 29 === e ? 6 : 0;
        }
        static IsELanguageValidInRealm(e, t) {
          return (
            t === (29 === e ? o.k_ESteamRealmChina : o.k_ESteamRealmGlobal)
          );
        }
        static GetLanguageListForRealms(e) {
          const t = new Array();
          for (let n = 0; n < 31; n++)
            for (const o of e)
              if (this.IsELanguageValidInRealm(n, o)) {
                t.push(n);
                break;
              }
          return t;
        }
        InitFromObjects(e, t, n, o, i, s) {
          s && (this.m_bReportIndividualMissingTokens = !1),
            i || this.m_mapTokens.clear();
          const r = { ...(n || {}), ...e },
            a = { ...(o || {}), ...(t || {}) };
          this.AddTokens(r, a), this.m_cbkTokensChanged.Dispatch();
        }
        InitDirect(e, t) {
          this.m_mapTokens.clear(),
            this.m_mapFallbackTokens.clear(),
            this.AddTokens(e, t),
            this.m_cbkTokensChanged.Dispatch();
        }
        AddTokens(e, t) {
          Object.keys(e).forEach((t) => {
            this.m_mapTokens.set(t, e[t]);
          }),
            t &&
              Object.keys(t).forEach((e) => {
                this.m_mapTokens.has(e) || this.m_mapTokens.set(e, t[e]),
                  this.m_mapFallbackTokens.set(e, t[e]);
              });
        }
        GetTokensChangedCallbackList() {
          return this.m_cbkTokensChanged;
        }
        GetPreferredLocales() {
          return this.m_rgLocalesToUse
            ? this.m_rgLocalesToUse
            : navigator && navigator.languages
              ? navigator.languages
              : ["en-US"];
        }
        GetELanguageFallbackOrder(e = null) {
          let t = new Array();
          if (
            (t.push((0, i.sf)(s.TS.LANGUAGE)),
            (s.TS.SUPPORTED_LANGUAGES || []).forEach((e) => {
              e.value != s.TS.LANGUAGE && t.push((0, i.sf)(e.value));
            }),
            e)
          ) {
            c.GetLanguageListForRealms(e).forEach((e) => {
              -1 == t.indexOf(e) && t.push(e);
            });
          }
          return t;
        }
        SetPreferredLocales(e) {
          this.m_rgLocalesToUse = e;
        }
        BLooksLikeToken(e) {
          return !!e && e.length > 0 && "#" == e.charAt(0);
        }
        LocalizeIfToken(e, t) {
          return this.BLooksLikeToken(e) ? this.LocalizeString(e, t) : e;
        }
        LocalizeString(e, t) {
          const n = 0 == this.m_mapTokens.size;
          if (
            ((0, r.wT)(
              !n,
              `Attempting to localize token '${e}' with no tokens in our map.`,
            ),
            !this.BLooksLikeToken(e))
          )
            return;
          let o = this.m_mapTokens.get(e.substring(1));
          if (void 0 !== o) return o;
          !t &&
            c.sm_ErrorReportingStore &&
            !n &&
            this.m_bReportIndividualMissingTokens &&
            c.sm_ErrorReportingStore.ReportError(
              new Error(
                `Unable to find localization token '${e}' for language '${s.TS.LANGUAGE}', ${this.m_mapTokens.size} tokens in map`,
              ),
              { bIncludeMessageInIdentifier: !0 },
            );
        }
        LocalizeStringFromFallback(e) {
          if (!e || 0 == e.length || "#" != e.charAt(0)) return;
          let t = this.m_mapFallbackTokens.get(e.substring(1));
          return void 0 !== t ? t : void 0;
        }
        static GetTokenWithFallback(e) {
          if (!e) return "";
          const t = (0, i.sf)(s.TS.LANGUAGE),
            n = e.find((e) => e.language == t);
          if (n) return n.localized_string;
          const o = c.GetELanguageFallback(t),
            r = e.find((e) => e.language == o);
          return r?.localized_string ?? "";
        }
        static BHasTokenLanguage(e, t) {
          return Boolean(t.find((t) => t.language == e));
        }
      }
      function u(e) {
        return null != _.LocalizeString(e, !0);
      }
      function d(e, ...t) {
        let n = _.LocalizeString(e);
        return void 0 === n ? e : m(n, ...t);
      }
      function m(e, ...t) {
        return 0 == t.length
          ? e
          : (e = e.replace(/%(?:(\d+)\$)?s/g, function (e, n) {
              if (n <= t.length && n >= 1) {
                let e = t[n - 1];
                return String(null == e ? "" : e);
              }
              return e;
            }));
      }
      const h = {
        english: "en",
        german: "de",
        french: "fr",
        italian: "it",
        korean: "ko",
        latam: "es-419",
        spanish: "es",
        schinese: "zh-cn",
        tchinese: "zh-tw",
        russian: "ru",
        thai: "th",
        japanese: "ja",
        brazilian: "pt-br",
        portuguese: "pt",
        polish: "pl",
        danish: "da",
        dutch: "nl",
        finnish: "fi",
        norwegian: "no",
        swedish: "sv",
        hungarian: "hu",
        czech: "cs",
        romanian: "ro",
        turkish: "tr",
        arabic: "ar",
        bulgarian: "bg",
        greek: "el",
        ukrainian: "uk",
        vietnamese: "vi",
        indonesian: "id",
        sc_schinese: "zh-cn",
        koreana: "ko",
      };
      function p() {
        return h[s.TS.LANGUAGE] || null;
      }
      const _ = new c();
      window.LocalizationManager = _;
    },
    4094: (e, t, n) => {
      "use strict";
      n.d(t, {
        TS: () => g,
        Tc: () => h,
        XJ: () => u,
        Pr: () => v,
        td: () => C,
      });
      var o = n(626),
        i = n(5489);
      function s(e) {
        if (!r() || !window.document.cookie) return null;
        const t = document.cookie.match("(^|; )" + e + "=([^;]*)");
        return t && t[2] ? decodeURIComponent(t[2]) : null;
      }
      function r() {
        return !!window.document;
      }
      const a = "webui_config";
      let l;
      function c() {
        const e = (function () {
          let e = "";
          for (let t = 0; t < 24; t++) e += (0, i.Tg)(0, 35).toString(36);
          return e;
        })();
        return (
          (function (e, t, n, o) {
            if (!r()) return;
            o || (o = "/");
            let i = "";
            if (void 0 !== n && n) {
              const e = new Date();
              e.setTime(e.getTime() + 864e5 * n),
                (i = "; expires=" + e.toUTCString());
            }
            document.cookie =
              encodeURIComponent(e) +
              "=" +
              encodeURIComponent(t) +
              i +
              ";path=" +
              o;
          })("sessionid", e, 0),
          e
        );
      }
      function u(e = a) {
        const t = {},
          n = h("config", e);
        n && (delete n.SESSIONID, Object.assign(g, n), (t.config = !0));
        const o = h("userinfo", e);
        o &&
          (Object.assign(f, o),
          (t.userConfig = !0),
          f.is_support &&
            (function () {
              let e = null;
              r() && (e = s(_));
              return Boolean(e && 1 === Number.parseInt(e));
            })() &&
            (f.is_support = !1));
        const i = h("broadcast", e);
        i && (Object.assign(b, i), (t.broadcastConfig = !0));
        const l = h("community", e);
        l && (Object.assign(E, l), (t.communityConfig = !0));
        const c = h("event", e);
        return (
          c && (Object.assign(S, c), (t.eventConfig = !0)),
          (m = !0),
          d.forEach((e) => e()),
          t
        );
      }
      let d = new Set(),
        m = !1;
      function h(e, t = a) {
        return p(e, t, !0);
      }
      function p(e, t = a, n) {
        let o;
        if (
          ((o =
            "string" == typeof t
              ? { NODE_ENV: "production", STEAM_BUILD: "buildbot" }.MOBILE_BUILD
                ? null
                : document.getElementById(t)
              : t),
          o)
        )
          try {
            if (o.hasAttribute("data-" + e)) {
              return JSON.parse(o.getAttribute("data-" + e));
            }
            return null;
          } catch (e) {
            console.error(
              "Failed to parse config for " +
                f.steamid +
                " (" +
                window.location.href +
                ")",
              e,
            );
          }
        else n && console.error("Missing config element #", t);
      }
      const _ = "presentation_mode";
      const g = {
          EUNIVERSE: 0,
          WEB_UNIVERSE: "",
          LANGUAGE: "english",
          SUPPORTED_LANGUAGES: [],
          COUNTRY: "",
          AVATAR_BASE_URL: "",
          MEDIA_CDN_COMMUNITY_URL: "",
          MEDIA_CDN_URL: "",
          CLAN_CDN_ASSET_URL: "",
          COMMUNITY_ASSETS_BASE_URL: "",
          VIDEO_CDN_URL: "",
          COMMUNITY_CDN_URL: "",
          COMMUNITY_CDN_ASSET_URL: "",
          BASE_URL_SHARED_CDN: "",
          STORE_CDN_URL: "",
          PUBLIC_SHARED_URL: "",
          COMMUNITY_BASE_URL: "",
          CHAT_BASE_URL: "",
          STORE_BASE_URL: "",
          STORE_CHECKOUT_BASE_URL: "",
          LOGIN_BASE_URL: "",
          SUPPORT_BASE_URL: "",
          STORE_ICON_BASE_URL: "",
          STORE_ITEM_BASE_URL: "",
          IMG_URL: "",
          STEAMTV_BASE_URL: "",
          HELP_BASE_URL: "",
          PARTNER_BASE_URL: "",
          STATS_BASE_URL: "",
          INTERNAL_STATS_BASE_URL: "",
          BASE_URL_STORE_CDN_ASSETS: "",
          IN_CLIENT: !1,
          USE_POPUPS: !1,
          IN_MOBILE: !1,
          IN_MOBILE_WEBVIEW: !1,
          IN_TENFOOT: !1,
          PLATFORM: "",
          SNR: "",
          LAUNCHER_TYPE: 0,
          EREALM: 0,
          IN_CHROMEOS: !1,
          TESLA: !1,
          LOCAL_HOSTNAME: "",
          WEBAPI_BASE_URL: "",
          TOKEN_URL: "",
          BUILD_TIMESTAMP: 0,
          PAGE_TIMESTAMP: 0,
          FROM_WEB: !1,
          WEBSITE_ID: "Unknown",
          get SESSIONID() {
            return (function () {
              if (!r()) return l || (l = c()), l;
              let e = s("sessionid");
              return e || (e = c()), e;
            })();
          },
          FRIENDSUI_BETA: !1,
          STEAM_TV: !1,
          DEV_MODE: !1,
          IN_STEAMUI: !1,
          IN_GAMEPADUI: !1,
          IN_STEAMUI_SHARED_CONTEXT: !1,
          FORCED_DISPLAY_MODE: void 0,
          ON_DECK: !1,
          ON_FRAME: !1,
          ON_STEAMOS: !1,
          IN_GAMESCOPE: !1,
          IN_LOGIN: !1,
          IN_LOGIN_REFRESH: !1,
          USE_LONGEST_LOC_STRING: !1,
          SILENT_STARTUP: !1,
          CLIENT_SESSION: 0,
        },
        f = {
          logged_in: !1,
          steamid: "",
          accountid: 0,
          account_name: "",
          token: void 0,
          token_use_id: void 0,
          webapi_token: "",
          authwgtoken: "",
          is_support: !1,
          is_limited: !1,
          is_partner_member: !1,
          is_valve_email: !1,
          short_url: "",
          country_code: "",
          excluded_content_descriptors: [3, 4, 1],
        },
        b = { steamid: "", clanid: 0, listid: 0 },
        E = {
          CLANSTEAMID: "",
          CLANACCOUNTID: 0,
          APPID: 0,
          VANITY_ID: "",
          IS_CREATOR_HOME: !1,
          IS_CURATOR: !1,
          IS_OGG: !1,
          CAN_UPLOAD_IMAGES: !1,
          IS_VALVE_GROUP: !1,
          IS_ALLOWED_SC: !1,
        },
        S = { ANNOUNCEMENT_GID: "", TAKEOVER_ANNOUNCEMENT_GID: "" };
      o.createContext({});
      function C() {
        return "windows" == g.PLATFORM;
      }
      function v() {
        return "macos" == g.PLATFORM;
      }
    },
    3808: (e, t, n) => {
      "use strict";
      "VALVE_PUBLIC_PATH" in window
        ? (n.p = window.VALVE_PUBLIC_PATH)
        : console.error(
            "VALVE_PUBLIC_PATH not defined; check for a call to CHTMLHelpers::WebpackConfigScriptlet",
          ),
        123 !== Array.from(new Set([123]))[0] &&
          console.error("Should not include prototypejs.");
    },
  },
  (e) => {
    e.O(0, [997], () => {
      return (t = 587), e((e.s = t));
      var t;
    });
    e.O();
  },
]);
